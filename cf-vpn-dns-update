#!/usr/bin/env bash

# Sample /etc/cloudflare-credentials file:
# API Key auth:
# CF_API_EMAIL=you@example.com
# CF_API_KEY=xxxxxx
#
# Token auth:
# CF_API_TOKEN=xxxxxx
#
# For zerotier auth, put the API token in /etc/zerotier/api-token

cd "$(dirname "$(readlink -f -- "$0")")" || return 9
# shellcheck source=lib/echo.sh
source lib/echo.sh || exit 2

usage() {
  cat <<EOF
Usage: $(basename "$0") MODE [OPTIONS]

Modes:
  --auto                    Run nb + ts + zt sync, then failover
  --failover                Manage failover CNAMEs across nb/ts/zt
  --netbird                 Sync netbird hosts
  --tailscale               Sync tailscale hosts
  --zerotier                Sync zerotier hosts

Global options:
  --debug                   Verbose logging
  --dry-run                 Show actions without applying
  --ttl TTL                 Record TTL (default: 60)
  --zone ZONE               Cloudflare zone (default: brkn.lol)

Cloudflare auth:
  --email EMAIL --api-key KEY   API key auth
  --token TOKEN                 API token auth

Record handling:
  --ignore REGEX            Skip hosts matching regex
  --clean                   Delete stale records
  --strip                   Trim numeric suffixes from hostnames
  --wildcard                Also manage *.host records

Netbird options:
  --netbird

Tailscale options:
  --tailscale

Zerotier options:
  --zt-api-token TOKEN      Zerotier API token (host discovery)

Failover options:
  --failover-zone SUBZONE   Failover subzone (default: vpn)
  --fallback-default MODE   Fallback when none responds: netbird|tailscale|zerotier|none (default: none)
  --nb-zone SUBZONE         Netbird CNAME target subzone (default: nb)
  --ts-zone SUBZONE         Tailscale CNAME target subzone (default: ts)
  --zt-zone SUBZONE         Zerotier CNAME target subzone (default: zt)

EOF
}

reverse_ipv4_record() {
  local ip="$1"
  IFS='.' read -r a b c d <<< "$ip"
  echo "$d.$c.$b.$a"
}

reverse_ipv6_record() {
  local ip="${1//:/}"
  local reversed
  local i
  for (( i=${#ip} - 1; i>=0; i-- ))
  do
    reversed+="${ip:$i:1}."
  done

  # Remove the trailing dot
  echo "${reversed%?}"
}

# Output format: <HOSTNAME> <IPV4> <IPV6>
get_nb_hosts() {
  # FIXME The .netbirdIp field for the current host includes the network cidr
  # eg: 100.54.232.1/16
  netbird status --json | \
    jq -er '
      [{fqdn: .fqdn, netbirdIp: .netbirdIp}, .peers.details[]] |
      sort_by(.fqdn)[] |
        (.fqdn | split(".")[0])
        + "\t" +
        .netbirdIp
    ' | sed -E 's#(.+)/(.+)#\1#g' # strip the CIDR suffix
}

# Output format: <HOSTNAME> <IPV4> <IPV6>
get_ts_hosts() {
  # NOTE Here we extract the hostname from the DNS name to avoid having to deal
  # with multi-word hostnames (eg: Xiaomi Mi Mix 2S)
  # Also, we do filter out items that have an empty DNSName which allows us to
  # skip services (eg: hello.ipn.dev)
  tailscale status --json | \
    jq -er '
      [.Self, .Peer[]] |
      sort_by(.DNSName)[] |
      select(.DNSName != "") |
        ((.DNSName | split("."))[0])
        + "\t" +
        (.TailscaleIPs | join("\t"))
    '
}

zt_token() {
  if [[ -n "$ZEROTIER_API_TOKEN" ]]
  then
    echo "$ZEROTIER_API_TOKEN"
    return 0
  fi

  if [[ -n "$ZEROTIER_API_TOKEN_FILE" && -r "$ZEROTIER_API_TOKEN_FILE" ]]
  then
    cat "$ZEROTIER_API_TOKEN_FILE"
    return 0
  fi

  # try a token file next to the script
  cat "$(cd "$(dirname "$0")" >/dev/null 2>&1; pwd -P)/token" || return 1
}

zt_api() {
  local api_host=${ZEROTIER_API_ENDPOINT:-https://api.zerotier.com/api/v1}
  local token
  token="$(zt_token)"

  if [[ -z "$token" ]]
  then
    echo "No API token set" >&2
    return 1
  fi

  local endpoint="$1"

  curl -fsSL \
    --header "Authorization: token $token" \
    "${api_host}/${endpoint}"
}

zt_network() {
  zt_api "network"
}

zt_first_network_id() {
  zt_network | jq -r '.[0].id'
}

zt_network_id() {
  local network_name="${1:-$ZEROTIER_NETWORK_NAME}"
  zt_network | jq -er --arg name "$network_name" '
    .[] | select(.config.name == $name) | .id'
}

zt_network_members() {
  local network_id="${1:-$(zt_first_network_id)}"
  zt_api "network/${network_id}/member"
}

# shellcheck disable=SC2120
get_zt_hosts() {
  local network_name="${1:-$ZEROTIER_NETWORK_NAME}"
  local network_id

  if [[ -n "$network_name" ]]
  then
    network_id=$(zt_network_id "$network_name")
    if [[ -z "$network_id" ]]
    then
      echo_error "Failed to find network with name '$network_name'" >&2
      exit 1
    fi
  else
    network_id=$(zt_first_network_id)
  fi

  if [[ -z "$network_id" ]]
  then
    echo_error "Failed to find zt network ID" >&2
    return 1
  fi

  zt_network_members "$network_id" | jq -er '
    sort_by(.name)
    | .[]
    | select(
      .hidden == false
      and
      # not-yet accept hosts will have no IP assigned
      # to add then you need to accept them first
      # https://my.zerotier.com/login
      (.config.ipAssignments[] | length > 0)
    )
    | .name + "\t" + .config.ipAssignments[0]
  '
}

get_hosts() {
  local hosts

  case "$VPN_TYPE" in
    netbird)
      hosts=$(get_nb_hosts)
      ;;
    tailscale)
      hosts=$(get_ts_hosts)
      ;;
    zerotier)
      hosts=$(get_zt_hosts)
      ;;
    *)
      echo_error "Missing --netbird, --tailscale or --zerotier" >&2
      exit 2
      ;;
  esac

  if [[ -z "$hosts" ]]
  then
    echo_warning "No $VPN_TYPE hosts found"
    return 1
  fi

  if [[ -n "$STRIP_HOSTNAMES" ]]
  then
    # Remove the trailing numbers from the hostnames (if any)
    # these typically get assigned when multiple hosts have the same name
    # or to ephemeral hosts
    # eg: "myhost-01" -> "myhost-01-130-220", etc.
    # this should be fine with hostnames like myhost-01
    hosts=$(sed -E ':a; s/^([^[:space:]]*-[0-9]+)-[0-9]+([[:space:]]|$)/\1\2/; ta' <<< "$hosts")
  fi

  if [[ -n "$IGNORE_REGEX" ]]
  then
    hosts=$(grep -vE "$IGNORE_REGEX" <<< "$hosts")
  fi

  printf '%s' "$hosts"
}

normalize_host() {
  local host="$1"

  if [[ -n "$STRIP_HOSTNAMES" ]]
  then
    host="$(sed -E ':a; s/^([^[:space:]]*-[0-9]+)-[0-9]+$/\1/; ta' <<< "$host")"
  fi

  if [[ -n "$IGNORE_REGEX" && "$host" =~ $IGNORE_REGEX ]]
  then
    return 1
  fi

  echo "$host"
}

trim_string() {
  local str="$1"
  # Trim leading whitespace
  while [[ "$str" == " "* ]]
  do
    str="${str# }"
  done
  # Trim trailing whitespace
  while [[ "$str" == *" " ]]
  do
    str="${str% }"
  done
  echo "$str"
}

ping_host() {
  local ip="$1"

  if [[ -z "$ip" ]]
  then
    return 1
  fi

  local ping_bin="ping"
  local -a ping_args=("-4" "-c" "1" "-W" "1")

  if [[ "$ip" == *:* ]]
  then
    ping_args=("-6" "-c" "1" "-W" "1")
  fi

  if ! command -v "$ping_bin" >/dev/null 2>&1
  then
    echo_error "No ping binary available"
    return 1
  fi

  "$ping_bin" "${ping_args[@]}" "$ip" >/dev/null 2>&1
}

is_vpn_ip() {
  local ip="$1"

  if [[ "$ip" == *:* ]]
  then
    [[ "$ip" =~ ^f[c-d][0-9a-fA-F]*: ]]
    return
  fi

  [[ "$ip" == 10.* || "$ip" == 100.* ]]
}

resolve_ips() {
  local family_flag="$1"
  local name="$2"

  if ! command -v dig >/dev/null 2>&1
  then
    return 1
  fi

  local type="A"
  if [[ "$family_flag" == "-6" ]]
  then
    type="AAAA"
  fi

  dig +short "$name" "$type" | sort -u
}

ping_any() {
  local ips="$1"

  if [[ -z "$ips" ]]
  then
    return 1
  fi

  ips="${ips//,/ }"
  ips="${ips//$'\t'/ }"

  local token ip
  local -a resolved

  for token in $ips
  do
    resolved=()

    if [[ "$token" == *.* || "$token" == *:* ]]
    then
      resolved=("$token")
    else
      mapfile -t resolved < <(resolve_ips -4 "$token")
      if [[ "${#resolved[@]}" -eq 0 ]]
      then
        mapfile -t resolved < <(resolve_ips -6 "$token")
      fi
    fi

    if [[ "${#resolved[@]}" -eq 0 ]]
    then
      continue
    fi

    for ip in "${resolved[@]}"
    do
      if ! is_vpn_ip "$ip"
      then
        continue
      fi

      if ping_host "$ip"
      then
        return 0
      fi
    done
  done

  return 1
}

record_target() {
  local host="$1"
  local nb_ip="$2"
  local ts_ip="$3"
  local zt_ip="$4"

  local nb_up
  local ts_up
  local zt_up
  local record_type="CNAME"
  local record_value

  if ping_any "$nb_ip"
  then
    nb_up=1
  fi

  if ping_any "$ts_ip"
  then
    ts_up=1
  fi

  if ping_any "$zt_ip"
  then
    zt_up=1
  fi

  if [[ -n "${nb_up:-}" ]]
  then
    record_value="${host}.${NB_SUBZONE}.${ZONE_NAME}"
    echo "$record_type $record_value"
    return 0
  fi

  if [[ -n "${ts_up:-}" ]]
  then
    record_value="${host}.${TS_SUBZONE}.${ZONE_NAME}"
    echo "$record_type $record_value"
    return 0
  fi

  if [[ -n "${zt_up:-}" ]]
  then
    record_value="${host}.${ZT_SUBZONE}.${ZONE_NAME}"
    echo "$record_type $record_value"
    return 0
  fi

  record_target_fallback "$host" "$nb_ip" "$ts_ip" "$zt_ip"
}

# Output one or more "<TYPE> <VALUE>" lines for the selected fallback.
record_target_fallback() {
  local host="$1"
  local nb_ip="$2"
  local ts_ip="$3"
  local zt_ip="$4"

  local fallback="${FALLBACK_DEFAULT:-none}"
  local ipv4 ipv6

  case "$fallback" in
    none)
      echo "CNAME ${host}.${ZONE_NAME}"
      return 0
      ;;
    netbird)
      ipv4="$(first_ipv4_from_tokens "$nb_ip")"
      ipv6="$(first_ipv6_from_tokens "$nb_ip")"
      ;;
    tailscale)
      ipv4="$(first_ipv4_from_tokens "$ts_ip")"
      ipv6="$(first_ipv6_from_tokens "$ts_ip")"
      ;;
    zerotier)
      ipv4="$(first_ipv4_from_tokens "$zt_ip")"
      ipv6="$(first_ipv6_from_tokens "$zt_ip")"
      ;;
    *)
      echo_error "Unsupported --fallback-default: $fallback" >&2
      return 1
      ;;
  esac

  if [[ -n "$ipv4" ]]
  then
    echo "A $ipv4"
  fi

  if [[ -n "$ipv6" ]]
  then
    echo "AAAA $ipv6"
  fi

  if [[ -z "$ipv4" && -z "$ipv6" ]]
  then
    echo "CNAME ${host}.${ZONE_NAME}"
  fi
}

# Extract the first IPv4 address from a whitespace/tab/comma-separated string.
first_ipv4_from_tokens() {
  local tokens="$1"
  tokens="${tokens//,/ }"
  tokens="${tokens//$'\t'/ }"

  local token
  for token in $tokens
  do
    if [[ "$token" == *.* && "$token" != *:* ]]
    then
      echo "$token"
      return 0
    fi
  done

  return 1
}

# Extract the first IPv6 address from a whitespace/tab/comma-separated string.
first_ipv6_from_tokens() {
  local tokens="$1"
  tokens="${tokens//,/ }"
  tokens="${tokens//$'\t'/ }"

  local token
  for token in $tokens
  do
    if [[ "$token" == *:* ]]
    then
      echo "$token"
      return 0
    fi
  done

  return 1
}

record_suffix_for_type() {
  local type="${1:-$VPN_TYPE}"

  case "$type" in
    netbird)
      echo "$NB_SUBZONE"
      ;;
    tailscale)
      echo "$TS_SUBZONE"
      ;;
    zerotier)
      echo "$ZT_SUBZONE"
      ;;
    failover)
      echo "$FAILOVER_ZONE"
      ;;
    *)
      echo ""
      ;;
  esac
}

cleanup_records() {
  local records_to_delete

  records_to_delete=$(get_hosts_to_delete)

  if [[ -z "$records_to_delete" ]]
  then
    echo_info "No records to delete"
    return 0
  fi

  local rc=0
  while read -r RECORD
  do
    read -r RECORD_ID RECORD_NAME <<<"$RECORD"
    echo_warning "â˜ ï¸ Deleting record: $RECORD_NAME"

    if [[ -n "$DRY_RUN" ]]
    then
      echo_dryrun "Delete record: $RECORD_NAME"
      continue
    fi

    if ! cf_delete_record "$RECORD_ID"
    then
      rc=1
    fi
  done < <(<<<"$records_to_delete" jq -cr '.ID + " " + .Name')

  return "$rc"
}

sync_vpn_hosts() {
  local type="$1"
  VPN_TYPE="$type"

  CLEAN_SUFFIX="$(record_suffix_for_type "$type")"

  RECORDS="$(cf_get_records "$ZONE_NAME")"
  PTR_RECORDS=()
  VPN_RECORDS=()

  if ! mapfile -t VPN_HOSTS < <(get_hosts)
  then
    return 1
  fi

  if [[ "${#VPN_HOSTS[@]}" -eq 0 ]]
  then
    echo_error "No VPN hosts found. This can't be right. Aborting." >&2
    return 1
  fi

  local errors=0
  local rc=0

  local suffix
  suffix="$(record_suffix_for_type "$type")"

  for line in "${VPN_HOSTS[@]}"
  do
    read -r host ipv4 ipv6 <<< "$line"
    echo_info "ðŸ–¥ï¸ Host: $host - IPv4: $ipv4 - IPv6: ${ipv6:-N/A}"

    record="$host"
    if [[ -n "$suffix" ]]
    then
      record="${record}.${suffix}"
    fi

    VPN_RECORDS+=("${record}.${ZONE_NAME}")

    if ! cf_record_update "$record" A "$ipv4"
    then
      errors=$((errors + 1))
    fi

    if [[ -n "$PTR" ]]
    then
      IPV4_REVERSED=$(reverse_ipv4_record "$ipv4")
      if ! cf_record_update "$IPV4_REVERSED" PTR "${record}.${ZONE_NAME}"
      then
        errors=$((errors + 1))
      fi
      PTR_RECORDS+=("$IPV4_REVERSED")
    fi

    if [[ -n "$HOST_WILDCARD" ]]
    then
      if ! cf_record_update "*.${record}" A "$ipv4"
      then
        errors=$((errors + 1))
      fi
      VPN_RECORDS+=("*.${record}.${ZONE_NAME}")
    fi

    if [[ -n "$ipv6" ]]
    then
      if ! cf_record_update "$record" AAAA "$ipv6"
      then
        errors=$((errors + 1))
      fi

      if [[ -n "$HOST_WILDCARD" ]]
      then
        if ! cf_record_update "*.$record" AAAA "$ipv6"
        then
          errors=$((errors + 1))
        fi
      fi

      if [[ -n "$PTR" ]]
      then
        IPV6_REVERSED=$(reverse_ipv6_record "$ipv6")
        if ! cf_record_update "$IPV6_REVERSED" PTR "${record}.${ZONE_NAME}"
        then
          errors=$((errors + 1))
        fi
        PTR_RECORDS+=("$IPV6_REVERSED")
      fi
    fi
  done

  rc="$?"
  if [[ "$errors" -eq 0 ]]
  then
    echo_success "There were no errors updating the records."
    rc=0
  else
    echo_error "There were $errors errors updating the records."
    rc=1
  fi

  if [[ -n "$CLEAN" ]]
  then
    cleanup_records || rc=1
  fi

  return "$rc"
}

get_hosts_to_delete() {
  local a_records_json ptr_records_json
  a_records_json="$(printf '%s\n' "${VPN_RECORDS[@]}" | jq -Rnc '[inputs]')"
  ptr_records_json="$(printf '%s\n' "${PTR_RECORDS[@]}" | jq -Rnc '[inputs]')"

  cf_get_records "$ZONE_NAME" | \
    jq -er \
      --arg zone "$ZONE_NAME" \
      --arg suffix "$CLEAN_SUFFIX" \
      --arg ignore "$IGNORE_REGEX" \
      --argjson hosts "$a_records_json" \
      --argjson ptrs "$ptr_records_json" \
      '
        .[] | select(

          # A/AAAA records
          (
            # Filter by zone and type
            (.Name | endswith(
              (if $suffix == "" then "" else $suffix + "." end) + $zone
            ))
            and
            (.Type == "A" or .Type == "AAAA")

            # Check if entry is not in the hosts list
            and
            (.Name | IN($hosts[]) | not)

            # skip ignored hosts
            and (
              if $ignore == ""
              then
                true
              else
                (.Name | test($ignore) | not)
              end
            )
          )

          # PTR records
          or (
            # Filter by zone and type
            (.Content | endswith(
              (if $suffix == "" then "" else $suffix + "." end) + $zone
            ))
            and
            (.Type == "PTR")

            and
            ((.Name | gsub(("." + $zone + "$"); "") | IN($ptrs[]) | not))

            # TODO Skip ignored hosts here as well?
            # and
            # (.Content | test($ignore) | not)
          )
        )
    '
}

cf() {
  if [[ -n "$DEBUG" ]]
  then
    echo_debug "\$ flarectl $*" >&2
  fi
  export CF_API_TOKEN CF_API_EMAIL CF_API_KEY
  command flarectl "$@"
}

cf_record_update() {
  local zone="${ZONE_NAME:-brkn.lol}"
  local ttl="${TTL}"

  local name="$1"
  local type="$2"
  local content="$3"

  local fqdn="${name}.${zone}"

  if [[ -n "$DRY_RUN" ]]
  then
    echo_dryrun "Create/update record: $type $fqdn $content (TTL $ttl)"
    return 0
  fi

  echo_info "Set record: $type $fqdn $content (TTL $ttl)"

  local -a args=(
    --zone "$zone" --type "$type" --content "$content" --name "$name" --ttl "$ttl"
  )

  local record_id
  record_id="$(cf_get_record_id "$type" "$fqdn")"

  if [[ -z "$record_id" ]]
  then
    local -a existing_ids
    mapfile -t existing_ids < <(cf_get_record_ids_by_name "$fqdn")

    local existing_id existing_type deleted_any
    for existing_id in "${existing_ids[@]}"
    do
      existing_type="$(cf_get_record_type "$existing_id")"

      if cf_record_types_compatible "$type" "$existing_type"
      then
        continue
      fi

      echo_warning "â˜ ï¸ Deleting existing ${existing_type} record to create $type: $fqdn"
      if ! cf_delete_record "$existing_id"
      then
        echo_error "Failed to delete existing record $fqdn ($existing_type)"
        return 1
      fi
      deleted_any=1
    done

    if [[ -n "${deleted_any:-}" ]]
    then
      RECORDS="$(cf_get_records "$ZONE_NAME")"
    fi

    echo_info "ðŸ†• Create record: $type $fqdn $content"
    cf dns create "${args[@]}"
    local rc="$?"
    if [[ "$rc" -ne 0 ]]
    then
      echo_error "Failed to create record: $type $fqdn $content (TTL $ttl)"
    fi
    # Update records
    RECORDS="$(cf_get_records "$ZONE_NAME")"
    return "$rc"
  fi

  # Update record
  local record_content
  record_content="$(cf_get_record_content "$record_id")"
  local record_ttl
  record_ttl="$(cf_get_record_ttl "$record_id")"
  if [[ "$record_content" == "$content" && "$record_ttl" == "$ttl" ]]
  then
    echo_success "âœ… DNS record already up to date: $fqdn $type $content (TTL $ttl)"
    return 0
  fi

  echo_info "ðŸ†™ Updating record: $fqdn $type $content"
  args+=(--id "$record_id")
  cf dns update "${args[@]}"
  local rc="$?"
  if [[ "$rc" -ne 0 ]]
  then
    echo_error "Failed to update record: $type $fqdn $content (TTL $ttl)"
  fi
  return "$rc"
}

cf_delete_record() {
  local record_id="$1"
  # echo_warning "â˜ ï¸ Deleting record: $record_id"
  cf dns delete --zone "$ZONE_NAME" --id "$record_id"
}

# Check whether two DNS record types can coexist on the same name.
cf_record_types_compatible() {
  local new_type="$1"
  local existing_type="$2"

  if [[ "$new_type" == "$existing_type" ]]
  then
    return 0
  fi

  if [[ "$new_type" == "A" && "$existing_type" == "AAAA" ]]
  then
    return 0
  fi

  if [[ "$new_type" == "AAAA" && "$existing_type" == "A" ]]
  then
    return 0
  fi

  if [[ "$new_type" == "CNAME" || "$existing_type" == "CNAME" ]]
  then
    return 1
  fi

  return 0
}

cf_get_records() {
  local zone="${1:-${ZONE_NAME:-brkn.lol}}"
  cf --json dns list --zone="${zone}"
}

cf_get_record_id() {
  local type="$1"
  local name="$2"

  <<< "$RECORDS" jq -r --arg type "${type}" --arg name "${name}" '
    .[] | select(.Type == $type and .Name == $name) |
    .ID'
}

cf_get_record_ids_by_name() {
  local name="$1"

  <<< "$RECORDS" jq -r --arg name "${name}" '
    .[] | select(.Name == $name) |
    .ID'
}

cf_get_record_type() {
  local record_id="$1"

  <<< "$RECORDS" jq -r --arg record_id "${record_id}" '
    .[] | select(.ID == $record_id) |
    .Type'
}

cf_get_record_content() {
  local record_id="$1"

  <<< "$RECORDS" jq -er --arg record_id "${record_id}" '
    .[] | select(.ID == $record_id) |
    .Content'
}

cf_get_record_ttl() {
  local record_id="$1"

  <<< "$RECORDS" jq -er --arg record_id "${record_id}" '
    .[] | select(.ID == $record_id) |
    .TTL'
}

run_failover() {
  local RC=1

  if ! mapfile -t NB_HOSTS_LINES < <(get_nb_hosts)
  then
    NB_HOSTS_LINES=()
  fi

  if ! mapfile -t TS_HOSTS_LINES < <(get_ts_hosts)
  then
    TS_HOSTS_LINES=()
  fi

  if ! mapfile -t ZT_HOSTS_LINES < <(get_zt_hosts)
  then
    ZT_HOSTS_LINES=()
  fi

  declare -A NB_HOSTS
  declare -A TS_HOSTS
  declare -A ZT_HOSTS
  declare -A HOSTS_SEEN

  local host ip normalized
  local -a tail_parts
  for line in "${NB_HOSTS_LINES[@]}"
  do
    IFS=$'\t' read -r host ip <<< "$line"
    host="$(trim_string "$host")"
    if ! normalized="$(normalize_host "$host")"
    then
      continue
    fi
    NB_HOSTS["$normalized"]="$ip"
    HOSTS_SEEN["$normalized"]=1
  done

  for line in "${TS_HOSTS_LINES[@]}"
  do
    IFS=$'\t' read -r -a parts <<< "$line"
    host="${parts[0]}"
    host="$(trim_string "$host")"
    tail_parts=("${parts[@]:1}")
    ip="${tail_parts[*]}"
    if ! normalized="$(normalize_host "$host")"
    then
      continue
    fi
    TS_HOSTS["$normalized"]="$ip"
    HOSTS_SEEN["$normalized"]=1
  done

  for line in "${ZT_HOSTS_LINES[@]}"
  do
    IFS=$'\t' read -r host ip <<< "$line"
    host="$(trim_string "$host")"
    if ! normalized="$(normalize_host "$host")"
    then
      continue
    fi
    ZT_HOSTS["$normalized"]="$ip"
    HOSTS_SEEN["$normalized"]=1
  done

  if [[ "${#HOSTS_SEEN[@]}" -eq 0 ]]
  then
    echo_error "No hosts found on netbird, tailscale or zerotier."
    return 1
  fi

  CLEAN_SUFFIX="$FAILOVER_ZONE"
  VPN_RECORDS=()

  RECORDS="$(cf_get_records "$ZONE_NAME")"

  HOST_LIST=()
  while IFS= read -r host
  do
    HOST_LIST+=("$host")
  done < <(printf '%s\n' "${!HOSTS_SEEN[@]}" | sort)

  ERRORS=0
  local local_nb_ip local_ts_ip local_zt_ip cname
  local record_type target
  local -a actions
  local action
  for host in "${HOST_LIST[@]}"
  do
    local_nb_ip="${NB_HOSTS[$host]:-}"
    local_ts_ip="${TS_HOSTS[$host]:-}"
    local_zt_ip="${ZT_HOSTS[$host]:-}"

    echo_info "ðŸ–¥ï¸ Host: $host - netbird: ${local_nb_ip:-N/A} - tailscale: ${local_ts_ip:-N/A} - zerotier: ${local_zt_ip:-N/A}"

    cname="${host}.${FAILOVER_ZONE}"
    VPN_RECORDS+=("${cname}.${ZONE_NAME}")

    actions=()
    mapfile -t actions < <(record_target "$host" "$local_nb_ip" "$local_ts_ip" "$local_zt_ip")
    if [[ "${#actions[@]}" -eq 0 ]]
    then
      echo_error "Failed to determine failover record target for host: $host"
      ERRORS=$((ERRORS + 1))
      continue
    fi

    for action in "${actions[@]}"
    do
      read -r record_type target <<< "$action"
      if ! cf_record_update "$cname" "$record_type" "$target"
      then
        ERRORS=$((ERRORS + 1))
      fi
    done

    if [[ -n "$HOST_WILDCARD" ]]
    then
      VPN_RECORDS+=("*.${cname}.${ZONE_NAME}")
      for action in "${actions[@]}"
      do
        read -r record_type target <<< "$action"
        if ! cf_record_update "*.${cname}" "$record_type" "$target"
        then
          ERRORS=$((ERRORS + 1))
        fi
      done
    fi
  done

  if [[ "$ERRORS" -eq 0 ]]
  then
    echo_success "There were no errors updating the records."
    RC=0
  fi

  if [[ "$ERRORS" -ne 0 ]]
  then
    echo_error "There were $ERRORS errors updating the records."
    RC=1
  fi

  if [[ -n "$CLEAN" ]]
  then
    cleanup_records || RC=1
  fi

  return "$RC"
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]
then
  set -u -o pipefail

  # flarectl resides in /srv/bin
  export PATH="$PATH:/srv/bin"

  DEBUG="${DEBUG:-}"
  DRY_RUN="${DRY_RUN:-}"
  CLEAN="${CLEAN:-}"
  IGNORE_REGEX="${IGNORE_REGEX:-}"
  STRIP_HOSTNAMES="${STRIP_HOSTNAMES:-}"
  PTR="${PTR:-}"
  VPN_TYPE="${VPN_TYPE:-}"
  ZEROTIER_NETWORK_NAME="${ZEROTIER_NETWORK_NAME:-}"
  ZEROTIER_API_TOKEN="${ZEROTIER_API_TOKEN:-}"
  ZEROTIER_API_TOKEN_FILE="${ZEROTIER_API_TOKEN_FILE:-/etc/zerotier/api-token}"

  CF_CREDENTIALS_FILE="${CF_CREDENTIALS_FILE:-/etc/cloudflare/credentials}"
  CF_API_KEY="${CF_API_KEY:-}"
  CF_API_EMAIL="${CF_API_EMAIL:-}"
  CF_API_TOKEN="${CF_API_TOKEN:-}"
  ZONE_NAME="${ZONE_NAME:-brkn.lol}"
  CLEAN_SUFFIX="${CLEAN_SUFFIX:-}"
  HOST_WILDCARD="${HOST_WILDCARD:-}"
  FAILOVER_ZONE="${FAILOVER_ZONE:-${SUBZONE:-vpn}}"
  NB_SUBZONE="${NB_SUBZONE:-nb}"
  TS_SUBZONE="${TS_SUBZONE:-ts}"
  ZT_SUBZONE="${ZT_SUBZONE:-zt}"
  FAILOVER="${FAILOVER:-}"
  AUTO="${AUTO:-}"
  FALLBACK_DEFAULT="${FALLBACK_DEFAULT:-none}"
  TTL="${TTL:-60}"

  while [[ -n "$*" ]]
  do
    case "$1" in
      help|h|-h|--help)
        usage
        exit 0
        ;;
      -d|--debug)
        DEBUG=1
        shift
        ;;
      -k|--dry-run|--dryrun)
        DRY_RUN=1
        shift
        ;;
      --failover)
        FAILOVER=1
        shift
        ;;
      --auto)
        AUTO=1
        shift
        ;;
      --netbird)
        VPN_TYPE=netbird
        shift
        ;;
      --tailscale)
        VPN_TYPE=tailscale
        shift
        ;;
      --zerotier|zt)
        VPN_TYPE=zerotier
        shift
        ;;
      --clean*)
        CLEAN=1
        shift
        ;;
      -i|--ignore)
        IGNORE_REGEX="$2"
        shift 2
        ;;
      -P|--ptr)
        PTR=1
        shift
        ;;
      -S|--strip)
        STRIP_HOSTNAMES=1
        shift
        ;;
      -e|--email|--cloudflare-email)
        CF_API_EMAIL="$2"
        shift 2
        ;;
      -K|--key|--api-key|--cloudflare-api-key)
        CF_API_KEY="$2"
        shift 2
        ;;
      -t|--cf|--token|--cloudflare-api-token)
        CF_API_TOKEN="$2"
        shift 2
        ;;
      --nb-zone)
        NB_SUBZONE="$2"
        shift 2
        ;;
      --netbird-zone)
        NB_SUBZONE="$2"
        shift 2
        ;;
      --ts-zone)
        TS_SUBZONE="$2"
        shift 2
        ;;
      --tailscale-zone)
        TS_SUBZONE="$2"
        shift 2
        ;;
      --zt-zone)
        ZT_SUBZONE="$2"
        shift 2
        ;;
      --zerotier-zone)
        ZT_SUBZONE="$2"
        shift 2
        ;;
      -w|--wildcard)
        HOST_WILDCARD=1
        shift
        ;;
      --failover-zone|--subzone)
        FAILOVER_ZONE="$2"
        shift 2
        ;;
      --fallback-default)
        FALLBACK_DEFAULT="$2"
        shift 2
        ;;
      -z|-zn|--zn|--zone*)
        ZONE_NAME="$2"
        shift 2
        ;;
      -Z|--zt-api-token|--zerotier-api-token)
        ZEROTIER_API_TOKEN="$2"
        shift 2
        ;;
      *)
        {
          echo_error "Unsupported option: $1"
          usage
        } >&2
        exit 2
        ;;
    esac
  done

  case "$FALLBACK_DEFAULT" in
    none|netbird|tailscale|zerotier)
      ;;
    *)
      {
        echo_error "Unsupported --fallback-default: $FALLBACK_DEFAULT"
        usage
      } >&2
      exit 2
      ;;
  esac

  if [[ -z "$CF_API_KEY" && -z "$CF_API_TOKEN" ]]
  then
    if [[ ! -e "$CF_CREDENTIALS_FILE" ]]
    then
      echo_error "$CF_CREDENTIALS_FILE: file does not exist." >&2
      exit 2
    fi

    # Attempt to source the file
    # shellcheck disable=SC1090
    source "$CF_CREDENTIALS_FILE" || exit 3
  fi

  if [[ -z "$AUTO" && -z "$FAILOVER" && -z "$VPN_TYPE" ]]
  then
    echo_error "Select a mode: --netbird | --tailscale | --zerotier | --failover | --auto"
    usage
    exit 2
  fi

  if [[ -n "$AUTO" ]]
  then
    rc=0
    for mode in netbird tailscale zerotier
    do
      if ! sync_vpn_hosts "$mode"
      then
        rc=1
      fi
    done

    if ! run_failover
    then
      rc=1
    fi

    exit "$rc"
  fi

  if [[ -n "$FAILOVER" ]]
  then
    if run_failover
    then
      exit 0
    fi

    exit 1
  fi

  if sync_vpn_hosts "$VPN_TYPE"
  then
    exit 0
  fi

  exit 1
fi
