#!/usr/bin/env bash

SCRIPT_NAME="$(basename "${BASH_SOURCE[0]}")"

cd "$(dirname "$(readlink -f "$0")")" || return 9

# shellcheck source=lib/echo.sh
source lib/echo.sh || exit 2

CONFIG_FILE="${CONFIG_FILE:-/etc/mmsms.conf}"

MODEM="${MODEM:-any}"
ALL_MODEMS="${ALL_MODEMS:-}"
DEFAULT_MODEM="${DEFAULT_MODEM:-}"

declare -A MODEM_OWN_NUMBER_CACHE=()
declare -A MODEM_SMSC_NUMBER_CACHE=()

SMS_SEND_TIMEOUT="${SMS_SEND_TIMEOUT:-30}"
SMS_RETRY_COUNT="${SMS_RETRY_COUNT:-${SMS_SEND_RETRY_COUNT:-${MAX_RETRY:-3}}}"
SMS_CHUNK_SIZE="${SMS_CHUNK_SIZE:-}"
CMD_OUTPUT_MAX_LEN="${CMD_OUTPUT_MAX_LEN:-4000}"
MAX_MESSAGES_PER_DAY="${MAX_MESSAGES_PER_DAY:-}"
MMMSMS_DATA_DIR_DEFAULT="/var/lib/mmsms"
if [[ -n "${MMMSMS_DATA_DIR:-}" ]]
then
  :
elif [[ -n "${SMS_DAILY_LIMIT_DIR:-}" ]]
then
  MMMSMS_DATA_DIR="$SMS_DAILY_LIMIT_DIR"
else
  MMMSMS_DATA_DIR="$MMMSMS_DATA_DIR_DEFAULT"
fi

if [[ -z "${MMMSMS_DATA_DIR:-}" ]]
then
  MMMSMS_DATA_DIR="$MMMSMS_DATA_DIR_DEFAULT"
fi

SMS_DAILY_LIMIT_DIR="$MMMSMS_DATA_DIR"
SMS_STATS_HISTORY_DAYS="${SMS_STATS_HISTORY_DAYS:-7}"
if [[ ! "$SMS_STATS_HISTORY_DAYS" =~ ^[0-9]+$ ]]
then
  SMS_STATS_HISTORY_DAYS=7
elif (( SMS_STATS_HISTORY_DAYS < 1 ))
then
  SMS_STATS_HISTORY_DAYS=7
fi
STATS_DAY="${STATS_DAY:-}"
STATS_DUMP="${STATS_DUMP:-}"
STATS_RESET="${STATS_RESET:-}"
SMS_DAILY_LIMIT_STATUS=""
SMS_DAILY_LIMIT_GLOBAL_LIMIT=""
SMS_DAILY_LIMIT_KEY=""
SMS_DAILY_LIMIT_LABEL=""
SMS_DAILY_LIMIT_MSISDN=""
declare -A SMS_DAILY_LIMIT_MSISDN_LIMITS=()
declare -a SMS_DAILY_LIMIT_ACTIVE_KEYS=()
declare -A SMS_DAILY_LIMIT_ACTIVE_FILES=()
declare -A SMS_DAILY_LIMIT_ACTIVE_LABELS=()
declare -A SMS_DAILY_LIMIT_ACTIVE_LIMITS=()
declare -A SMS_DAILY_LIMIT_ACTIVE_COUNTS=()
SMS_DAILY_LIMIT_RESERVED=0
SMS_DAILY_LIMIT_SENT=0

AT_FALLBACK_MAX_READS="${AT_FALLBACK_MAX_READS:-25}"
AT_FALLBACK_READ_TIMEOUT="${AT_FALLBACK_READ_TIMEOUT:-0.2}"

AT_WAIT_TIMEOUT_DEFAULT="${AT_WAIT_TIMEOUT_DEFAULT:-60}"
AT_WAIT_SLEEP_INTERVAL="${AT_WAIT_SLEEP_INTERVAL:-2}"
AT_WAIT_MODEM="${AT_WAIT_MODEM:-}"
AT_WAIT_TIMEOUT="${AT_WAIT_TIMEOUT:-0}"

ENABLE_WAIT_TIMEOUT_DEFAULT="${ENABLE_WAIT_TIMEOUT_DEFAULT:-600}"
ENABLE_WAIT_SLEEP_INTERVAL="${ENABLE_WAIT_SLEEP_INTERVAL:-2}"
ENABLE_WAIT_MODEM="${ENABLE_WAIT_MODEM:-}"
ENABLE_WAIT_TIMEOUT="${ENABLE_WAIT_TIMEOUT:-0}"

WEBHOOK_URL="${WEBHOOK_URL:-}"

WATCH_DELETE_AFTER="${WATCH_DELETE_AFTER:-${DELETE_AFTER:-0}}"
WATCH_DELETE_AFTER_CLI_OVERRIDE=""
WATCH_RETRY_SLEEP="${RETRY_SLEEP:-1}"
WATCH_CMD_TIMEOUT="${CMD_TIMEOUT:-8}"
WATCH_CMD_KILL_TIMEOUT="${WATCH_CMD_KILL_TIMEOUT:-${CMD_KILL_TIMEOUT:-20}}"
WATCH_ENABLE="${WATCH_ENABLE:-}"
WATCH_ENABLE_POLL_INTERVAL="${WATCH_ENABLE_POLL_INTERVAL:-5}"
WATCH_PRUNE="${WATCH_PRUNE:-}"

WATCH_MAX_PENDING_PER_MODEM="${WATCH_MAX_PENDING_PER_MODEM:-10}"
WATCH_WORKER_LOCK_SLEEP="${WATCH_WORKER_LOCK_SLEEP:-1}"
declare -A WATCH_WORKER_PIDS=()
WATCH_ASYNC_DIR=""

QUIET="${QUIET:-}"
JSON_OUTPUT="${JSON_OUTPUT:-}"
RAW_OUTPUT="${RAW_OUTPUT:-}"
JSON_OUTPUT_FORCED="${JSON_OUTPUT_FORCED:-}"
RAW_OUTPUT_FORCED="${RAW_OUTPUT_FORCED:-}"
HARD_RESET="${HARD_RESET:-}"
USB_REPLUG="${USB_REPLUG:-}"
SENT_ONLY="${SENT_ONLY:-}"
ALLOW_FOREIGN="${ALLOW_FOREIGN:-}"
HOME_CC="${HOME_CC:-}"
FALLBACK="${FALLBACK:-}"
AUTO_RECIPIENT="${AUTO_RECIPIENT:-}"
PULL_NO_RESTART="${PULL_NO_RESTART:-}"
PULL_HARD_RESET="${PULL_HARD_RESET:-}"
SKIP_MODEM_INIT_PATTERNS=()

# Shared ANSI color codes for consistent styling across outputs
COLOR_RESET='0'
COLOR_CYAN='36'
COLOR_BOLD_RED='1;31'
COLOR_BOLD_GREEN='1;32'
COLOR_BOLD_YELLOW='1;33'
COLOR_BOLD_BLUE='1;34'
COLOR_BOLD_MAGENTA='1;35'
COLOR_BOLD_CYAN='1;36'
COLOR_BOLD_WHITE='1;37'

# Build an ANSI escape sequence for a color code while honoring NO_COLOR/CRON.
ansi_escape() { # $1=colorcode -> ANSI escape sequence honoring NO_COLOR/CRON
  local code="$1"

  if [[ -z "$code" || -n "$NO_COLOR" || -n "$CRON" ]]
  then
    printf ''
    return 0
  fi

  printf '\e[%sm' "$code"
}

# Shared ANSI color codes for consistent styling across outputs
COLOR_RESET='0'
COLOR_CYAN='36'
COLOR_BOLD_RED='1;31'
COLOR_BOLD_GREEN='1;32'
COLOR_BOLD_YELLOW='1;33'
COLOR_BOLD_BLUE='1;34'
COLOR_BOLD_MAGENTA='1;35'
COLOR_BOLD_WHITE='1;37'

# Strip leading and trailing whitespace from a string.
trim() {
  local s="$1"
  s="${s#"${s%%[![:space:]]*}"}"
  s="${s%"${s##*[![:space:]]}"}"
  printf '%s' "$s"
}

# Add a unique skip-modem-init pattern after normalizing input.
add_skip_modem_init_pattern() {
  local pattern
  pattern="$(trim "$1")"
  [[ -z "$pattern" ]] && return 0

  local existing
  for existing in "${SKIP_MODEM_INIT_PATTERNS[@]}"
  do
    if [[ "${existing,,}" == "${pattern,,}" ]]
    then
      return 0
    fi
  done

  SKIP_MODEM_INIT_PATTERNS+=("$pattern")
}

# Populate skip-modem-init patterns from config variables and formats.
apply_skip_modem_init_from_config() {
  local decl

  if decl="$(declare -p SKIP_MODEM_INIT 2>/dev/null)"
  then
    if [[ "$decl" == "declare -a"* ]]
    then
      local pattern
      for pattern in "${SKIP_MODEM_INIT[@]}"
      do
        add_skip_modem_init_pattern "$pattern"
      done
      return 0
    fi
  elif [[ -z "${SKIP_MODEM_INIT:-}" ]]
  then
    return 0
  fi

  local raw="${SKIP_MODEM_INIT:-}"
  if [[ -z "$raw" ]]
  then
    return 0
  fi

  if [[ "$raw" == *$'\n'* ]]
  then
    while IFS= read -r line
    do
      add_skip_modem_init_pattern "$line"
    done <<< "$raw"
  elif [[ "$raw" == *,* ]]
  then
    local -a patterns=()
    local IFS=','
    read -ra patterns <<< "$raw"
    local pattern
    for pattern in "${patterns[@]}"
    do
      add_skip_modem_init_pattern "$pattern"
    done
  else
    add_skip_modem_init_pattern "$raw"
  fi
}

PARSED_ARGS=()
PARSE_SHIFT=0

MODEM_EXPLICIT=""
LOG_ABBREV_LEN="${LOG_ABBREV_LEN:-80}"

# Source the configuration file and apply derived runtime settings.
load_config() {
  echo_debug "loading config: $CONFIG_FILE"

  # shellcheck disable=SC1090
  if ! source "$CONFIG_FILE"
  then
    echo_warning "failed to load config: $CONFIG_FILE"
    return 1
  fi

  apply_skip_modem_init_from_config
}

# Ensure SMS_WHITELIST is defined as an array if provided by the config
if ! declare -p SMS_WHITELIST &>/dev/null
then
  SMS_WHITELIST=()
fi

# Allow overriding the whitelist via SMS_WHITELIST_OVERRIDE (comma or space separated digits)
if [[ -n "${SMS_WHITELIST_OVERRIDE:-}" ]]
then
  # shellcheck disable=SC2206
  SMS_WHITELIST=( ${SMS_WHITELIST_OVERRIDE//,/ } )
elif (( ${#SMS_WHITELIST[@]} == 0 )) && \
     declare -p SMS_WHITELIST_DEFAULT &>/dev/null
then
  SMS_WHITELIST=("${SMS_WHITELIST_DEFAULT[@]}")
fi

WATCH_FIFO=""
WATCH_DBUS_PID=""
WATCH_MODEM_MONITOR_PID=""
MODEM_DETAILS_LOGGED=""

# Return success when plain raw mmcli output without JSON was requested.
raw_plain_requested() {
  [[ -n "$RAW_OUTPUT" && -z "$JSON_OUTPUT" ]]
}

# Return success when raw mmcli JSON output was requested.
raw_json_requested() {
  [[ -n "$RAW_OUTPUT" && -n "$JSON_OUTPUT" ]]
}

# Return success when custom formatted JSON output was requested.
custom_json_requested() {
  [[ -n "$JSON_OUTPUT" && -z "$RAW_OUTPUT" ]]
}

# Return success when any JSON-like output mode should be used.
json_like_requested() {
  raw_json_requested || custom_json_requested
}

# DIRTYFIX OpenWrt's jq is not compiled with ONIGURUMA
jq() {
  if [[ -x /srv/bin/jq ]]
  then
    /srv/bin/jq "$@"
    return $?
  fi

  command jq "$@"
}

# Log and run generic mmcli calls (no implicit --modem)
mmcli() {
  echo_debug "\$ mmcli $*"
  command mmcli "$@"
}

mmcli_cmd() {
  command mmcli --modem "$MODEM" "$@"
}

# Check whether mmcli arguments already specify a modem selection.
mmcli_args_include_modem() {
  local arg
  local expecting_value

  for arg in "$@"
  do
    if [[ -n "$expecting_value" ]]
    then
      return 0
    fi

    case "$arg" in
      --)
        break
        ;;
      -m|--modem)
        expecting_value=1
        ;;
      -m*)
        return 0
        ;;
      --modem=*)
        return 0
        ;;
    esac
  done

  return 1
}

# Check whether adding an implicit --modem would conflict with the provided args.
mmcli_args_allow_modem_injection() {
  local arg

  for arg in "$@"
  do
    case "$arg" in
      -L|--list-modems)
        return 1
        ;;
      --)
        break
        ;;
    esac
  done

  return 0
}

# Run a single mmcli invocation targeting the provided modem when possible.
mmcli_passthrough_invoke() {
  local target_modem="$1"
  shift
  local -a mmcli_args=("$@")
  local add_modem
  local rc

  if [[ -n "$target_modem" && "$target_modem" != "any" ]]
  then
    if mmcli_args_allow_modem_injection "${mmcli_args[@]}"
    then
      if ! mmcli_args_include_modem "${mmcli_args[@]}"
      then
        add_modem=1
      fi
    fi
  fi

  if [[ -n "$add_modem" ]]
  then
    mmcli_args=(--modem "$target_modem" "${mmcli_args[@]}")
  fi

  mmcli "${mmcli_args[@]}"
  rc=$?
  return "$rc"
}

# Run mmcli with passthrough arguments, injecting --modem when appropriate.
mmcli_passthrough() {
  local -a mmcli_args=("$@")
  local rc

  if [[ -n "$ALL_MODEMS" ]]
  then
    if mmcli_args_allow_modem_injection "${mmcli_args[@]}"
    then
      local -a mids
      if ! mapfile -t mids < <(list_modem_ids_sorted)
      then
        echo_error "failed to list modems for mmcli passthrough"
        return 1
      fi

      if (( ${#mids[@]} == 0 ))
      then
        return 0
      fi

      local mid
      local sub_rc
      rc=0

      for mid in "${mids[@]}"
      do
        if [[ -z "$mid" ]]
        then
          continue
        fi

        if ! mmcli_passthrough_invoke "$mid" "${mmcli_args[@]}"
        then
          sub_rc=$?
          if (( rc == 0 ))
          then
            rc=$sub_rc
          fi
        fi
      done

      return "$rc"
    fi
  fi

  mmcli_passthrough_invoke "$MODEM" "${mmcli_args[@]}"
  rc=$?
  return "$rc"
}

# Print the top-level usage summary for the script.
usage() {
  cat <<USAGE
Usage: $SCRIPT_NAME [OPTIONS] COMMAND [ARGS]

Options:
  -A, --auto            Fallback: if foreign blocked, use modem's default recipient
  -a, --all             List/Prune/Enable/Status/Reset/Number/SMSC/Stats: operate on all modems
  -c, --config PATH     Use alternate config file for watch
      --data-dir PATH   Override SMS data directory (MMMSMS_DATA_DIR)
  -d, --debug           Enable debug output
  -F, --fallback        Send/Watch: on failure, try other modem(s)
      --chunk[=SIZE]   Send: split SMS text into SIZE-character chunks (default: 160)
  -f, --allow-foreign   Send: allow sending to foreign country codes
  -H, --hard            Reset: also stop/start modemmanager (hard reset)
      --replug         Reset: temporarily deauthorize the modem's USB device via sysfs
  -j, --json            Output JSON (for list/status/read/number/smsc/stats)
  -m, --modem MODEM     Modem selector or id (default: $MODEM)
                        Accepts id (e.g. 2), dbus path, 'any', or
                        a string matching manufacturer/plugin/ttyUSB/phone-number
                        or country (fr/de/us) or country name (france/germany/us)
  -q, --quiet           Suppress info output (warnings/errors only) and status output (exit code only)
      --silent          Same as --quiet
  -r, --raw             Use mmcli output format; combine with --json for raw mmcli JSON
  -R, --retry COUNT     Set SMS send retry attempts (default: ${SMS_RETRY_COUNT})
  -s, --syslog          Mirror logs to syslog (in addition to stderr)
  -S, --sent            Prune: delete only sent outgoing messages
      --skip-modem-init PATTERN
                        Enable: skip vendor-specific modem initialization when
                        modem details match PATTERN (repeatable)
  -x, --trace           Enable shell tracing (set -x)
  -h, --help            Show this help and exit

Commands:
  at [AT_COMMAND]            Issue AT command to modem (interactive if no COMMAND)
  enable                     Wait for ModemManager and enable the modem
  list                       List SMS messages on the modem
  logs [LOGREAD_ARGS]        Show log entries from logread
  mmcli|raw [--] [MMCLI_ARGS]
                             Run mmcli with optional modem resolution and pass-through args
  number|phone [-a|--all] [-j|--json]
                             Print modem's own phone number
  prune                      Delete all SMS messages from the modem
  read MESSAGE_ID            Show details for a specific SMS
  restart                    Restart modemmanager, issue vendor reset, re-enable modem
  send RECIPIENT [TEXT|-]    Send SMS; use '-' or stdin for TEXT
  pull [--hard] [--no-restart]
                             Update repository and restart service
  service [ACTION]           Control the ${SCRIPT_NAME} service (start|stop|restart|status)
  smsc [-a|--all] [-j|--json]
                             Print modem's configured SMSC number
  stats [-a|--all] [-j|--json]
                             Show daily SMS usage totals for outgoing, failed, and incoming messages
  status                     Show modem status summary
  watch                      Monitor incoming SMS and forward/execute actions
USAGE
}

# Subcommand-specific usage helpers (concise, focused on per-command flags)
# Print usage details for the at subcommand.
usage_at() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] at [OPTIONS] [COMMAND]

Issue and AT command to the modem's AT port. If COMMAND is omitted, enters interactive mode.

Relevant flags:
  -w, --wait[=SECONDS]  Wait for the modem AT port before running the command.
                        Defaults to ${AT_WAIT_TIMEOUT_DEFAULT}s when no value is provided.
                        Use 0 to wait indefinitely.
USAGE
}

# Subcommand-specific usage helpers (concise, focused on per-command flags)
# Print usage details for the send subcommand.
usage_send() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] send [RECIPIENT] TEXT|-

Sends an SMS. If RECIPIENT is omitted, uses DEFAULT_RECIPIENT_XX/CC/DEFAULT.

Relevant flags:
  -A, --auto           During fallback, use modem default recipient if original blocked (cc restriction)
  -c, --config PATH    Load config for defaults (only needed outside 'watch')
  -F, --fallback       Try other modems on failure (sorted by id)
      --chunk[=SIZE]   Split message into SIZE-character chunks (default: 160 when omitted)
  -f, --allow-foreign  Allow sending outside the modem's home country code
  -R, --retry COUNT    Override SMS resend attempts
USAGE
}

# Print usage details for the list subcommand.
usage_list() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] list [-a|--all] [-j|--json] [-r|--raw]

Lists SMS messages. Pretty by default; --json prints structured JSON; --raw prints mmcli output
(combine with --json for mmcli JSON).

Relevant flags:
  -a, --all    Include messages from all modems
  -j, --json   Output custom JSON array
  -r, --raw    Output mmcli-format details (combine with --json for mmcli JSON)
USAGE
}

# Print usage details for the logs subcommand.
usage_logs() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] logs [LOGREAD_ARGS]

Prints $SCRIPT_NAME-related log entries from logread (if available). Extra args passed to logread.
USAGE
}

# Print usage details for the read subcommand.
usage_read() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] read MESSAGE_ID [-j|--json] [-r|--raw]

Reads a single SMS. --json outputs compact structured JSON; --raw outputs mmcli output
(combine with --json for mmcli JSON).
USAGE
}

# Print usage details for the prune subcommand.
usage_prune() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] prune [-a|--all] [-S|--sent]

Deletes messages. By default deletes all on the selected modem.

Relevant flags:
  -a, --all    Operate on all modems
  -S, --sent   Delete only sent (outgoing, state=sent) messages
USAGE
}

# Print usage details for the enable subcommand.
usage_enable() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] enable [-a|--all] [-w|--wait[=SECONDS]]

Enables the selected modem. With --wait, waits for a matching modem to appear
before enabling it (optionally limited by SECONDS).

Relevant flags:
  -a, --all    Enable all detected modems
  -w, --wait[=SECONDS]
                Wait for modem detection before enabling (default timeout: 600s)
      --skip-modem-init PATTERN
                 Skip vendor-specific modem initialization when modem details
                 match PATTERN (repeatable)
USAGE
}

# Print usage details for the service subcommand.
usage_service() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] service start|stop|restart|status|debug [-- WATCH_FLAGS...]

Control the $SCRIPT_NAME service.

Actions:
  start                     Start the $SCRIPT_NAME service
  stop                      Stop the $SCRIPT_NAME service
  restart                   Restart the $SCRIPT_NAME service
  status                    Show current service status
  debug [-- WATCH_FLAGS...] Stop the service, run $SCRIPT_NAME watch with WATCH_FLAGS (defaults:
                            --debug --all --enable), then start the service again
USAGE
}

# Print usage details for the pull subcommand.
usage_pull() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] pull [--hard] [--no-restart]

Updates the $SCRIPT_NAME repository via git pull. With --hard, runs
git reset --hard before pulling. Use --no-restart to skip restarting the
service after pulling.
USAGE
}

# Print usage details for the status subcommand.
usage_status() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] status [-a|--all] [-j|--json] [-r|--raw]

Shows modem status. --json outputs structured JSON; --raw dumps mmcli output
(combine with --json for mmcli JSON). (Default command)

Relevant flags:
  -a, --all    Include all detected modems
  -j, --json   Output structured JSON
  -r, --raw    Output mmcli status (combine with --json for mmcli JSON)
USAGE
}

# Print usage details for the reset subcommand.
usage_reset() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] reset [-a|--all] [-H|--hard] [--replug]

Resets the selected modem. Issues vendor-specific resets when supported.

Relevant flags:
  -a, --all    Reset all detected modems
  -H, --hard   Stop/start ModemManager around reset
      --replug Temporarily deauthorize/reauthorize the modem's USB device
USAGE
}

# Print usage details for the watch subcommand.
usage_watch() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] watch [-A|--auto-recipient] [-a|--all] [-c|--config PATH] [-E|--enable] [-F|--fallback] [-f|--allow-foreign] [-P|--prune] [-R|--retry COUNT] [--delete-sent]

Watches incoming SMS and executes reply/webhook logic.

Relevant flags:
  -A, --auto, --auto-recipient  When fallback, use modem defaults if original blocked
  -a, --all           Process messages from all modems (default: selected modem only)
  -c, --config PATH   Config file with defaults and whitelist
  -E, --enable        Enable selected modem(s) when starting watch; keep enabling new modems with --all
  -F, --fallback      When replying, try other modems on failure (sorted by id)
  -f, --allow-foreign Allow replies to recipients outside the modem's home CC
  -P, --prune         Delete existing SMS on startup before watching
  -R, --retry COUNT   Override SMS resend attempts
      --delete-sent   Delete SMS from the modem after handling (default: keep)
USAGE
}

# Print usage details for the number subcommand.
usage_number() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] number|phone [-a|--all] [-j|--json]

Prints the modem's own number (MSISDN) if reported.

Relevant flags:
  -a, --all    Query all detected modems
  -j, --json   Output structured JSON
USAGE
}

# Print usage details for the smsc subcommand.
usage_smsc() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] smsc [-a|--all] [-j|--json]

Prints the modem\'s configured SMSC (service center) number when available.

Relevant flags:
  -a, --all    Query all detected modems
  -j, --json   Output structured JSON
USAGE
}

# Print usage details for the stats subcommand.
usage_stats() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] stats [-a|--all] [-j|--json] [--day DATE|--dump] [--reset]

Displays daily SMS usage totals for outgoing, failed, and incoming messages.

Relevant flags:
  -a, --all         Show statistics for all tracked lines
  -j, --json        Output structured JSON
      --day DATE    Display statistics for DATE (YYYY-MM-DD)
      --dump        Show the full retained history
      --reset       Remove stored usage statistics
USAGE
}

# Print usage details for the mmcli/raw subcommand.
usage_mmcli() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] mmcli|raw [--] [MMCLI_ARGS...]

Runs mmcli with optional modem selection handled by mmsms.
Examples:
  $SCRIPT_NAME raw -L
  $SCRIPT_NAME -m de mmcli
  $SCRIPT_NAME -m fr raw -- -e
USAGE
}

# Dispatch to the usage helper for the requested subcommand.
print_subcommand_usage() {
  case "$1" in
    at)      usage_at      ;;
    send)    usage_send    ;;
    list)    usage_list    ;;
    logs)    usage_logs    ;;
    read)    usage_read    ;;
    prune)   usage_prune   ;;
    enable)  usage_enable  ;;
    status)  usage_status  ;;
    reset)   usage_reset   ;;
    pull)    usage_pull    ;;
    service) usage_service ;;
    watch)   usage_watch   ;;
    number)  usage_number  ;;
    smsc)    usage_smsc    ;;
    stats)   usage_stats   ;;
    mmcli)   usage_mmcli   ;;
    *)       usage         ;;
  esac
}

# Check whether a token matches one of the supported commands.
is_command_token() {
  local token="$1"

  case "$token" in
    at|ati|send|s|list|ls|l|-l|logs|log*|read|get|r|prune|clear|delete|-e|*enable*|en|start|status|stat|st|stats|number|phone|reset|rst|restart|pull|service|svc|watch|w|smsc|raw|mmcli|help)
      return 0
      ;;
  esac

  return 1
}

# Parse command-line options common to all subcommands.
parse_common_option() {
  PARSE_SHIFT=0
  local opt="$1"
  local value="${2:-}"

  case "$opt" in
    -m|--modem)
      if [[ -z "$value" ]]
      then
        echo_error "missing value for $opt"
        return 2
      fi
      DEBUG_FLAGS+=("${opt}=$value")
      MODEM="$value"
      MODEM_EXPLICIT=1
      PARSE_SHIFT=2
      return 0
      ;;
    -d|--debug)
      DEBUG_FLAGS+=("$opt")
      # shellcheck disable=SC2034
      DEBUG=1
      PARSE_SHIFT=1
      return 0
      ;;
    -q|--quiet|--silent)
      DEBUG_FLAGS+=("$opt")
      QUIET=1
      PARSE_SHIFT=1
      return 0
      ;;
    -x|--trace)
      DEBUG_FLAGS+=("$opt")
      PS4='+ [${BASH_SOURCE##*/}:${LINENO}] ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
      set -x
      PARSE_SHIFT=1
      return 0
      ;;
    -s|--syslog)
      DEBUG_FLAGS+=("$opt")
      # shellcheck disable=SC2034
      ECHO_SYSLOG=1
      PARSE_SHIFT=1
      return 0
      ;;
    -c|--config)
      if [[ -z "$value" ]]
      then
        echo_error "missing value for $opt"
        return 2
      fi
      DEBUG_FLAGS+=("${opt}=$value")
      CONFIG_FILE="$value"
      PARSE_SHIFT=2
      return 0
      ;;
    --data-dir)
      if [[ -z "$value" ]]
      then
        echo_error "missing value for $opt"
        return 2
      fi
      DEBUG_FLAGS+=("${opt}=$value")
      MMMSMS_DATA_DIR="$value"
      SMS_DAILY_LIMIT_DIR="$MMMSMS_DATA_DIR"
      PARSE_SHIFT=2
      return 0
      ;;
    --data-dir=*)
      local data_dir_value
      data_dir_value="${opt#*=}"
      if [[ -z "$data_dir_value" ]]
      then
        echo_error "missing value for --data-dir"
        return 2
      fi
      DEBUG_FLAGS+=("--data-dir=$data_dir_value")
      MMMSMS_DATA_DIR="$data_dir_value"
      SMS_DAILY_LIMIT_DIR="$MMMSMS_DATA_DIR"
      PARSE_SHIFT=1
      return 0
      ;;
    --skip-modem-init)
      if [[ -z "$value" ]]
      then
        echo_error "missing value for $opt"
        return 2
      fi
      DEBUG_FLAGS+=("${opt}=$value")
      add_skip_modem_init_pattern "$value"
      PARSE_SHIFT=2
      return 0
      ;;
    --skip-modem-init=*)
      local pattern
      pattern="${opt#*=}"
      if [[ -z "$pattern" ]]
      then
        echo_error "missing value for --skip-modem-init"
        return 2
      fi
      DEBUG_FLAGS+=("--skip-modem-init=$pattern")
      add_skip_modem_init_pattern "$pattern"
      PARSE_SHIFT=1
      return 0
      ;;
  esac

  PARSE_SHIFT=0
  return 1
}

# Parse arguments for the at command and record leftovers in PARSED_ARGS.
parse_at_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage at
        PARSED_ARGS=()
        return 64
        ;;
      -w|--wait)
        AT_WAIT_MODEM=1
        if [[ ! "$AT_WAIT_TIMEOUT" =~ ^[0-9]+$ ]] || (( AT_WAIT_TIMEOUT <= 0 ))
        then
          AT_WAIT_TIMEOUT="$AT_WAIT_TIMEOUT_DEFAULT"
        fi
        shift
        if [[ -n "${1:-}" && "${1:-}" =~ ^[0-9]+$ ]]
        then
          AT_WAIT_TIMEOUT="$1"
          shift
        fi
        continue
        ;;
      -w=*|--wait=*)
        local wait_value
        wait_value="${1#*=}"
        if [[ -z "$wait_value" ]]
        then
          echo_error "missing value for --wait"
          return 2
        fi
        if [[ ! "$wait_value" =~ ^[0-9]+$ ]]
        then
          echo_error "invalid value for --wait: '$wait_value' (expected integer seconds)"
          return 2
        fi
        AT_WAIT_MODEM=1
        AT_WAIT_TIMEOUT="$wait_value"
        shift
        continue
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

# Parse arguments for the send command and record leftovers in PARSED_ARGS.
parse_send_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage send
        PARSED_ARGS=()
        return 64
        ;;
      -A|--auto|--auto-recipient)
        DEBUG_FLAGS+=("$1")
        AUTO_RECIPIENT=1
        shift
        continue
        ;;
      -F|--fallback)
        DEBUG_FLAGS+=("$1")
        FALLBACK=1
        shift
        continue
        ;;
      --chunk)
        local chunk_value="160"
        if (( $# > 1 )) && [[ "${2}" =~ ^[0-9]+$ ]]
        then
          chunk_value="$2"
          shift 2
        else
          shift
        fi
        if [[ ! "$chunk_value" =~ ^[0-9]+$ ]] || (( chunk_value <= 0 ))
        then
          echo_error "--chunk requires a positive integer size"
          return 2
        fi
        DEBUG_FLAGS+=("--chunk=$chunk_value")
        SMS_CHUNK_SIZE="$chunk_value"
        continue
        ;;
      --chunk=*)
        local chunk_value
        chunk_value="${1#*=}"
        if [[ -z "$chunk_value" ]]
        then
          chunk_value="160"
        fi
        if [[ ! "$chunk_value" =~ ^[0-9]+$ ]] || (( chunk_value <= 0 ))
        then
          echo_error "--chunk requires a positive integer size"
          return 2
        fi
        DEBUG_FLAGS+=("--chunk=$chunk_value")
        SMS_CHUNK_SIZE="$chunk_value"
        shift
        continue
        ;;
      -f|--allow-foreign)
        DEBUG_FLAGS+=("$1")
        ALLOW_FOREIGN=1
        shift
        continue
        ;;
      -R|--retry)
        if (( $# < 2 ))
        then
          echo_error "missing value for $1"
          return 2
        fi
        if [[ ! "$2" =~ ^[0-9]+$ ]]
        then
          echo_error "--retry requires a non-negative integer"
          return 2
        fi
        DEBUG_FLAGS+=("$1=$2")
        SMS_RETRY_COUNT="$2"
        shift 2
        continue
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

# Parse arguments for the list command and record leftovers in PARSED_ARGS.
parse_list_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage list
        PARSED_ARGS=()
        return 64
        ;;
      -a|--all)
        DEBUG_FLAGS+=("$1")
        ALL_MODEMS=1
        shift
        continue
        ;;
      -j|--json)
        DEBUG_FLAGS+=("$1")
        JSON_OUTPUT=1
        JSON_OUTPUT_FORCED=1
        shift
        continue
        ;;
      -r|--raw)
        DEBUG_FLAGS+=("$1")
        RAW_OUTPUT=1
        RAW_OUTPUT_FORCED=1
        shift
        continue
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

# Parse arguments for the logs command and record leftovers in PARSED_ARGS.
parse_logs_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage logs
        PARSED_ARGS=()
        return 64
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

# Parse arguments for the read command and record leftovers in PARSED_ARGS.
parse_read_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage read
        PARSED_ARGS=()
        return 64
        ;;
      -j|--json)
        DEBUG_FLAGS+=("$1")
        JSON_OUTPUT=1
        JSON_OUTPUT_FORCED=1
        shift
        continue
        ;;
      -r|--raw)
        DEBUG_FLAGS+=("$1")
        RAW_OUTPUT=1
        RAW_OUTPUT_FORCED=1
        shift
        continue
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

# Parse arguments for the prune command and record leftovers in PARSED_ARGS.
parse_prune_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage prune
        PARSED_ARGS=()
        return 64
        ;;
      -a|--all)
        DEBUG_FLAGS+=("$1")
        ALL_MODEMS=1
        shift
        continue
        ;;
      -S|--sent)
        DEBUG_FLAGS+=("$1")
        SENT_ONLY=1
        shift
        continue
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

# Parse arguments for the enable command and record leftovers in PARSED_ARGS.
parse_enable_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage enable
        PARSED_ARGS=()
        return 64
        ;;
      -a|--all)
        DEBUG_FLAGS+=("$1")
        ALL_MODEMS=1
        shift
        continue
        ;;
      -w|--wait)
        DEBUG_FLAGS+=("$1")
        ENABLE_WAIT_MODEM=1
        if [[ ! "$ENABLE_WAIT_TIMEOUT" =~ ^[0-9]+$ ]] || (( ENABLE_WAIT_TIMEOUT <= 0 ))
        then
          ENABLE_WAIT_TIMEOUT="$ENABLE_WAIT_TIMEOUT_DEFAULT"
        fi
        shift
        if [[ -n "${1:-}" && "${1:-}" =~ ^[0-9]+$ ]]
        then
          ENABLE_WAIT_TIMEOUT="$1"
          shift
        fi
        continue
        ;;
      -w=*|--wait=*)
        local wait_value
        wait_value="${1#*=}"
        if [[ -z "$wait_value" ]]
        then
          echo_error "missing value for --wait"
          return 2
        fi
        if [[ ! "$wait_value" =~ ^[0-9]+$ ]]
        then
          echo_error "invalid value for --wait: '$wait_value' (expected integer seconds)"
          return 2
        fi
        DEBUG_FLAGS+=("$1")
        ENABLE_WAIT_MODEM=1
        ENABLE_WAIT_TIMEOUT="$wait_value"
        shift
        continue
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

# Parse arguments for the service command and record leftovers in PARSED_ARGS.
parse_service_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage service
        PARSED_ARGS=()
        return 64
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

# Parse arguments for the pull command and record leftovers in PARSED_ARGS.
parse_pull_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage pull
        PARSED_ARGS=()
        return 64
        ;;
      --hard)
        DEBUG_FLAGS+=("$1")
        PULL_HARD_RESET=1
        shift
        continue
        ;;
      --no-restart)
        DEBUG_FLAGS+=("$1")
        PULL_NO_RESTART=1
        shift
        continue
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

# Parse arguments for the status command and record leftovers in PARSED_ARGS.
parse_status_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage status
        PARSED_ARGS=()
        return 64
        ;;
      -a|--all)
        DEBUG_FLAGS+=("$1")
        ALL_MODEMS=1
        shift
        continue
        ;;
      -j|--json)
        DEBUG_FLAGS+=("$1")
        JSON_OUTPUT=1
        JSON_OUTPUT_FORCED=1
        shift
        continue
        ;;
      -r|--raw)
        DEBUG_FLAGS+=("$1")
        RAW_OUTPUT=1
        RAW_OUTPUT_FORCED=1
        shift
        continue
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

# Parse arguments for the reset command and record leftovers in PARSED_ARGS.
parse_reset_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage reset
        PARSED_ARGS=()
        return 64
        ;;
      -a|--all)
        DEBUG_FLAGS+=("$1")
        ALL_MODEMS=1
        shift
        continue
        ;;
      -H|--hard)
        DEBUG_FLAGS+=("$1")
        HARD_RESET=1
        shift
        continue
        ;;
      --replug)
        DEBUG_FLAGS+=("$1")
        USB_REPLUG=1
        shift
        continue
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

# Parse arguments for the watch command and record leftovers in PARSED_ARGS.
parse_watch_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage watch
        PARSED_ARGS=()
        return 64
        ;;
      -A|--auto|--auto-recipient)
        DEBUG_FLAGS+=("$1")
        AUTO_RECIPIENT=1
        shift
        continue
        ;;
      -a|--all)
        DEBUG_FLAGS+=("$1")
        ALL_MODEMS=1
        shift
        continue
        ;;
      -E|--enable)
        DEBUG_FLAGS+=("$1")
        WATCH_ENABLE=1
        shift
        continue
        ;;
      -F|--fallback)
        DEBUG_FLAGS+=("$1")
        FALLBACK=1
        shift
        continue
        ;;
      -f|--allow-foreign)
        DEBUG_FLAGS+=("$1")
        ALLOW_FOREIGN=1
        shift
        continue
        ;;
      -P|--prune)
        DEBUG_FLAGS+=("$1")
        WATCH_PRUNE=1
        shift
        continue
        ;;
      -R|--retry)
        if (( $# < 2 ))
        then
          echo_error "missing value for $1"
          return 2
        fi
        if [[ ! "$2" =~ ^[0-9]+$ ]]
        then
          echo_error "--retry requires a non-negative integer"
          return 2
        fi
        DEBUG_FLAGS+=("$1=$2")
        SMS_RETRY_COUNT="$2"
        shift 2
        continue
        ;;
      --delete-sent)
        DEBUG_FLAGS+=("$1")
        WATCH_DELETE_AFTER=1
        WATCH_DELETE_AFTER_CLI_OVERRIDE=1
        shift
        continue
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

# Parse arguments for the number command and record leftovers in PARSED_ARGS.
parse_number_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage number
        PARSED_ARGS=()
        return 64
        ;;
      -a|--all)
        DEBUG_FLAGS+=("$1")
        ALL_MODEMS=1
        shift
        continue
        ;;
      -j|--json)
        DEBUG_FLAGS+=("$1")
        JSON_OUTPUT=1
        JSON_OUTPUT_FORCED=1
        shift
        continue
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

# Parse arguments for the smsc command and record leftovers in PARSED_ARGS.
parse_smsc_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage smsc
        PARSED_ARGS=()
        return 64
        ;;
      -a|--all)
        DEBUG_FLAGS+=("$1")
        ALL_MODEMS=1
        shift
        continue
        ;;
      -j|--json)
        DEBUG_FLAGS+=("$1")
        JSON_OUTPUT=1
        JSON_OUTPUT_FORCED=1
        shift
        continue
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

# Parse arguments for the stats command and record leftovers in PARSED_ARGS.
parse_stats_args() {
  PARSED_ARGS=()
  STATS_DAY=""
  STATS_DUMP=""
  STATS_RESET=""
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage stats
        PARSED_ARGS=()
        return 64
        ;;
      -a|--all)
        DEBUG_FLAGS+=("$1")
        ALL_MODEMS=1
        shift
        continue
        ;;
      -j|--json)
        DEBUG_FLAGS+=("$1")
        JSON_OUTPUT=1
        JSON_OUTPUT_FORCED=1
        shift
        continue
        ;;
      --day)
        shift
        if (( $# == 0 ))
        then
          echo_error "stats: missing argument for --day"
          return 2
        fi
        local day_value
        day_value="$1"
        if [[ ! "$day_value" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]
        then
          echo_error "stats: --day expects YYYY-MM-DD"
          return 2
        fi
        DEBUG_FLAGS+=("--day=$day_value")
        STATS_DAY="$day_value"
        shift
        continue
        ;;
      --day=*)
        local day_value
        day_value="${1#*=}"
        if [[ -z "$day_value" ]]
        then
          echo_error "stats: missing argument for --day"
          return 2
        fi
        if [[ ! "$day_value" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]
        then
          echo_error "stats: --day expects YYYY-MM-DD"
          return 2
        fi
        DEBUG_FLAGS+=("--day=$day_value")
        STATS_DAY="$day_value"
        shift
        continue
        ;;
      --dump)
        DEBUG_FLAGS+=("$1")
        STATS_DUMP=1
        shift
        continue
        ;;
      --reset)
        DEBUG_FLAGS+=("$1")
        STATS_RESET=1
        shift
        continue
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  if [[ -n "$STATS_DAY" && -n "$STATS_DUMP" ]]
  then
    echo_error "stats: --day cannot be combined with --dump"
    return 2
  fi

  if [[ -n "$STATS_RESET" && ( -n "$STATS_DAY" || -n "$STATS_DUMP" ) ]]
  then
    echo_error "stats: --reset cannot be combined with --day or --dump"
    return 2
  fi

  if (( ${#out[@]} > 0 ))
  then
    echo_error "stats does not accept positional arguments"
    return 2
  fi

  PARSED_ARGS=()
  return 0
}

# Parse arguments for the mmcli/raw command and record leftovers in PARSED_ARGS.
parse_mmcli_args() {
  PARSED_ARGS=()
  local -a out=()
  local seen_separator
  local arg
  local value

  while (( $# > 0 ))
  do
    arg="$1"
    shift

    if [[ -z "$seen_separator" && "$arg" == "--" ]]
    then
      seen_separator=1
      continue
    fi

    if [[ -z "$seen_separator" ]]
    then
      case "$arg" in
        -m)
          if (( $# == 0 ))
          then
            echo_error "mmcli: missing value for -m"
            return 2
          fi

          value="$1"
          if [[ -z "$value" || "$value" == "--" ]]
          then
            echo_error "mmcli: missing value for -m"
            return 2
          fi

          MODEM="$value"
          MODEM_EXPLICIT=1
          DEBUG_FLAGS+=("-m=$value")
          shift
          continue
          ;;
        --modem)
          if (( $# == 0 ))
          then
            echo_error "mmcli: missing value for --modem"
            return 2
          fi

          value="$1"
          if [[ -z "$value" || "$value" == "--" ]]
          then
            echo_error "mmcli: missing value for --modem"
            return 2
          fi

          MODEM="$value"
          MODEM_EXPLICIT=1
          DEBUG_FLAGS+=("--modem=$value")
          shift
          continue
          ;;
        -m?*)
          value="${arg#-m}"
          if [[ -z "$value" ]]
          then
            out+=("$arg")
            continue
          fi

          MODEM="$value"
          MODEM_EXPLICIT=1
          DEBUG_FLAGS+=("-m=$value")
          continue
          ;;
        --modem=*)
          value="${arg#--modem=}"
          if [[ -z "$value" ]]
          then
            echo_error "mmcli: missing value for --modem"
            return 2
          fi

          MODEM="$value"
          MODEM_EXPLICIT=1
          DEBUG_FLAGS+=("--modem=$value")
          continue
          ;;
        -a|--all)
          DEBUG_FLAGS+=("$arg")
          ALL_MODEMS=1
          continue
          ;;
      esac
    fi

    out+=("$arg")
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

# Route to the parser for the active subcommand and store remaining args.
parse_command_args() {
  local command="$1"
  shift || true

  case "$command" in
    at)
      parse_at_args "$@"
      return $?
      ;;
    send)
      parse_send_args "$@"
      return $?
      ;;
    list)
      parse_list_args "$@"
      return $?
      ;;
    logs)
      parse_logs_args "$@"
      return $?
      ;;
    read)
      parse_read_args "$@"
      return $?
      ;;
    prune)
      parse_prune_args "$@"
      return $?
      ;;
    enable)
      parse_enable_args "$@"
      return $?
      ;;
    pull)
      parse_pull_args "$@"
      return $?
      ;;
    service)
      parse_service_args "$@"
      return $?
      ;;
    status)
      parse_status_args "$@"
      return $?
      ;;
    reset)
      parse_reset_args "$@"
      return $?
      ;;
    watch)
      parse_watch_args "$@"
      return $?
      ;;
    number)
      parse_number_args "$@"
      return $?
      ;;
    smsc)
      parse_smsc_args "$@"
      return $?
      ;;
    stats)
      parse_stats_args "$@"
      return $?
      ;;
    mmcli)
      parse_mmcli_args "$@"
      return $?
      ;;
    *)
      PARSED_ARGS=("$@")
      return 0
      ;;
  esac
}

# Map selector to a country calling code (digits) for a small set
# Supports: fr (France=33), de (Germany=49), us/usa (United States=1)
country_to_cc() {
  local s="${1,,}"

  case "$s" in
    fr|fra|france)
      printf '33'
      ;;
    de|deu|germany|deutschland)
      printf '49'
      ;;
    us|usa|"united states"|"united-states"|america)
      printf '1'
      ;;
    *)
      return 1
      ;;
  esac
}

# Determine the home country code for E.164 numbers
# Priority:
#  - HOME_CC if set (digits only, e.g., 49)
#  - Derive from the modem's own number (heuristic: +1 -> 1, otherwise first two digits)
get_home_cc() {
  local target_mid="${1:-}"
  local cc
  if [[ -n "$HOME_CC" ]]
  then
    cc="${HOME_CC//[^0-9]/}"
    printf '%s' "$cc"
    return 0
  fi

  # Prefer using query_modem_number to respect current MODEM context
  local own=""
  if [[ -n "$target_mid" ]]
  then
    own="$(query_modem_number "$target_mid")" || own=""
  else
    own="$(query_modem_number)" || own=""
  fi

  if [[ -z "$own" ]]
  then
    # Fallback to direct mmcli parsing
    local j=""

    if [[ -n "$target_mid" ]]
    then
      j="$(mmcli -m "$target_mid" -J)"
    else
      j="$(mmcli_cmd -J)"
    fi

    if [[ -n "$j" ]]
    then
      own="$(jq -r '.modem.generic["own-numbers"][0] // empty' <<<"$j" 2>/dev/null)"
      own="$(ensure_plus "$own")"
      if [[ -n "$own" ]]
      then
        local actual_id
        actual_id="$(modem_json_extract_id "$j")"
        remember_modem_own_number "$target_mid" "$own"
        if [[ -n "$actual_id" && "$actual_id" != "$target_mid" ]]
        then
          remember_modem_own_number "$actual_id" "$own"
        fi
      fi
    fi
  fi

  if [[ "$own" == +* ]]
  then
    local digits="${own#+}"
    if [[ "$digits" == 1* ]]
    then
      cc="1"
    else
      cc="${digits:0:2}"
    fi
    printf '%s' "$cc"
    return 0
  fi

  return 1
}

# Derive a simple country code from a phone number in +E.164 form
phone_cc() {
  local n="$1"
  if [[ "$n" == +* ]]
  then
    local d="${n#+}"

    if [[ "$d" == 1* ]]
    then
      printf '1'
      return 0
    fi

    printf '%s' "${d:0:2}"
    return 0
  fi

  printf '%s' "--"
}

# Map a numeric country calling code to a short human-readable label
cc_to_label() {
  case "$1" in
    1) printf 'US' ;;
    33) printf 'FR' ;;
    49) printf 'DE' ;;
    *) printf '%s' "$1" ;;
  esac
}

# Return a human-readable CC label (US/FR/DE) for a +E.164 phone number
phone_cc_label() {
  local cc
  cc="$(phone_cc "$1")"
  cc_to_label "$cc"
}

# Ensure a phone/MSISDN has leading '+' when it's only digits
ensure_plus() {
  local n="${1:-}"

  if [[ -z "$n" ]]
  then
    printf '%s' ""
    return 0
  fi

  if [[ "$n" != +* && "$n" =~ ^[0-9]+$ ]]
  then
    printf '+%s' "$n"
  else
    printf '%s' "$n"
  fi
}

# Abbreviate text for logs: strip CR, escape newlines/backslashes, and truncate
abbrev_text_for_log() {
  local s="${1:-}"
  local maxlen="${2:-$LOG_ABBREV_LEN}"

  s=${s//$'\r'/}
  s=${s//$'\n'/\\n}
  s=${s//\\/\\\\}

  if [[ -z "$s" ]]
  then
    s="<empty>"
  fi

  if (( ${#s} > maxlen ))
  then
    s="${s:0:maxlen}…"
  fi

  printf '%s' "$s"
}

# Map mmcli SMS pdu-type to a friendly type label
pdu_to_type() {
  local pdu="${1,,}"
  case "$pdu" in
    deliver) printf 'received' ;;
    submit) printf 'sent' ;;
    status-report) printf 'report' ;;
    *) printf '%s' "$1" ;;
  esac
}

# List modem ids sorted numerically (one per line)
list_modem_ids_sorted() {
  local list_json
  if ! list_json="$(mmcli -L -J)"
  then
    return 1
  fi

  jq -r '."modem-list"[]? | split("/")[-1]' <<<"$list_json" | sort -n
}

# Check whether modem info JSON matches a human-friendly selector.
modem_info_matches_selector() {
  local selector_raw="$1"
  local info_json="$2"
  shift 2

  local selector
  selector="$(trim "$selector_raw")"
  if [[ -z "$selector" ]]
  then
    return 1
  fi

  local selector_lc="${selector,,}"
  local selector_digits="${selector//[^0-9+]/}"

  local cc_filter
  if ! cc_filter="$(country_to_cc "$selector")"
  then
    cc_filter=""
  fi

  local -a text_fields=()
  if ! mapfile -t text_fields < <(jq -r '
    .modem.generic as $g
    | [
        ($g.manufacturer // ""),
        ($g.model // ""),
        ($g.plugin // ""),
        ($g["primary-port"] // ""),
        (($g.ports // [])[]? | (split(" ")[0]))
      ]
    | .[]
    | select(. != "")
  ' <<<"$info_json")
  then
    text_fields=()
  fi

  if (( $# > 0 ))
  then
    local extra
    for extra in "$@"
    do
      if [[ -n "$extra" ]]
      then
        text_fields+=("$extra")
      fi
    done
  fi

  local -a number_fields=()
  if ! mapfile -t number_fields < <(jq -r '
    .modem.generic["own-numbers"][]?
    | select(. != "")
  ' <<<"$info_json")
  then
    number_fields=()
  fi

  local field
  if [[ -n "$cc_filter" ]]
  then
    for field in "${number_fields[@]}"
    do
      [[ -z "$field" ]] && continue
      local digits_only="${field//[^0-9]/}"
      if [[ -n "$digits_only" && "$digits_only" == "$cc_filter"* ]]
      then
        printf '%s' "$field"
        return 0
      fi
    done
  fi

  for field in "${text_fields[@]}"
  do
    [[ -z "$field" ]] && continue
    if [[ "${field,,}" == *"$selector_lc"* ]]
    then
      printf '%s' "$field"
      return 0
    fi
  done

  for field in "${number_fields[@]}"
  do
    [[ -z "$field" ]] && continue
    if [[ "${field,,}" == *"$selector_lc"* ]]
    then
      printf '%s' "$field"
      return 0
    fi

    if [[ -n "$selector_digits" ]]
    then
      local digits_with_plus="${field//[^0-9+]/}"
      if [[ "$digits_with_plus" == *"$selector_digits"* ]]
      then
        printf '%s' "$field"
        return 0
      fi
    fi

    if printf '%s\n' "$field" | grep -Eq -- "$selector"
    then
      printf '%s' "$field"
      return 0
    fi
  done

  return 1
}

# Resolve a human-friendly modem selector to a concrete modem id
# - Accepts: numeric id (e.g., 2), D-Bus path, 'any', or a substring
#   matching manufacturer, model, plugin, primary-port, or any ttyUSB/wwan port.
# - On multiple matches, prints a modem list to stderr and returns non-zero.
# - On no match, reports an error and shows the list.
get_modem_id() {
  local sel_raw="${1:-}"
  # Default / passthrough cases
  if [[ -z "$sel_raw" || "$sel_raw" == any ]]
  then
    printf '%s' "any"
    return 0
  fi

  # If a D-Bus path (/org/.../Modem/N)
  if [[ "$sel_raw" == */Modem/* ]]
  then
    printf '%s' "${sel_raw##*/}"
    return 0
  fi

  local list_json ids id json
  if ! list_json="$(mmcli -L -J)"
  then
    echo_error "could not query modem list via mmcli"
    return 1
  fi

  # Collect modem ids
  mapfile -t ids < <(jq -r '."modem-list"[]? | split("/")[-1]' <<<"$list_json")
  if (( ${#ids[@]} == 0 ))
  then
    echo_error "no modems detected"
    return 1
  fi

  # If pure numeric input, treat as id only if it matches a detected id; otherwise
  # continue with fuzzy matching (e.g., phone number fragment)
  if [[ "$sel_raw" =~ ^[0-9]+$ ]]
  then
    local _id
    for _id in "${ids[@]}"
    do
      if [[ "$_id" == "$sel_raw" ]]
      then
        printf '%s' "$sel_raw"
        return 0
      fi
    done
  fi

  local matches=()

  for id in "${ids[@]}"
  do
    [[ -z "$id" ]] && continue
    if ! json="$(mmcli -m "$id" -J)"
    then
      continue
    fi

    if modem_info_matches_selector "$sel_raw" "$json" >/dev/null
    then
      matches+=("$id")
    fi
  done

  if (( ${#matches[@]} == 1 ))
  then
    printf '%s' "${matches[0]}"
    return 0
  fi

  # Helper to show available modems for disambiguation
  echo_error "${SCRIPT_NAME}: modem selector '${sel_raw}' matched ${#matches[@]} modem(s)"
  echo_info "Available modems:"

  for id in "${ids[@]}"
  do
    [[ -z "$id" ]] && continue

    if ! json="$(mmcli -m "$id" -J)"
    then
      continue
    fi

    jq -r '
      .modem as $m
      | {
          id: ($m["dbus-path"] | split("/")[-1]),
          manufacturer: ($m.generic.manufacturer // "--"),
          model: ($m.generic.model // "--"),
          plugin: ($m.generic.plugin // "--"),
          primary: ($m.generic["primary-port"] // "--"),
          ports: (($m.generic.ports // []) | map(split(" ")[0]) | join(","))
        }
      | ("  " + .id + ": " + .manufacturer + " " + .model
         + " plugin=" + .plugin
         + " primary=" + .primary
         + " ports=" + .ports)
    ' <<<"$json" >&2
  done

  if (( ${#matches[@]} == 0 ))
  then
    return 1
  fi

  # Ambiguous modem selector, the user is at fault!
  return 2
}


# Resolve a modem selector and return its mmcli JSON description.
get_modem() {
  local selector="${1:-}"

  if [[ -z "$selector" ]]
  then
    if [[ -n "$MODEM" ]]
    then
      selector="$MODEM"
    else
      selector="any"
    fi
  fi

  selector="$(trim "$selector")"
  if [[ -z "$selector" ]]
  then
    selector="any"
  fi

  local mmcli_target="$selector"
  if [[ "$mmcli_target" != "any" && "$mmcli_target" != */Modem/* && ! "$mmcli_target" =~ ^[0-9]+$ ]]
  then
    if ! mmcli_target="$(get_modem_id "$mmcli_target")"
    then
      return "$?"
    fi
  fi

  mmcli -m "$mmcli_target" -J
}

# Convert modem JSON into a concise key=value summary string.
modem_info_string_from_json() {
  local info_json="$1"
  local fallback_id="${2:-}"

  if [[ -z "$info_json" ]]
  then
    return 1
  fi

  if [[ -n "$fallback_id" ]]
  then
    fallback_id="$(trim "$fallback_id")"
  fi

  local fields
  if ! fields="$(jq -r '
      .modem as $m
      | [
          ($m["dbus-path"] | split("/")[-1] // ""),
          ($m.generic.manufacturer // "--"),
          ($m.generic.model // "--"),
          ($m.generic.plugin // "--"),
          ($m.generic["primary-port"] // "--"),
          (($m.generic.ports // []) | map(split(" ")[0]) | join(",")),
          ($m.generic["own-numbers"][0] // "")
        ]
      | @tsv
    ' <<<"$info_json")"
  then
    return 1
  fi

  if [[ -z "$fields" ]]
  then
    return 1
  fi

  local id manufacturer model plugin primary ports phone cc_label
  IFS=$'\t' read -r id manufacturer model plugin primary ports phone <<<"$fields" || return 1

  phone="$(ensure_plus "$phone")"

  [[ -n "$ports" ]] || ports="--"
  if [[ -z "$id" ]]
  then
    id="$fallback_id"
  fi
  [[ -n "$id" ]] || id="$MODEM"
  [[ -n "$phone" ]] || phone="--"

  cc_label="$(phone_cc_label "$phone")"
  [[ -n "$cc_label" ]] || cc_label="--"

  printf "id='%s' manufacturer='%s' model='%s' plugin='%s' primary='%s' ports='%s' phone='%s' cc='%s'" \
    "$id" "$manufacturer" "$model" "$plugin" "$primary" "$ports" "$phone" "$cc_label"
}

# Get modem JSON and emit a formatted info string with optional prefix.
get_modem_info() {
  local selector="${1:-}"
  local prefix="${2:-}"
  local fallback_id="${selector:-$MODEM}"

  if [[ -n "$fallback_id" ]]
  then
    fallback_id="$(trim "$fallback_id")"
  fi

  local info_json
  if ! info_json="$(get_modem "$selector")"
  then
    return 1
  fi

  local info_string
  if ! info_string="$(modem_info_string_from_json "$info_json" "$fallback_id")"
  then
    return 1
  fi

  printf '%smodem={%s}' "$prefix" "$info_string"
}

# Return a concise modem info string for logs: id=.. manufacturer=.. model=.. plugin=.. primary=..
modem_info_brief() {
  local fallback="$MODEM"
  local info_json info_string

  if info_json="$(mmcli_cmd -J)"
  then
    if info_string="$(modem_info_string_from_json "$info_json" "$fallback")"
    then
      printf '%s' "$info_string"
      return 0
    fi
  fi

  printf "id='%s'" "$fallback"
}

# Log modem identification details with an optional prefix.
log_modem_details() {
  local mid="$1" prefix="${2:-}"
  local info

  if info="$(get_modem_info "$mid" "$prefix")"
  then
    echo_debug "$info"
    return 0
  fi

  if [[ -n "$mid" ]]
  then
    echo_debug "${prefix}modem={id='$mid'}"
  else
    echo_debug "${prefix}modem={}"
  fi
}

# Determine the modem's AT device path, optionally waiting for availability.
get_modem_at_port() {
  local wait_enabled="$AT_WAIT_MODEM"
  local wait_timeout="$AT_WAIT_TIMEOUT"
  local sleep_interval="$AT_WAIT_SLEEP_INTERVAL"

  if [[ ! "$wait_timeout" =~ ^[0-9]+$ ]]
  then
    wait_timeout=0
  fi

  if [[ ! "$sleep_interval" =~ ^[0-9]+(\.[0-9]+)?$ ]]
  then
    sleep_interval=2
  fi

  echo_debug "Resolving modem AT port for '$MODEM'"

  local wait_started=$SECONDS
  local wait_logged=0
  local err="no AT port detected for modem '$MODEM'"

  while :
  do
    local mmcli_out json port

    if ! mmcli_out="$(mmcli -m "$MODEM" -J 2>&1)"
    then
      echo_debug "get_modem_at_port: mmcli failed: ${mmcli_out//$'\n'/ }"
      err="failed to query modem JSON"
    else
      json="$mmcli_out"
      port="$(jq -r '
        def normalize_port:
          if . == null or . == "" then ""
          elif startswith("/") then .
          else "/dev/" + .
          end;
        ((.modem.generic.ports // [])
          | map(select(test("\\(at\\)"; "i")) | split(" ")[0] | normalize_port)
          | map(select(. != ""))
          | .[0])
        // ((.modem.generic["primary-port"] // "") | normalize_port)
      ' <<<"$json")"

      if [[ "$port" == "null" ]]
      then
        port=""
      fi

      if [[ -n "$port" ]]
      then
        echo_debug "resolved modem '$MODEM' AT port candidate '${port}'"
        if [[ -e "$port" ]]
        then
          echo_debug "resolved modem '$MODEM' AT port to '${port}'"
          printf '%s' "$port"
          return 0
        fi
        err="modem '$MODEM' AT port '$port' does not exist"
      else
        err="no AT port detected for modem '$MODEM'"
      fi
    fi

    if [[ -z "$wait_enabled" ]]
    then
      echo_error "$err"
      return 1
    fi

    if (( wait_logged == 0 ))
    then
      if (( wait_timeout > 0 ))
      then
        echo_info "waiting for modem '$MODEM' AT port (timeout ${wait_timeout}s)"
      else
        echo_info "waiting for modem '$MODEM' AT port"
      fi
      wait_logged=1
      wait_started=$SECONDS
    fi

    if (( wait_timeout > 0 ))
    then
      local elapsed=$(( SECONDS - wait_started ))
      if (( elapsed >= wait_timeout ))
      then
        echo_error "$err"
        return 1
      fi
    fi

    sleep "$sleep_interval"
  done
}

# Send an AT command directly to the resolved modem port.
at_command_direct() {
  local cmd="$1"
  local port

  if ! port="$(get_modem_at_port)"
  then
    return 1
  fi

  if [[ ! -w "$port" ]]
  then
    echo_error "AT port '$port' is not writable"
    return 1
  fi

  local fd
  echo_debug "Opening connection to AT port '$port'"
  if ! exec {fd}<>"$port"
  then
    echo_error "Failed to open '$port'"
    return 1
  fi

  local _drain
  while read -r -t "$AT_FALLBACK_READ_TIMEOUT" -u $fd _drain
  do
    :
  done

  echo_debug "AT TX -> $cmd"
  printf '%s\r' "$cmd" >&$fd

  local resp line timeout_count=0
  while (( timeout_count < AT_FALLBACK_MAX_READS ))
  do
    if ! read -r -t "$AT_FALLBACK_READ_TIMEOUT" -u $fd line
    then
      timeout_count=$((timeout_count + 1))
      continue
    fi

    timeout_count=0
    line="${line%$'\r'}"

    [[ "$line" == "$cmd" ]] && continue

    if [[ -n "$line" ]]
    then
      echo_debug "AT RX <- $line"
      resp+="$line"$'\n'
      if [[ "$line" == "OK" || "$line" == "ERROR" ]]
      then
        break
      fi
    fi
  done

  exec {fd}>&- {fd}<&-

  resp="${resp%$'\n'}"
  if [[ -n "$resp" ]]
  then
    printf '%s' "$resp"
    return 0
  fi

  return 1
}

# Apply vendor-specific AT configuration for Huawei modems.
configure_huawei_modem() {
  echo_info "huawei: configuring modem for SMS text mode"

  local -A at_codes=(
    [AT]="baseline connectivity check"
    [AT&F]="restore factory defaults"
    [AT+CMEE=2]="enable verbose error codes"
    [AT+CMGF=1]="set SMS message format to text"
    [AT+CSMP=17,167,0,0]="set SMS params: submit PDU, validity ~24h, normal PID, 7-bit alphabet"
    [AT+CGSMS=3]="set SMS service to PS preferred (fallback CS)"
    [AT+CMGD=1,4]="delete all messages"
  )

  local cmd resp
  for cmd in "${!at_codes[@]}"
  do
    resp="$(at_command "$cmd")"
    echo_info "huawei: $cmd (${at_codes[$cmd]}) -> $(format_at_response "$resp")"
  done
}

# Apply vendor-specific configuration for Quectel modems (currently no-op).
configure_quectel_modem() {
  echo_debug "quectel: no vendor-specific configuration required"
  return 0
}

# Infer the modem vendor from mmcli-provided JSON information.
modem_vendor_from_info_json() {
  local info_json="$1"

  local plugin manufacturer vendor
  plugin="$(jq -r '.modem.generic.plugin // ""' <<<"$info_json")"
  manufacturer="$(jq -r '.modem.generic.manufacturer // ""' <<<"$info_json")"

  if [[ "${plugin,,}" == huawei || "${manufacturer,,}" == huawei* ]]
  then
    vendor="huawei"
  elif [[ "${plugin,,}" == quectel || "${manufacturer,,}" == quectel* ]]
  then
    vendor="quectel"
  fi

  if [[ -n "$vendor" ]]
  then
    printf '%s' "$vendor"
    return 0
  fi

  return 1
}

# Run vendor-specific configuration unless excluded by skip patterns.
configure_modem_vendor() {
  local info_json="$1"

  local vendor
  if ! vendor="$(modem_vendor_from_info_json "$info_json")"
  then
    return 0
  fi

  if (( ${#SKIP_MODEM_INIT_PATTERNS[@]} > 0 ))
  then
    local -a extra_fields=()
    if [[ -n "$vendor" ]]
    then
      extra_fields+=("$vendor")
    fi

    local pattern matched_field
    for pattern in "${SKIP_MODEM_INIT_PATTERNS[@]}"
    do
      pattern="$(trim "$pattern")"
      [[ -z "$pattern" ]] && continue

      matched_field=""
      if matched_field="$(modem_info_matches_selector "$pattern" "$info_json" "${extra_fields[@]}")"
      then
        if [[ -n "$matched_field" ]]
        then
          echo_info "$vendor: skipping vendor-specific initialization (--skip-modem-init \"$pattern\" matched \"$matched_field\")"
        else
          echo_info "$vendor: skipping vendor-specific initialization (--skip-modem-init \"$pattern\")"
        fi
        return 0
      fi
    done
  fi

  case "$vendor" in
    huawei)
      configure_huawei_modem
      ;;
    quectel)
      configure_quectel_modem
      ;;
  esac
}

# Issue the Quectel power-down command as part of reset handling.
reset_quectel_modem() {
  reset_log "quectel: sending AT+QPOWD=0"

  local resp
  if ! resp="$(at_command 'AT+QPOWD=0')"
  then
    echo_error "quectel reset failed"
  fi

  local formatted_resp
  formatted_resp="$(format_at_response "$resp")"
  reset_log "quectel: AT+QPOWD=0 -> $formatted_resp"

  return 0
}

# Perform vendor-specific reset logic for the current modem.
reset_modem_vendor() {
  local info_json="${1:-}"
  local vendor="${2:-}"

  if [[ -z "$vendor" ]]
  then
    if [[ -z "$info_json" ]]
    then
      return 0
    fi
    if ! vendor="$(modem_vendor_from_info_json "$info_json")"
    then
      return 0
    fi
  fi

  case "$vendor" in
    quectel)
      reset_quectel_modem
      ;;
  esac

  return 0
}

# Find the sysfs path backing a modem port name.
usb_sysfs_path_for_port() {
  local port="$1"
  local path
  local -a bases=(
    "/sys/class/tty/$port"
    "/sys/class/usbmisc/$port"
    "/sys/class/net/$port"
  )

  for path in "${bases[@]}"
  do
    if [[ -e "$path" ]]
    then
      readlink -f "$path"
      return 0
    fi
  done

  return 1
}

# Ascend sysfs to locate the USB device directory for a port.
usb_device_dir_for_path() {
  local path="$1"
  local dir="$path"

  while [[ -n "$dir" && "$dir" != "/" ]]
  do
    if [[ -f "$dir/idVendor" && -f "$dir/idProduct" ]]
    then
      printf '%s\n' "$dir"
      return 0
    fi
    dir="$(dirname "$dir")"
  done

  return 1
}

# Temporarily deauthorize and reauthorize the modem's USB device.
modem_usb_replug() {
  local info_json="$1"

  if [[ -z "$info_json" ]]
  then
    echo_error "cannot replug USB device: missing modem info"
    return 1
  fi

  local -a ports=()
  local jq_status=0
  mapfile -t ports < <(jq -r '
    (.modem.generic.ports // [])
    | map(split(" ")[0])
    | map(select(length > 0)) | .[]
  ' <<<"$info_json") || jq_status=$?

  if (( jq_status != 0 )) && (( ${#ports[@]} == 0 ))
  then
    echo_warning "failed to parse modem ports for USB replug"
    return 1
  fi

  if (( ${#ports[@]} == 0 ))
  then
    echo_warning "no modem ports reported, cannot replug USB device"
    return 1
  fi

  declare -A seen_dirs=()
  declare -A dir_ports=()
  local -a device_dirs=()

  local port
  for port in "${ports[@]}"
  do
    [[ -n "$port" ]] || continue

    local sys_path
    if ! sys_path="$(usb_sysfs_path_for_port "$port")"
    then
      echo_debug "usb replug: unable to resolve sysfs path for port $port"
      continue
    fi

    local device_dir
    if ! device_dir="$(usb_device_dir_for_path "$sys_path")"
    then
      echo_debug "usb replug: no USB device directory found for port $port ($sys_path)"
      continue
    fi

    if [[ -z "${seen_dirs[$device_dir]:-}" ]]
    then
      device_dirs+=("$device_dir")
      seen_dirs["$device_dir"]=1
    fi

    if [[ -n "${dir_ports[$device_dir]:-}" ]]
    then
      dir_ports["$device_dir"]+=" $port"
    else
      dir_ports["$device_dir"]="$port"
    fi
  done

  if (( ${#device_dirs[@]} == 0 ))
  then
    echo_warning "could not resolve USB device backing modem ports (${ports[*]})"
    return 1
  fi

  local bind_path="/sys/bus/usb/drivers/usb/bind"
  local unbind_path="/sys/bus/usb/drivers/usb/unbind"
  local success

  local device_dir
  for device_dir in "${device_dirs[@]}"
  do
    local port_list="${dir_ports[$device_dir]# }"

    local dev_name
    dev_name="$(basename "$device_dir")"

    local vendor
    local product

    if [[ -f "$device_dir/idVendor" ]]
    then
      vendor="$(<"$device_dir/idVendor")"
    fi

    if [[ -f "$device_dir/idProduct" ]]
    then
      product="$(<"$device_dir/idProduct")"
    fi

    local authorized_path="$device_dir/authorized"
    if [[ -w "$authorized_path" ]]
    then
      reset_log "USB replugging device $dev_name (ports: ${port_list:-unknown}, vid:pid ${vendor:-??}:${product:-??})"
      if ! printf '0\n' >"$authorized_path"
      then
        echo_warning "failed to deauthorize USB device $dev_name"
        continue
      fi

      sleep 2

      if ! printf '1\n' >"$authorized_path"
      then
        echo_warning "failed to reauthorize USB device $dev_name"
        continue
      fi

      sleep 2
      success=1
      continue
    fi

    if [[ -w "$unbind_path" && -w "$bind_path" ]]
    then
      reset_log "USB replugging device $dev_name (ports: ${port_list:-unknown}, vid:pid ${vendor:-??}:${product:-??}) via unbind/bind"
      if ! printf '%s\n' "$dev_name" >"$unbind_path"
      then
        echo_warning "failed to unbind USB device $dev_name"
        continue
      fi

      sleep 2

      if ! printf '%s\n' "$dev_name" >"$bind_path"
      then
        echo_warning "failed to bind USB device $dev_name"
        continue
      fi

      sleep 2
      success=1
      continue
    fi

    echo_warning "no supported USB replug control for device $dev_name (ports: ${port_list:-unknown})"
  done

  if [[ -n $success ]]
  then
    return 1
  fi

  return 0
}

# Resolve default recipient based on modem/country-specific variables.
# Order:
#  - DEFAULT_RECIPIENT_<LABEL> (US/FR/DE)
#  - DEFAULT_RECIPIENT_<CC> (1/33/49)
#  - DEFAULT_RECIPIENT
resolve_default_recipient() {
  local mid="${1:-}"

  local cc
  cc="$(get_home_cc "$mid")"

  echo_debug "resolve_default_recipient: mid=${mid:-} cc=${cc:-}"

  # Guard: unknown CC → fall back to global default or fail
  if [[ -z "$cc" ]]
  then
    if [[ -n "${DEFAULT_RECIPIENT-}" ]]
    then
      echo_debug "resolve_default_recipient: cc unknown, using DEFAULT_RECIPIENT=${DEFAULT_RECIPIENT}"
      printf '%s' "${DEFAULT_RECIPIENT}"
      return 0
    fi

    echo_debug "resolve_default_recipient: cc unknown and no DEFAULT_RECIPIENT"
    return 1
  fi

  local label
  case "$cc" in
    1)
      label=US
      ;;
    33)
      label=FR
      ;;
    49)
      label=DE
      ;;
  esac

  # Try label-specific var
  local var val
  if [[ -n "$label" ]]
  then
    var="DEFAULT_RECIPIENT_${label}"
    echo_debug "resolve_default_recipient: try $var"
    if declare -p "$var" &>/dev/null
    then
      val="${!var}"
      if [[ -n "$val" ]]
      then
        echo_debug "resolve_default_recipient: matched $var=$val"
        printf '%s' "$val"
        return 0
      fi
    fi
  fi

  # Try numeric-CC specific var
  var="DEFAULT_RECIPIENT_${cc}"
  echo_debug "resolve_default_recipient: try $var"
  if declare -p "$var" &>/dev/null
  then
    val="${!var}"
    if [[ -n "$val" ]]
    then
      echo_debug "resolve_default_recipient: matched $var=$val"
      printf '%s' "$val"
      return 0
    fi
  fi

  # Global default
  if [[ -n "${DEFAULT_RECIPIENT-}" ]]
  then
    echo_debug "resolve_default_recipient: default DEFAULT_RECIPIENT=${DEFAULT_RECIPIENT}"
    printf '%s' "${DEFAULT_RECIPIENT}"
    return 0
  fi

  echo_debug "resolve_default_recipient: no default found"
  return 1
}

# Detect whether ModemManager is running via the debug wrapper.
modemmanager_running_with_debug() {
  pgrep -a -f 'ModemManager-wrapper.*--debug' &>/dev/null
}

# Run an AT command via mmcli and return the response string
# - Strips the leading "response: '...'") wrapper printed by mmcli
# - If no such wrapper is present, returns raw stdout/stderr as-is
at_command() {
  local cmd="$1"
  local resp

  if modemmanager_running_with_debug
  then
    echo_debug "MM is in debug mode, running AT command '${cmd}' using mmcli"

    local out
    if out="$(mmcli_cmd --command="$cmd" 2>&1)"
    then
      # TODO is this really working for multiple-line responses?
      resp="$(printf '%s\n' "$out" | \
        sed -n "s/^response: '\(.*\)'$/\1/p" | head -n1)"

      if [[ -z "$resp" ]]
      then
        echo_warning "'${cmd}': empty AT command response"
        return 1
      fi

      printf '%s' "$resp"
      return 0
    fi

    echo_debug "mmcli --command='${cmd}' failed, attempting to issue AT command directly"
  fi

  if ! resp="$(at_command_direct "$cmd")"
  then
    echo_debug "direct AT command failed: '$cmd'"
    return 1
  fi

  printf '%s' "$resp"
  return 0
}

# Start an interactive AT command session over the modem port.
at_command_interactive() {
  local port
  if ! port="$(get_modem_at_port)"
  then
    echo_error "Failed to determine AT port for modem $MODEM"
    return 1
  fi

  echo_info "Starting interactive AT command session with $port (exit with Ctrl-D)"
  socat - "${port},crnl"
}

# Invoke logread filtered for this script's messages.
mmsms_logread() {
  echo_debug "logread args: $*"
  logread -e "$SCRIPT_NAME" "$@"
}

# Call the init script for the mmsms service with given arguments.
mmsms_service_action() {
  "/etc/init.d/${SCRIPT_NAME}" "$@"
}

mmsms_service_debug_cleanup() {
  echo_info "Restarting $SCRIPT_NAME service after debug session"
  if ! mmsms_service_action start
  then
    echo_error "failed to start $SCRIPT_NAME service"
    return 1
  fi
}

# Stop the service, run a debug watch session with optional flags, then start service again.
mmsms_service_debug() {
  local -a default_flags=(--debug --all --enable)
  local -a watch_flags=()
  local -a extra_flags=("$@")

  trap 'mmsms_service_debug_cleanup' EXIT

  if (( ${#extra_flags[@]} == 0 ))
  then
    watch_flags=("${default_flags[@]}")
  else
    if [[ "${extra_flags[0]}" == "--" ]]
    then
      extra_flags=("${extra_flags[@]:1}")
    fi

    if (( ${#extra_flags[@]} == 0 ))
    then
      watch_flags=("${default_flags[@]}")
    else
      watch_flags=("${extra_flags[@]}")
    fi
  fi

  echo_info "Stopping $SCRIPT_NAME service for debug session"
  if ! mmsms_service_action stop
  then
    echo_error "failed to stop $SCRIPT_NAME service"
    return 1
  fi

  local debug_prev="$DEBUG"
  if [[ -r "$CONFIG_FILE" ]]
  then
    DEBUG=1
    echo_debug "dumping config from $CONFIG_FILE"
    local line
    while IFS= read -r line || [[ -n "$line" ]]
    do
      echo_debug "cfg> $line"
    done < "$CONFIG_FILE"
  else
    echo_warning "config file not readable: $CONFIG_FILE"
  fi
  DEBUG="$debug_prev" # restore

  local watch_flags_desc
  if (( ${#watch_flags[@]} > 0 ))
  then
    printf -v watch_flags_desc '%q ' "${watch_flags[@]}"
    watch_flags_desc="${watch_flags_desc%% }"
  fi

  if [[ -n "$watch_flags_desc" ]]
  then
    echo_debug "service debug watch flags: $watch_flags_desc"
    echo_info "Starting $SCRIPT_NAME watch for debug session ($watch_flags_desc)"
  else
    echo_debug "service debug watch has no flags"
    echo_info "Starting $SCRIPT_NAME watch for debug session"
  fi

  CONFIG_FILE="$CONFIG_FILE" \
  MODEM="$MODEM" \
  QUIET="$QUIET" \
  ECHO_SYSLOG="$ECHO_SYSLOG" \
  VERBOSE="$VERBOSE" \
  NO_COLOR="$NO_COLOR" \
    "$0" watch "${watch_flags[@]}"
}

# Update the repository and optionally restart the service after pulling.
mmsms_repo_pull() {
  if [[ -n "$PULL_HARD_RESET" ]]
  then
    echo_info "Resetting repository (git reset --hard)"
    if ! git reset --hard
    then
      echo_error "git reset --hard failed"
      return 1
    fi
  fi

  echo_info "Pulling latest changes"
  if ! git pull
  then
    echo_error "git pull failed"
    return 1
  fi

  if [[ -n "$PULL_NO_RESTART" ]]
  then
    echo_debug "Skipping service restart (--no-restart)"
    return 0
  fi

  echo_info "Restarting $SCRIPT_NAME service"
  if ! mmsms_service_action restart
  then
    echo_error "failed to restart $SCRIPT_NAME service"
    return 1
  fi

  return 0
}

# Flatten multiline AT command responses into a log-friendly string.
format_at_response() {
  local resp="$1"

  if [[ -z "$resp" ]]
  then
    printf '%s' '<no response>'
    return 0
  fi

  resp="${resp//$'\n'/'; '}"
  printf '%s' "$resp"
}

# Decode a UCS2 hex string like "002B0033..." by taking the low byte of each code unit
at_decode_ucs2() {
  local s="$1"

  if [[ "$s" =~ ^([0-9A-Fa-f]{4})+$ ]]
  then
    local out
    local pos=0 len=${#s} hb
    while (( pos < len ))
    do
      hb="${s:pos+2:2}"
      out+="$(printf '%b' "\\x$hb")"
      pos=$((pos + 4))
    done

    printf '%s' "$out"
    return 0
  fi

  printf '%s' "$s"
}

# Extract the first double-quoted field from an AT response and decode UCS2 if applicable
at_first_quoted_decoded() {
  local resp="$1"

  local q
  q="$(printf '%s\n' "$resp" | sed -n 's/^.*"\([^"]*\)".*$/\1/p' | head -n1)"

  if [[ -z "$q" ]]
  then
    return 1
  fi

  if [[ "$q" =~ ^([0-9A-Fa-f]{4})+$ ]]
  then
    q="$(at_decode_ucs2 "$q")"
  fi

  printf '%s' "$q"
}

# Choose an ANSI color for a given SMS state.
sms_state_color() { # $1=state
  local state="${1,,}"
  case "$state" in
    received|read|sent|delivered|delivery-success|complete|completed|stored|stored-received|stored-sent)
      printf '%s' "$COLOR_BOLD_GREEN"
      ;;
    queued|pending|sending|temporary|unknown|new|waiting|draft)
      printf '%s' "$COLOR_BOLD_YELLOW"
      ;;
    failed|error|rejected|aborted|cancelled|timeout|unsent|not-sent|undelivered)
      printf '%s' "$COLOR_BOLD_RED"
      ;;
    *)
      printf '%s' "$COLOR_CYAN"
      ;;
  esac
}

# Choose an ANSI color for a given SMS type.
sms_type_color() { # $1=type
  local type="${1,,}"
  case "$type" in
    received)
      printf '%s' "$COLOR_BOLD_GREEN"
      ;;
    sent)
      printf '%s' "$COLOR_BOLD_BLUE"
      ;;
    report|status-report)
      printf '%s' "$COLOR_BOLD_MAGENTA"
      ;;
    *)
      printf '%s' "$COLOR_CYAN"
      ;;
  esac
}

# Choose a stable ANSI color for a modem ID value.
sms_mid_color() { # $1=mid
  local mid="$1"
  if [[ -z "$mid" ]]
  then
    printf '%s' "$COLOR_BOLD_WHITE"
    return 0
  fi

  local -a palette=(
    "$COLOR_BOLD_BLUE"
    "$COLOR_BOLD_GREEN"
    "$COLOR_BOLD_MAGENTA"
    "$COLOR_BOLD_CYAN"
    "$COLOR_BOLD_YELLOW"
    "$COLOR_BOLD_RED"
    "$COLOR_BOLD_WHITE"
  )

  local palette_size
  palette_size=${#palette[@]}

  if (( palette_size == 0 ))
  then
    printf '%s' "$COLOR_BOLD_WHITE"
    return 0
  fi

  local index
  if [[ "$mid" =~ ^[0-9]+$ ]]
  then
    index=$((mid % palette_size))
  else
    local checksum_raw
    checksum_raw="$(printf '%s' "$mid" | cksum 2>/dev/null)"
    local checksum
    checksum="${checksum_raw%% *}"

    if [[ -z "$checksum" ]]
    then
      checksum=0
    fi

    index=$((checksum % palette_size))
  fi

  printf '%s' "${palette[index]}"
}

# Summarize SMS direction and party labels for display.
sms_read_party_info() { # $1=type, $2=remote, $3=own
  local type="${1,,}"
  local remote="$2"
  local own="$3"

  local direction="unknown"
  local remote_label="Number"
  local local_label="Own"
  local remote_value="$remote"
  local local_value="$own"

  case "$type" in
    received)
      direction="incoming"
      remote_label="From"
      local_label="To"
      ;;
    sent)
      direction="outgoing"
      remote_label="To"
      local_label="From"
      ;;
    report|status-report)
      direction="network"
      remote_label="Report For"
      local_label="From"
      ;;
  esac

  printf '%s\t%s\t%s\t%s\t%s' "$direction" "$remote_label" "$local_label" "$remote_value" "$local_value"
}

# Fetch an SMS using mmcli and print the raw output.
sms_read_raw() {
  local msg_id="$1"
  mmcli_cmd --sms "$msg_id"
}

# Collect rich JSON details for an SMS message using mmcli.
sms_read_details_json() {
  local msg_id="$1"
  local js pdu msg_type own number smsc party_info direction remote_label local_label remote_value local_value payload


  if ! js="$(mmcli_cmd --sms "$msg_id" -J)"
  then
    return 1
  fi

  pdu="$(jq -r '.sms.properties["pdu-type"] // ""' <<<"$js")"
  msg_type="$(pdu_to_type "$pdu")"

  number="$(jq -r '.sms.content.number // ""' <<<"$js")"
  number="$(ensure_plus "$number")"

  if own="$(query_modem_number)"
  then
    :
  else
    own=""
  fi
  own="$(ensure_plus "$own")"

  party_info="$(sms_read_party_info "$msg_type" "$number" "$own")"
  IFS=$'\t' read -r direction remote_label local_label remote_value local_value <<<"$party_info"

  smsc="$(jq -r '.sms.properties.smsc // ""' <<<"$js")"
  smsc="$(ensure_plus "$smsc")"

  if ! payload="$(
    jq --arg type "$msg_type" \
       --arg direction "$direction" \
       --arg remote_label "$remote_label" \
       --arg local_label "$local_label" \
       --arg remote "$remote_value" \
       --arg local "$local_value" \
       --arg own "$own" \
       --arg smsc "$smsc" \
       --arg pdu "$pdu" \
       --arg fallback_modem "$MODEM" \
       --arg msg_id "$msg_id" '
      def blank_to_null:
        if . == null or . == "" then null else . end;

      (.sms.modem // "") as $modem_path
      | (.sms["dbus-path"] // "") as $sms_path
      | ($modem_path | split("/")[-1]) as $modem_id_str
      | ($sms_path | split("/")[-1]) as $sms_id_str
      | $fallback_modem as $fallback
      | {
          id: ($sms_id_str | tonumber?),
          modem_id: ($modem_id_str | tonumber?),
          modem_label: (
            if ($modem_id_str // "") != "" then $modem_id_str
            elif ($fallback | test("^[0-9]+$")) then $fallback
            elif ($fallback | blank_to_null) then $fallback
            else "unknown" end
          ),
          type: ($type | blank_to_null),
          direction: ($direction | blank_to_null),
          state: (.sms.properties.state // null),
          storage: ((.sms.properties.storage // "") | blank_to_null),
          class: ((.sms.properties.class // "") | if . == "" then null else (. | tonumber? // .) end),
          pdu: ($pdu | blank_to_null),
          timestamp: (.sms.properties.timestamp // null),
          discharge_timestamp: (.sms.properties["discharge-timestamp"] // null),
          remote_number: ($remote | blank_to_null),
          remote_label: ($remote_label | blank_to_null),
          local_number: ($local | blank_to_null),
          local_label: ($local_label | blank_to_null),
          own_number: ($own | blank_to_null),
          smsc: ($smsc | blank_to_null),
          text: ((.sms.content.text // null) | if . == null then null else gsub("\r"; "") end),
          encoding: ((.sms.content.encoding // "") | blank_to_null),
          data: ((.sms.content.data // "") | blank_to_null),
          delivery: (
            {state: (.sms.properties["delivery-state"] // ""), report: (.sms.properties["delivery-report"] // "")} as $d
            | if ($d.state == "" and $d.report == "") then null
              else {
                state: ($d.state | blank_to_null),
                report: ($d.report | blank_to_null)
              }
              end
          )
        }
      | .raw_id = (if ($sms_id_str // "") != "" then $sms_id_str else $msg_id end)
      | .raw_modem_id = (if ($modem_id_str // "") != "" then $modem_id_str else $fallback end)
    ' <<<"$js"
  )"
  then
    return 1
  fi

  printf '%s\n' "$payload"
}

# Render SMS details in a colorized human-readable format.
sms_read_pretty() {
  local msg_id="$1"
  local payload

  if ! payload="$(sms_read_details_json "$msg_id")"
  then
    return 1
  fi

  local color_reset color_white color_cyan color_blue color_green color_yellow color_red color_magenta
  local color_type_green color_type_blue color_type_magenta
  color_reset="$(ansi_escape "$COLOR_RESET")"
  color_white="$(ansi_escape "$COLOR_BOLD_WHITE")"
  color_cyan="$(ansi_escape "$COLOR_CYAN")"
  color_blue="$(ansi_escape "$COLOR_BOLD_BLUE")"
  color_green="$(ansi_escape "$COLOR_BOLD_GREEN")"
  color_yellow="$(ansi_escape "$COLOR_BOLD_YELLOW")"
  color_red="$(ansi_escape "$COLOR_BOLD_RED")"
  color_magenta="$(ansi_escape "$COLOR_BOLD_MAGENTA")"
  color_type_green="$color_green"
  color_type_blue="$color_blue"
  color_type_magenta="$color_magenta"

  jq -r \
    --arg reset "$color_reset" \
    --arg white "$color_white" \
    --arg cyan "$color_cyan" \
    --arg blue "$color_blue" \
    --arg green "$color_green" \
    --arg yellow "$color_yellow" \
    --arg red "$color_red" \
    --arg magenta "$color_magenta" \
    --arg type_green "$color_type_green" \
    --arg type_blue "$color_type_blue" \
    --arg type_magenta "$color_type_magenta" \
    --arg msg_id "$msg_id" \
    'def color($code; $text):
       if $code == "" then $text else $code + $text + $reset end;

     def ucfirst:
       if . == null or . == "" then ""
       else (.[:1] | ascii_upcase) + (.[1:] // "") end;

     def choose_type_color($type):
       if $type == null then $cyan
       else
         ($type | ascii_downcase) as $t
         | if $t == "received" then $type_green
           elif $t == "sent" then $type_blue
           elif ($t == "report" or $t == "status-report") then $type_magenta
           else $cyan end
       end;

     def choose_state_color($state):
       if $state == null then $cyan
       else
         ($state | ascii_downcase) as $s
         | if ["received","read","sent","delivered","delivery-success","complete","completed","stored","stored-received","stored-sent"] | index($s) then $green
           elif ["queued","pending","sending","temporary","unknown","new","waiting","draft"] | index($s) then $yellow
           elif ["failed","error","rejected","aborted","cancelled","timeout","unsent","not-sent","undelivered"] | index($s) then $red
           else $cyan end
       end;

     def format_value($v):
       if $v == null or $v == "" then "--" else $v end;

     def highlight_own($number; $own):
       if $number == null then "--"
       elif $own != null and $number == $own then $number + "*"
       else $number end;

     def summarize_data($data):
       if $data == null then null
       else
         ($data | tostring) as $d
         | (if ($d | length) > 64 then $d[0:61] + "…" else $d end) as $trim
         | if ($d | test("^[0-9A-Fa-f]+$")) then
             ( ($d | length) / 2 | floor | tostring) + " bytes (" + $trim + ")"
           else $trim end
       end;

      def split_lines($value):
        ($value // "--") | tostring | split("\n");

      def spaces($n):
        if $n <= 0 then ""
        else [range(0; $n) | " "] | add
        end;

      def format_label($label; $width):
        ($label // "") as $l
        | ($width - ($l | length)) as $pad
        | if $pad <= 0 then $l else $l + spaces($pad) end;

      def format_lines($label; $color; $lines; $width):
        if ($lines | length) == 0 then [""]
        else
          [format_label($label; $width) + "  " + color($color; $lines[0])]
          + ($lines[1:] | map(format_label(""; $width) + "  " + color($color; .)))
        end;

      def add_row($rows; $label; $color; $value):
        $rows + [{label:$label, color:$color, value:$value}];

      def add_optional_row($rows; $label; $color; $value):
        if $value == null or $value == "" then $rows else add_row($rows; $label; $color; $value) end;

     . as $sms
     | ($sms.id // ($sms.raw_id // $msg_id)) as $id_label
     | ($sms.modem_label // ($sms.raw_modem_id // "unknown")) as $modem_label
     | ($sms.type // "unknown") as $type_label
     | ($type_label | tostring | ascii_downcase | ucfirst) as $type_title
     | ($sms.direction // "") as $direction
     | ($sms.state // "unknown") as $state_label
     | ($sms.storage // null) as $storage_raw
     | (if $storage_raw == null or $storage_raw == "" then "unknown" else $storage_raw end) as $storage_label
     | ($sms.timestamp // "--") as $timestamp_label
     | ($sms.discharge_timestamp // null) as $discharge
     | ($sms.delivery // null) as $delivery
     | ($delivery | if . == null then null else (.state // null) end) as $delivery_state
     | ($delivery | if . == null then null else (.report // null) end) as $delivery_report
     | (if $delivery == null then null
        else
          if $delivery_state != null and $delivery_report != null then $delivery_state + " (" + $delivery_report + ")"
          elif $delivery_state != null then $delivery_state
          elif $delivery_report != null then $delivery_report
          else null end
        end) as $delivery_label
     | ($sms.own_number // null) as $own
     | ($sms.remote_number // null) as $remote
     | ($sms.local_number // null) as $local
     | ($sms.remote_label // "Number") as $remote_label
     | ($sms.local_label // "Own") as $local_label
     | summarize_data($sms.data) as $data_summary
     | ($sms.text // "*no text*") as $message
     | (if $direction == null or $direction == "" or $direction == "unknown" then $type_title else $type_title + " (" + $direction + ")" end) as $type_display
     | ( []
         | add_row(.; "SMS ID"; $white; ($id_label | tostring))
         | add_row(.; "Modem"; $blue; ($modem_label | tostring))
         | add_row(.; "Type"; choose_type_color($sms.type); $type_display)
         | add_row(.; "State"; choose_state_color($sms.state); $state_label)
         | add_row(.; "Storage"; $cyan; $storage_label)
         | add_row(.; "Timestamp"; $cyan; $timestamp_label)
         | add_optional_row(.; "Discharged"; $cyan; $discharge)
         | add_optional_row(.; "Delivery"; choose_state_color($delivery_state); $delivery_label)
         | . + [null]
         | add_row(.; $remote_label; $blue; highlight_own($remote; $own))
         | add_row(.; $local_label; $blue; highlight_own($local; $own))
         | add_row(.; "SMSC"; $blue; format_value($sms.smsc))
         | add_optional_row(.; "Class"; $cyan; ($sms.class | tostring))
         | add_optional_row(.; "Encoding"; $cyan; $sms.encoding)
         | add_optional_row(.; "PDU"; $cyan; $sms.pdu)
         | add_optional_row(.; "Data"; $cyan; $data_summary)
         | . + [null]
         | add_row(.; "Message"; ""; $message)
         | . + [null]
       ) as $rows
     | ($rows | map(select(. != null) | .label | length) | max // 0) as $width
     | $rows
     | map(
           if . == null then [""]
           else
             (.label // "") as $label
             | (.color // "") as $color
             | split_lines(.value) as $lines
             | format_lines($label; $color; $lines; $width)
           end
         )
     | (add // [])
       | .[]
    ' <<<"$payload"
}

# Output the JSON payload produced by sms_read_details_json.
sms_read_json() {
  local msg_id="$1"
  local payload

  if ! payload="$(sms_read_details_json "$msg_id")"
  then
    return 1
  fi

  printf '%s\n' "$payload"
}

# Normalize a phone number to +E.164 form for limit matching.
sms_daily_limit_normalize_msisdn() {
  local raw
  raw="$(trim "${1:-}")"
  raw="${raw//[[:space:]]/}"
  raw="${raw//[^0-9+]/}"

  if [[ -z "$raw" ]]
  then
    return 1
  fi

  if [[ "$raw" =~ ^\+?[0-9]+$ ]]
  then
    raw="${raw#+}"
    printf '+%s' "$raw"
    return 0
  fi

  return 1
}


# Determine whether the daily SMS limit should be enforced.
sms_daily_limit_enabled() {
  if [[ "$SMS_DAILY_LIMIT_STATUS" == "enabled" ]]
  then
    return 0
  fi

  if [[ "$SMS_DAILY_LIMIT_STATUS" == "disabled" || "$SMS_DAILY_LIMIT_STATUS" == "invalid" ]]
  then
    return 1
  fi

  SMS_DAILY_LIMIT_GLOBAL_LIMIT=""
  SMS_DAILY_LIMIT_MSISDN_LIMITS=()

  local found_valid=0
  local found_invalid=0

  local decl
  if decl="$(declare -p MAX_DAILY_MESSAGES 2>/dev/null)"
  then
    if [[ "$decl" == "declare -A"* ]]
    then
      local -a limit_keys=()
      eval "limit_keys=(\"\${!MAX_DAILY_MESSAGES[@]}\")"

      local key
      for key in "${limit_keys[@]}"
      do
        local value
        eval "value=\${MAX_DAILY_MESSAGES[\"$key\"]}"
        value="$(trim "$value")"
        if [[ -z "$value" ]]
        then
          continue
        fi

        if [[ ! "$value" =~ ^[0-9]+$ ]] || (( value <= 0 ))
        then
          echo_warning "ignoring MAX_DAILY_MESSAGES['$key']='$value'; expected positive integer"
          found_invalid=1
          continue
        fi

        local trimmed_key
        trimmed_key="$(trim "$key")"
        if [[ -z "$trimmed_key" ]]
        then
          continue
        fi

        local lower_key="${trimmed_key,,}"
        if [[ "$lower_key" == "global" ]]
        then
          SMS_DAILY_LIMIT_GLOBAL_LIMIT="$value"
          found_valid=1
          continue
        fi

        local normalized
        if normalized="$(sms_daily_limit_normalize_msisdn "$trimmed_key")"
        then
          SMS_DAILY_LIMIT_MSISDN_LIMITS["$normalized"]="$value"
          found_valid=1
        else
          echo_warning "ignoring MAX_DAILY_MESSAGES['$key']='$value'; expected phone number key"
          found_invalid=1
        fi
      done
    else
      local scalar
      scalar="$(trim "${MAX_DAILY_MESSAGES:-}")"
      if [[ -n "$scalar" ]]
      then
        if [[ "$scalar" =~ ^[0-9]+$ ]] && (( scalar > 0 ))
        then
          SMS_DAILY_LIMIT_GLOBAL_LIMIT="$scalar"
          found_valid=1
        else
          echo_warning "ignoring MAX_DAILY_MESSAGES='$scalar'; expected positive integer"
          found_invalid=1
        fi
      fi
    fi
  fi

  local legacy
  legacy="$(trim "${MAX_MESSAGES_PER_DAY:-}")"
  if [[ -n "$legacy" ]]
  then
    if [[ "$legacy" =~ ^[0-9]+$ ]] && (( legacy > 0 ))
    then
      if [[ -z "$SMS_DAILY_LIMIT_GLOBAL_LIMIT" ]]
      then
        SMS_DAILY_LIMIT_GLOBAL_LIMIT="$legacy"
        found_valid=1
      elif [[ "$legacy" != "$SMS_DAILY_LIMIT_GLOBAL_LIMIT" ]]
      then
        echo_warning "ignoring MAX_MESSAGES_PER_DAY='$legacy'; global limit already set via MAX_DAILY_MESSAGES"
      fi
    else
      echo_warning "ignoring MAX_MESSAGES_PER_DAY='$legacy'; expected positive integer"
      found_invalid=1
    fi
  fi

  if (( found_valid ))
  then
    SMS_DAILY_LIMIT_STATUS="enabled"
    return 0
  fi

  if (( found_invalid ))
  then
    SMS_DAILY_LIMIT_STATUS="invalid"
  else
    SMS_DAILY_LIMIT_STATUS="disabled"
  fi

  return 1
}

# Ensure the directory used for storing daily limit state exists.
sms_daily_limit_state_dir() {
  local dir="${SMS_DAILY_LIMIT_DIR:-}"
  dir="$(trim "$dir")"

  if [[ -z "$dir" ]]
  then
    dir="/var/lib/mmsms"
  fi

  if [[ ! -d "$dir" ]]
  then
    if ! mkdir -p "$dir"
    then
      echo_error "daily limit: failed to create state directory '$dir'"
      return 1
    fi
  fi

  printf '%s' "$dir"
  return 0
}

# Identify the SIM/modem used for tracking daily limits.
sms_daily_limit_identity() {
  local preferred_label="${1:-}"
  local preferred_msisdn="${2:-}"
  local label
  local modem_hint
  local info_json
  local mmcli_number
  local info_modem_id
  local cached_number

  SMS_DAILY_LIMIT_MSISDN=""
  SMS_DAILY_LIMIT_KEY=""
  SMS_DAILY_LIMIT_LABEL=""

  if [[ -n "$preferred_msisdn" ]]
  then
    local normalized_from_arg
    if normalized_from_arg="$(sms_daily_limit_normalize_msisdn "$preferred_msisdn")"
    then
      SMS_DAILY_LIMIT_MSISDN="$normalized_from_arg"
    fi
  fi

  if [[ -n "$preferred_label" ]]
  then
    label="$preferred_label"
  fi

  if [[ -z "$label" && -n "$SMS_DAILY_LIMIT_MSISDN" ]]
  then
    label="$SMS_DAILY_LIMIT_MSISDN"
  fi

  local modem_own
  if [[ -z "$label" ]]
  then
    modem_own="$(query_modem_number)" || modem_own=""
    if [[ -n "$modem_own" ]]
    then
      label="$modem_own"
    fi
  fi

  if [[ -z "$SMS_DAILY_LIMIT_MSISDN" && -n "$label" ]]
  then
    local normalized_from_label
    if normalized_from_label="$(sms_daily_limit_normalize_msisdn "$label")"
    then
      SMS_DAILY_LIMIT_MSISDN="$normalized_from_label"
    fi
  fi

  if [[ -z "$label" || -z "$SMS_DAILY_LIMIT_MSISDN" ]]
  then
    if info_json="$(mmcli_cmd -J 2>/dev/null)"
    then
      info_modem_id="$(modem_json_extract_id "$info_json")"
      mmcli_number="$(jq -r '.modem.generic["own-numbers"][0] // empty' <<<"$info_json")"
      if [[ -z "$label" ]]
      then
        label="$mmcli_number"
      fi
      cached_number="$(ensure_plus "$mmcli_number")"
      if [[ -n "$cached_number" ]]
      then
        remember_modem_own_number "$MODEM" "$cached_number"
        if [[ -n "$info_modem_id" && "$info_modem_id" != "$MODEM" ]]
        then
          remember_modem_own_number "$info_modem_id" "$cached_number"
        fi
      fi
      if [[ -z "$SMS_DAILY_LIMIT_MSISDN" ]]
      then
        local normalized_from_mmcli
        if normalized_from_mmcli="$(sms_daily_limit_normalize_msisdn "$mmcli_number")"
        then
          SMS_DAILY_LIMIT_MSISDN="$normalized_from_mmcli"
        fi
      fi
      if [[ -z "$modem_hint" ]]
      then
        modem_hint="$(jq -r '.modem["dbus-path"] | split("/")[-1] // empty' <<<"$info_json")"
      fi
    fi
  fi

  if [[ -z "$label" ]]
  then
    if [[ -n "$SMS_DAILY_LIMIT_MSISDN" ]]
    then
      label="$SMS_DAILY_LIMIT_MSISDN"
    elif [[ -n "$modem_hint" ]]
    then
      label="modem $modem_hint"
    elif [[ -n "$MODEM" ]]
    then
      label="modem $MODEM"
    else
      label="modem"
    fi
  fi

  if [[ -z "$SMS_DAILY_LIMIT_MSISDN" ]]
  then
    local normalized_from_fallback
    if normalized_from_fallback="$(sms_daily_limit_normalize_msisdn "$label")"
    then
      SMS_DAILY_LIMIT_MSISDN="$normalized_from_fallback"
    fi
  fi

  if [[ -n "$SMS_DAILY_LIMIT_MSISDN" ]]
  then
    SMS_DAILY_LIMIT_LABEL="$SMS_DAILY_LIMIT_MSISDN"
    SMS_DAILY_LIMIT_KEY="${SMS_DAILY_LIMIT_MSISDN#+}"
    return 0
  fi

  local sanitized
  sanitized="${label//[^A-Za-z0-9]/_}"
  sanitized="${sanitized##_}"
  sanitized="${sanitized%%_}"
  if [[ -z "$sanitized" ]]
  then
    sanitized="line"
  fi

  SMS_DAILY_LIMIT_LABEL="$(ensure_plus "$label")"
  SMS_DAILY_LIMIT_KEY="$sanitized"
  return 0
}

# Return the full path to the counter file for a given identity token.
sms_daily_limit_state_file() {
  local token="${1:-}"

  if [[ -z "$token" ]]
  then
    if ! sms_daily_limit_identity
    then
      return 1
    fi
    token="$SMS_DAILY_LIMIT_KEY"
  fi

  local dir
  if ! dir="$(sms_daily_limit_state_dir)"
  then
    return 1
  fi

  printf '%s/sms-count-%s.state' "$dir" "$token"
  return 0
}

# Read the stored counters from a state file without enforcing the current date.
sms_daily_state_read() {
  local file
  local date_var
  local sent_var
  local failed_var
  local incoming_var
  local label_var
  local msisdn_var
  local history_var
  local msisdn_key
  local msisdn_alt_key
  local state_date
  local state_label
  local state_msisdn
  local state_sent
  local state_failed
  local state_incoming
  local content
  local parsed
  local legacy_date
  local legacy_count
  local state_history_json
  local opt

  msisdn_key="msisdn"
  msisdn_alt_key=""

  while (( $# > 0 ))
  do
    opt="$1"
    case "$opt" in
      --file)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --file"
          return 1
        fi
        file="$1"
        shift
        continue
        ;;
      --out-date-var)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --out-date-var"
          return 1
        fi
        date_var="$1"
        shift
        continue
        ;;
      --out-sent-var)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --out-sent-var"
          return 1
        fi
        sent_var="$1"
        shift
        continue
        ;;
      --out-failed-var)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --out-failed-var"
          return 1
        fi
        failed_var="$1"
        shift
        continue
        ;;
      --out-incoming-var)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --out-incoming-var"
          return 1
        fi
        incoming_var="$1"
        shift
        continue
        ;;
      --out-label-var)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --out-label-var"
          return 1
        fi
        label_var="$1"
        shift
        continue
        ;;
      --out-msisdn-var)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --out-msisdn-var"
          return 1
        fi
        msisdn_var="$1"
        shift
        continue
        ;;
      --msisdn-key)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --msisdn-key"
          return 1
        fi
        msisdn_key="$1"
        shift
        continue
        ;;
      --out-history-json-var)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --out-history-json-var"
          return 1
        fi
        history_var="$1"
        shift
        continue
        ;;
      --)
        shift
        break
        ;;
      *)
        echo_error "daily limit: unknown argument '$opt' for sms_daily_state_read"
        return 1
        ;;
    esac
  done

  if [[ "$msisdn_key" == "msisdn" ]]
  then
    msisdn_alt_key="msisdn_count"
  else
    msisdn_alt_key="msisdn"
  fi

  if [[ -z "$file" ]]
  then
    echo_error "daily limit: --file is required for sms_daily_state_read"
    return 1
  fi

  state_sent=0
  state_failed=0
  state_incoming=0
  if [[ -n "$history_var" ]]
  then
    state_history_json="[]"
  fi

  if [[ -r "$file" ]]
  then
    if content="$(cat "$file" 2>/dev/null)"
    then
      :
    else
      content=""
    fi

    if [[ -n "$content" ]]
    then
      local sep
      sep=$'\x1f'
      if parsed="$(jq -r \
        --arg msisdn_key "$msisdn_key" \
        --arg msisdn_alt_key "$msisdn_alt_key" \
        '[.date // "", .label // "", ((.[$msisdn_key] // (if $msisdn_alt_key == "" then null else .[$msisdn_alt_key] end) // "") | tostring), ((.outgoing.sent // 0) | tostring), ((.outgoing.failed // 0) | tostring), ((.incoming.received // 0) | tostring)] | join("\u001f")' <<<"$content" 2>/dev/null)"
      then
        local parsed_fields
        printf -v parsed_fields '%s%s' "$parsed" "$sep"
        IFS=$'\x1f' read -r state_date state_label state_msisdn state_sent state_failed state_incoming <<<"$parsed_fields"
        if [[ -n "$history_var" ]]
        then
          if state_history_json="$(jq -c '.history // []' <<<"$content" 2>/dev/null)"
          then
            :
          else
            state_history_json="[]"
          fi
        fi
      else
        if read -r legacy_date legacy_count <<<"$content"
        then
          if [[ "$legacy_date" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]
          then
            state_date="$legacy_date"
          fi
          if [[ "$legacy_count" =~ ^[0-9]+$ ]]
          then
            state_sent="$legacy_count"
          fi
        fi
        if [[ -n "$history_var" ]]
        then
          state_history_json="[]"
        fi
      fi
    fi
  fi

  if [[ -n "$date_var" ]]
  then
    printf -v "$date_var" '%s' "$state_date"
  fi
  if [[ -n "$sent_var" ]]
  then
    printf -v "$sent_var" '%s' "$state_sent"
  fi
  if [[ -n "$failed_var" ]]
  then
    printf -v "$failed_var" '%s' "$state_failed"
  fi
  if [[ -n "$incoming_var" ]]
  then
    printf -v "$incoming_var" '%s' "$state_incoming"
  fi
  if [[ -n "$label_var" ]]
  then
    printf -v "$label_var" '%s' "$state_label"
  fi
  if [[ -n "$msisdn_var" ]]
  then
    printf -v "$msisdn_var" '%s' "$state_msisdn"
  fi
  if [[ -n "$history_var" ]]
  then
    printf -v "$history_var" '%s' "$state_history_json"
  fi

  return 0
}

# Read counters for the current day, resetting stale totals to zero.
sms_daily_state_read_today() {
  local file
  local today
  local sent_var
  local failed_var
  local incoming_var
  local label_var
  local msisdn_var
  local msisdn_key
  local day_date
  local day_sent
  local day_failed
  local day_incoming
  local day_label
  local day_msisdn
  local opt

  msisdn_key="msisdn"

  while (( $# > 0 ))
  do
    opt="$1"
    case "$opt" in
      --file)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --file"
          return 1
        fi
        file="$1"
        shift
        continue
        ;;
      --today)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --today"
          return 1
        fi
        today="$1"
        shift
        continue
        ;;
      --out-sent-var)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --out-sent-var"
          return 1
        fi
        sent_var="$1"
        shift
        continue
        ;;
      --out-failed-var)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --out-failed-var"
          return 1
        fi
        failed_var="$1"
        shift
        continue
        ;;
      --out-incoming-var)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --out-incoming-var"
          return 1
        fi
        incoming_var="$1"
        shift
        continue
        ;;
      --out-label-var)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --out-label-var"
          return 1
        fi
        label_var="$1"
        shift
        continue
        ;;
      --out-msisdn-var)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --out-msisdn-var"
          return 1
        fi
        msisdn_var="$1"
        shift
        continue
        ;;
      --msisdn-key)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --msisdn-key"
          return 1
        fi
        msisdn_key="$1"
        shift
        continue
        ;;
      --)
        shift
        break
        ;;
      *)
        echo_error "daily limit: unknown argument '$opt' for sms_daily_state_read_today"
        return 1
        ;;
    esac
  done

  if [[ -z "$file" ]]
  then
    echo_error "daily limit: --file is required for sms_daily_state_read_today"
    return 1
  fi

  if [[ -z "$today" ]]
  then
    echo_error "daily limit: --today is required for sms_daily_state_read_today"
    return 1
  fi

  day_sent=0
  day_failed=0
  day_incoming=0

  if ! sms_daily_state_read \
    --file "$file" \
    --out-date-var day_date \
    --out-sent-var day_sent \
    --out-failed-var day_failed \
    --out-incoming-var day_incoming \
    --out-label-var day_label \
    --out-msisdn-var day_msisdn \
    --msisdn-key "$msisdn_key"
  then
    return 1
  fi

  if [[ "$day_date" != "$today" ]]
  then
    day_sent=0
    day_failed=0
    day_incoming=0
  fi

  if [[ -n "$sent_var" ]]
  then
    printf -v "$sent_var" '%s' "$day_sent"
  fi
  if [[ -n "$failed_var" ]]
  then
    printf -v "$failed_var" '%s' "$day_failed"
  fi
  if [[ -n "$incoming_var" ]]
  then
    printf -v "$incoming_var" '%s' "$day_incoming"
  fi
  if [[ -n "$label_var" ]]
  then
    printf -v "$label_var" '%s' "$day_label"
  fi
  if [[ -n "$msisdn_var" ]]
  then
    printf -v "$msisdn_var" '%s' "$day_msisdn"
  fi

  return 0
}

# Persist counters to disk while the caller holds the lock for the file.
sms_daily_state_write_locked() {
  local file
  local date
  local label
  local msisdn
  local msisdn_key
  local msisdn_alt_key
  local msisdn_json_value
  local use_msisdn_json
  local use_msisdn_str
  local sent
  local failed
  local incoming
  local dir
  local tmp
  local base
  local new_json
  local history_days
  local history_limit
  local opt

  sent=0
  failed=0
  incoming=0
  msisdn_key="msisdn"
  msisdn_alt_key=""
  msisdn_json_value="null"
  use_msisdn_json=0
  use_msisdn_str=0

  while (( $# > 0 ))
  do
    opt="$1"
    case "$opt" in
      --file)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --file"
          return 1
        fi
        file="$1"
        shift
        continue
        ;;
      --date)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --date"
          return 1
        fi
        date="$1"
        shift
        continue
        ;;
      --label)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --label"
          return 1
        fi
        label="$1"
        shift
        continue
        ;;
      --msisdn)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --msisdn"
          return 1
        fi
        msisdn="$1"
        use_msisdn_str=1
        shift
        continue
        ;;
      --msisdn-key)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --msisdn-key"
          return 1
        fi
        msisdn_key="$1"
        shift
        continue
        ;;
      --msisdn-json)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --msisdn-json"
          return 1
        fi
        msisdn_json_value="$1"
        use_msisdn_json=1
        shift
        continue
        ;;
      --sent)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --sent"
          return 1
        fi
        sent="$1"
        shift
        continue
        ;;
      --failed)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --failed"
          return 1
        fi
        failed="$1"
        shift
        continue
        ;;
      --incoming)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --incoming"
          return 1
        fi
        incoming="$1"
        shift
        continue
        ;;
      --)
        shift
        break
        ;;
      *)
        echo_error "daily limit: unknown argument '$opt' for sms_daily_state_write_locked"
        return 1
        ;;
    esac
  done

  if [[ "$msisdn_key" == "msisdn" ]]
  then
    msisdn_alt_key="msisdn_count"
  else
    msisdn_alt_key="msisdn"
  fi

  if (( use_msisdn_json ))
  then
    use_msisdn_str=0
  fi

  if [[ -z "$file" ]]
  then
    echo_error "daily limit: --file is required for sms_daily_state_write_locked"
    return 1
  fi

  if [[ -z "$date" ]]
  then
    echo_error "daily limit: --date is required for sms_daily_state_write_locked"
    return 1
  fi

  if [[ -z "$sent" || ! "$sent" =~ ^-?[0-9]+$ ]]
  then
    sent=0
  fi

  if [[ -z "$failed" || ! "$failed" =~ ^-?[0-9]+$ ]]
  then
    failed=0
  fi

  if [[ -z "$incoming" || ! "$incoming" =~ ^-?[0-9]+$ ]]
  then
    incoming=0
  fi

  history_days="$SMS_STATS_HISTORY_DAYS"
  if [[ ! "$history_days" =~ ^[0-9]+$ ]]
  then
    history_days=1
  elif (( history_days < 1 ))
  then
    history_days=1
  fi
  history_limit=$((history_days - 1))
  if (( history_limit < 0 ))
  then
    history_limit=0
  fi

  dir="$(dirname "$file")"

  if ! tmp="$(mktemp "$dir/.sms-count.XXXXXX")"
  then
    echo_error "daily limit: failed to create temporary file in '$dir'"
    return 1
  fi

  base="{}"
  if [[ -r "$file" ]]
  then
    if base="$(cat "$file" 2>/dev/null)"
    then
      if [[ -z "${base//[[:space:]]/}" ]]
      then
        base="{}"
      fi
    else
      base="{}"
    fi
  fi

  if ! new_json="$(jq \
    --arg date "$date" \
    --arg label "${label:-}" \
    --arg msisdn_key "$msisdn_key" \
    --arg msisdn_alt_key "$msisdn_alt_key" \
    --arg new_msisdn_str "${msisdn:-}" \
    --arg use_msisdn_str "$use_msisdn_str" \
    --arg use_msisdn_json "$use_msisdn_json" \
    --argjson new_msisdn_json "$msisdn_json_value" \
    --argjson sent "$sent" \
    --argjson failed "$failed" \
    --argjson incoming "$incoming" \
    --argjson history_limit "$history_limit" \
    'def mkentry($d; $label; $msisdn_obj; $sent; $failed; $incoming):
       (if $d == "" then {} else {date:$d} end)
       + (if $label == "" then {} else {label:$label} end)
       + $msisdn_obj
       + {outgoing:{sent:$sent, failed:$failed}, incoming:{received:$incoming}};
     def ensure_history($hist):
       if ($hist | type) == "array" then
         $hist
         | map(
             if (type == "object") then
               (if $msisdn_key != "" and $msisdn_key != $msisdn_alt_key then
                  (if (has($msisdn_alt_key) and (has($msisdn_key) | not)) then
                     . + {($msisdn_key): .[$msisdn_alt_key]} | del(.[$msisdn_alt_key])
                   elif ($msisdn_alt_key == "msisdn" and has("msisdn") and (has($msisdn_key) | not)) then
                     . + {($msisdn_key): .msisdn} | del(.msisdn)
                   else .
                   end)
                elif $msisdn_key == "msisdn" and has("msisdn_count") and (has("msisdn") | not) then
                  . + {msisdn:(.msisdn_count | tostring)} | del(.msisdn_count)
                else .
                end)
             else .
             end)
       else [] end;
     def trim_history($hist; $limit):
       if $limit <= 0 then [] else $hist[:$limit] end;
     def msisdn_obj($value):
       if $msisdn_key == "" then {}
       elif $value == "__MMSMS_UNSET__" then {}
       else {($msisdn_key): $value}
       end;
     def new_msisdn_obj($orig_value):
       if $use_msisdn_json == "1" then
         msisdn_obj($new_msisdn_json)
       elif $use_msisdn_str == "1" then
         if $new_msisdn_str == "" then msisdn_obj("__MMSMS_UNSET__") else msisdn_obj($new_msisdn_str) end
       else
         msisdn_obj($orig_value)
       end;
     def cleanup_alt($obj):
       if ($msisdn_key != "" and $msisdn_key != $msisdn_alt_key and ($obj | type) == "object") then
         $obj | del(.[$msisdn_alt_key])
       else
         $obj
       end;
     . as $existing
     | ($existing.date // "") as $orig_date
     | ($existing.label // "") as $orig_label
     | ($existing.outgoing.sent // 0) as $orig_sent
     | ($existing.outgoing.failed // 0) as $orig_failed
     | ($existing.incoming.received // 0) as $orig_incoming
     | ensure_history($existing.history) as $existing_hist
     | cleanup_alt($existing) as $clean_existing
     | ($clean_existing[$msisdn_key] // (if $msisdn_alt_key == "" then null else $clean_existing[$msisdn_alt_key] end)) as $orig_msisdn
     | (if $orig_date != "" and $orig_date != $date then
          trim_history([mkentry($orig_date; $orig_label; msisdn_obj($orig_msisdn); $orig_sent; $orig_failed; $orig_incoming)] + $existing_hist; $history_limit)
        else
          trim_history($existing_hist; $history_limit)
        end) as $hist
     | mkentry($date; $label; new_msisdn_obj($orig_msisdn); $sent; $failed; $incoming)
       + {history:$hist}
     | cleanup_alt(.)' <<<"$base" 2>/dev/null)"
  then
    if ! new_json="$(jq -n \
      --arg date "$date" \
      --arg label "${label:-}" \
      --arg msisdn_key "$msisdn_key" \
      --arg new_msisdn_str "${msisdn:-}" \
      --arg use_msisdn_str "$use_msisdn_str" \
      --arg use_msisdn_json "$use_msisdn_json" \
      --argjson new_msisdn_json "$msisdn_json_value" \
      --argjson sent "$sent" \
      --argjson failed "$failed" \
      --argjson incoming "$incoming" \
      'def mkentry($d; $label; $msisdn_obj; $sent; $failed; $incoming):
         (if $d == "" then {} else {date:$d} end)
         + (if $label == "" then {} else {label:$label} end)
         + $msisdn_obj
         + {outgoing:{sent:$sent, failed:$failed}, incoming:{received:$incoming}};
       def msisdn_obj($value):
         if $msisdn_key == "" then {}
         elif $value == "__MMSMS_UNSET__" then {}
         else {($msisdn_key): $value}
         end;
       def new_msisdn_obj:
         if $use_msisdn_json == "1" then
           msisdn_obj($new_msisdn_json)
         elif $use_msisdn_str == "1" then
           if $new_msisdn_str == "" then msisdn_obj("__MMSMS_UNSET__") else msisdn_obj($new_msisdn_str) end
         else
           msisdn_obj("__MMSMS_UNSET__")
         end;
       mkentry($date; $label; new_msisdn_obj; $sent; $failed; $incoming)
       + {history:[]}')"
    then
      rm -f "$tmp"
      echo_error "daily limit: failed to build counter JSON"
      return 1
    fi
  fi

  if ! printf '%s\n' "$new_json" >"$tmp"
  then
    rm -f "$tmp"
    echo_error "daily limit: failed to write temporary counter file"
    return 1
  fi

  if ! mv "$tmp" "$file"
  then
    rm -f "$tmp"
    echo_error "daily limit: failed to update counter file '$file'"
    return 1
  fi

  return 0
}

# Atomically adjust counters for a state file, updating the current day.
sms_daily_state_increment() {
  local file
  local label
  local msisdn
  local sent_delta
  local failed_delta
  local incoming_delta
  local sent_out_var
  local failed_out_var
  local incoming_out_var
  local today
  local lock_handle
  local stored_date
  local stored_sent
  local stored_failed
  local stored_incoming
  local stored_label
  local stored_msisdn
  local new_sent
  local new_failed
  local new_incoming
  local opt

  sent_delta=0
  failed_delta=0
  incoming_delta=0

  while (( $# > 0 ))
  do
    opt="$1"
    case "$opt" in
      --file)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --file"
          return 1
        fi
        file="$1"
        shift
        continue
        ;;
      --label)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --label"
          return 1
        fi
        label="$1"
        shift
        continue
        ;;
      --msisdn)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --msisdn"
          return 1
        fi
        msisdn="$1"
        shift
        continue
        ;;
      --sent-delta)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --sent-delta"
          return 1
        fi
        sent_delta="$1"
        shift
        continue
        ;;
      --failed-delta)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --failed-delta"
          return 1
        fi
        failed_delta="$1"
        shift
        continue
        ;;
      --incoming-delta)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --incoming-delta"
          return 1
        fi
        incoming_delta="$1"
        shift
        continue
        ;;
      --out-sent-var)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --out-sent-var"
          return 1
        fi
        sent_out_var="$1"
        shift
        continue
        ;;
      --out-failed-var)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --out-failed-var"
          return 1
        fi
        failed_out_var="$1"
        shift
        continue
        ;;
      --out-incoming-var)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --out-incoming-var"
          return 1
        fi
        incoming_out_var="$1"
        shift
        continue
        ;;
      --)
        shift
        break
        ;;
      *)
        echo_error "daily limit: unknown argument '$opt' for sms_daily_state_increment"
        return 1
        ;;
    esac
  done

  if [[ -z "$file" ]]
  then
    echo_error "daily limit: --file is required for sms_daily_state_increment"
    return 1
  fi

  if [[ -z "$sent_delta" || ! "$sent_delta" =~ ^-?[0-9]+$ ]]
  then
    sent_delta=0
  fi

  if [[ -z "$failed_delta" || ! "$failed_delta" =~ ^-?[0-9]+$ ]]
  then
    failed_delta=0
  fi

  if [[ -z "$incoming_delta" || ! "$incoming_delta" =~ ^-?[0-9]+$ ]]
  then
    incoming_delta=0
  fi

  today="$(date +%Y-%m-%d)"

  if ! sms_daily_limit_lock_acquire "$file" lock_handle
  then
    return 1
  fi

  stored_sent=0
  stored_failed=0
  stored_incoming=0

  if ! sms_daily_state_read \
    --file "$file" \
    --out-date-var stored_date \
    --out-sent-var stored_sent \
    --out-failed-var stored_failed \
    --out-incoming-var stored_incoming \
    --out-label-var stored_label \
    --out-msisdn-var stored_msisdn
  then
    sms_daily_limit_lock_release "$lock_handle"
    return 1
  fi

  if [[ "$stored_date" != "$today" ]]
  then
    stored_sent=0
    stored_failed=0
    stored_incoming=0
  fi

  if [[ -z "$label" && -n "$stored_label" ]]
  then
    label="$stored_label"
  fi

  if [[ -z "$msisdn" && -n "$stored_msisdn" ]]
  then
    msisdn="$stored_msisdn"
  fi

  new_sent=$((stored_sent + sent_delta))
  new_failed=$((stored_failed + failed_delta))
  new_incoming=$((stored_incoming + incoming_delta))

  if (( new_sent < 0 ))
  then
    new_sent=0
  fi

  if (( new_failed < 0 ))
  then
    new_failed=0
  fi

  if (( new_incoming < 0 ))
  then
    new_incoming=0
  fi

  if ! sms_daily_state_write_locked \
    --file "$file" \
    --date "$today" \
    --label "${label:-}" \
    --msisdn "${msisdn:-}" \
    --sent "$new_sent" \
    --failed "$new_failed" \
    --incoming "$new_incoming"
  then
    sms_daily_limit_lock_release "$lock_handle"
    return 1
  fi

  if [[ -n "$sent_out_var" ]]
  then
    printf -v "$sent_out_var" '%s' "$new_sent"
  fi

  if [[ -n "$failed_out_var" ]]
  then
    printf -v "$failed_out_var" '%s' "$new_failed"
  fi

  if [[ -n "$incoming_out_var" ]]
  then
    printf -v "$incoming_out_var" '%s' "$new_incoming"
  fi

  sms_daily_limit_lock_release "$lock_handle"
  return 0
}

# Acquire an exclusive lock for manipulating the counter file.
sms_daily_limit_lock_acquire() {
  local file="$1"
  local __out_var="$2"
  local lock_path="${file}.lock"

  if command -v flock >/dev/null 2>&1
  then
    exec {__lock_fd}>"$lock_path" || return 1
    if flock "$__lock_fd"
    then
      printf -v "$__out_var" 'flock:%s:%s' "$__lock_fd" "$lock_path"
      return 0
    fi
    exec {__lock_fd}>&-
  fi

  local attempts=0
  local max_attempts=50
  while ! ( set -o noclobber; : >"$lock_path" ) 2>/dev/null
  do
    sleep 1
    attempts=$((attempts + 1))
    if (( attempts >= max_attempts ))
    then
      return 1
    fi
  done

  printf -v "$__out_var" 'file:%s' "$lock_path"
  return 0
}

# Release a previously acquired counter lock.
sms_daily_limit_lock_release() {
  local handle="$1"
  [[ -z "$handle" ]] && return 0

  local type="${handle%%:*}"
  local rest="${handle#*:}"

  case "$type" in
    flock)
      local fd="${rest%%:*}"
      local path="${rest#*:}"
      if [[ "$fd" =~ ^[0-9]+$ ]]
      then
        eval "exec ${fd}>&-"
      fi
      [[ -n "$path" ]] && rm -f "$path"
      ;;
    file)
      [[ -n "$rest" ]] && rm -f "$rest"
      ;;
  esac
}

# Persist the current counter value for the given date.
sms_daily_limit_write_state() {
  local file
  local date
  local sent
  local failed
  local incoming
  local label
  local msisdn
  local opt

  sent=0
  failed=0
  incoming=0

  while (( $# > 0 ))
  do
    opt="$1"
    case "$opt" in
      --file)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --file"
          return 1
        fi
        file="$1"
        shift
        continue
        ;;
      --date)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --date"
          return 1
        fi
        date="$1"
        shift
        continue
        ;;
      --sent)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --sent"
          return 1
        fi
        sent="$1"
        shift
        continue
        ;;
      --failed)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --failed"
          return 1
        fi
        failed="$1"
        shift
        continue
        ;;
      --incoming)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --incoming"
          return 1
        fi
        incoming="$1"
        shift
        continue
        ;;
      --label)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --label"
          return 1
        fi
        label="$1"
        shift
        continue
        ;;
      --msisdn)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily limit: missing argument for --msisdn"
          return 1
        fi
        msisdn="$1"
        shift
        continue
        ;;
      --)
        shift
        break
        ;;
      *)
        echo_error "daily limit: unknown argument '$opt' for sms_daily_limit_write_state"
        return 1
        ;;
    esac
  done

  if [[ -z "$file" ]]
  then
    echo_error "daily limit: --file is required for sms_daily_limit_write_state"
    return 1
  fi

  if [[ -z "$date" ]]
  then
    echo_error "daily limit: --date is required for sms_daily_limit_write_state"
    return 1
  fi

  if [[ -z "$sent" || ! "$sent" =~ ^-?[0-9]+$ ]]
  then
    sent=0
  fi

  if [[ -z "$failed" || ! "$failed" =~ ^-?[0-9]+$ ]]
  then
    failed=0
  fi

  if [[ -z "$incoming" || ! "$incoming" =~ ^-?[0-9]+$ ]]
  then
    incoming=0
  fi

  if ! sms_daily_state_write_locked \
    --file "$file" \
    --date "$date" \
    --label "${label:-}" \
    --msisdn "${msisdn:-}" \
    --sent "$sent" \
    --failed "$failed" \
    --incoming "$incoming"
  then
    return 1
  fi

  return 0
}

# Reserve capacity for the specified number of outgoing SMS segments.
sms_daily_limit_reserve() {
  local requested="$1"

  if ! sms_daily_limit_enabled
  then
    return 0
  fi

  if [[ -z "$requested" || ! "$requested" =~ ^[0-9]+$ ]] || (( requested <= 0 ))
  then
    return 0
  fi

  local -a entries=()
  declare -A entry_limits=()
  declare -A entry_labels=()
  declare -A entry_tokens=()
  declare -A entry_msisdn=()

  if [[ -n "$SMS_DAILY_LIMIT_GLOBAL_LIMIT" ]]
  then
    entries+=("global")
    entry_limits["global"]="$SMS_DAILY_LIMIT_GLOBAL_LIMIT"
    entry_labels["global"]="global"
    entry_tokens["global"]="global"
    entry_msisdn["global"]=""
  fi

  if ! sms_daily_limit_identity
  then
    return 1
  fi

  local msisdn_limit
  if [[ -n "$SMS_DAILY_LIMIT_MSISDN" ]]
  then
    msisdn_limit="${SMS_DAILY_LIMIT_MSISDN_LIMITS[$SMS_DAILY_LIMIT_MSISDN]:-}"
  fi

  if [[ -n "$msisdn_limit" ]]
  then
    local per_key="msisdn:${SMS_DAILY_LIMIT_KEY}"
    entries+=("$per_key")
    entry_limits["$per_key"]="$msisdn_limit"
    entry_labels["$per_key"]="$SMS_DAILY_LIMIT_LABEL"
    entry_tokens["$per_key"]="$SMS_DAILY_LIMIT_KEY"
    entry_msisdn["$per_key"]="$SMS_DAILY_LIMIT_MSISDN"
  fi

  if (( ${#entries[@]} == 0 ))
  then
    return 0
  fi

  declare -A entry_files=()
  local entry other
  for entry in "${entries[@]}"
  do
    local token="${entry_tokens[$entry]}"
    local file
    if ! file="$(sms_daily_limit_state_file "$token")"
    then
      return 1
    fi
    entry_files["$entry"]="$file"
  done

  local today
  today="$(date +%Y-%m-%d)"

  declare -A entry_locks=()
  declare -A entry_currents=()
  declare -A entry_prev_exists=()
  declare -A entry_prev_content=()
  declare -A entry_failed=()
  declare -A entry_incoming=()
  declare -A entry_known_labels=()

  for entry in "${entries[@]}"
  do
    local file="${entry_files[$entry]}"
    local lock_handle
    if ! sms_daily_limit_lock_acquire "$file" lock_handle
    then
      echo_error "daily limit: unable to lock counter for ${entry_labels[$entry]}"
      for other in "${entries[@]}"
      do
        if [[ -n "${entry_locks[$other]:-}" ]]
        then
          sms_daily_limit_lock_release "${entry_locks[$other]}"
        fi
      done
      return 1
    fi

    entry_locks["$entry"]="$lock_handle"

    if [[ -e "$file" ]]
    then
      entry_prev_exists["$entry"]=1
      entry_prev_content["$entry"]="$(cat "$file" 2>/dev/null)"
    else
      entry_prev_exists["$entry"]=0
      entry_prev_content["$entry"]=""
    fi

    local current=0
    local current_failed=0
    local current_incoming=0
    local stored_label
    local stored_msisdn
    sms_daily_state_read_today \
      --file "$file" \
      --today "$today" \
      --out-sent-var current \
      --out-failed-var current_failed \
      --out-incoming-var current_incoming \
      --out-label-var stored_label \
      --out-msisdn-var stored_msisdn
    entry_currents["$entry"]="$current"
    entry_failed["$entry"]="$current_failed"
    entry_incoming["$entry"]="$current_incoming"
    entry_known_labels["$entry"]="$stored_label"
    if [[ -z "${entry_msisdn[$entry]:-}" && -n "$stored_msisdn" ]]
    then
      entry_msisdn["$entry"]="$stored_msisdn"
    fi
    if [[ -z "${entry_labels[$entry]:-}" && -n "$stored_label" ]]
    then
      entry_labels["$entry"]="$stored_label"
    fi
  done

  declare -A entry_new_counts=()
  for entry in "${entries[@]}"
  do
    local limit="${entry_limits[$entry]}"
    local current="${entry_currents[$entry]}"
    if (( current + requested > limit ))
    then
      local label="${entry_labels[$entry]}"
      echo_error "daily SMS limit reached for ${label} (limit=$limit, used=$current, requested=$requested)"
      for other in "${entries[@]}"
      do
        if [[ -n "${entry_locks[$other]:-}" ]]
        then
          sms_daily_limit_lock_release "${entry_locks[$other]}"
        fi
      done
      return 1
    fi
    entry_new_counts["$entry"]=$((current + requested))
  done

  local -a updated_entries=()
  for entry in "${entries[@]}"
  do
    local file="${entry_files[$entry]}"
    local new_count="${entry_new_counts[$entry]}"
    local stored_failed="${entry_failed[$entry]:-0}"
    local stored_incoming="${entry_incoming[$entry]:-0}"
    local label="${entry_labels[$entry]:-}"
    local msisdn_value="${entry_msisdn[$entry]:-}"
    if [[ -z "$label" ]]
    then
      label="${entry_known_labels[$entry]:-}"
    fi
    if ! sms_daily_limit_write_state \
      --file "$file" \
      --date "$today" \
      --sent "$new_count" \
      --failed "$stored_failed" \
      --incoming "$stored_incoming" \
      --label "$label" \
      --msisdn "$msisdn_value"
    then
      echo_error "daily limit: failed to update counter for ${entry_labels[$entry]}"
      local prev_entry
      for prev_entry in "${updated_entries[@]}"
      do
        local prev_file="${entry_files[$prev_entry]}"
        if (( ${entry_prev_exists[$prev_entry]} ))
        then
          printf '%s\n' "${entry_prev_content[$prev_entry]}" >"$prev_file" 2>/dev/null || true
        else
          rm -f "$prev_file" 2>/dev/null || true
        fi
      done
      for other in "${entries[@]}"
      do
        if [[ -n "${entry_locks[$other]:-}" ]]
        then
          sms_daily_limit_lock_release "${entry_locks[$other]}"
        fi
      done
      return 1
    fi
    updated_entries+=("$entry")
  done

  for entry in "${entries[@]}"
  do
    if [[ -n "${entry_locks[$entry]:-}" ]]
    then
      sms_daily_limit_lock_release "${entry_locks[$entry]}"
    fi
  done

  SMS_DAILY_LIMIT_ACTIVE_KEYS=("${entries[@]}")
  SMS_DAILY_LIMIT_ACTIVE_FILES=()
  SMS_DAILY_LIMIT_ACTIVE_LABELS=()
  SMS_DAILY_LIMIT_ACTIVE_LIMITS=()
  SMS_DAILY_LIMIT_ACTIVE_COUNTS=()

  for entry in "${entries[@]}"
  do
    SMS_DAILY_LIMIT_ACTIVE_FILES["$entry"]="${entry_files[$entry]}"
    SMS_DAILY_LIMIT_ACTIVE_LABELS["$entry"]="${entry_labels[$entry]}"
    SMS_DAILY_LIMIT_ACTIVE_LIMITS["$entry"]="${entry_limits[$entry]}"
    SMS_DAILY_LIMIT_ACTIVE_COUNTS["$entry"]="${entry_new_counts[$entry]}"

    local label="${entry_labels[$entry]}"
    local limit="${entry_limits[$entry]}"
    local new_count="${entry_new_counts[$entry]}"
    echo_debug "daily limit: reserved $requested message(s) for ${label} (used=$new_count/$limit)"
  done

  SMS_DAILY_LIMIT_RESERVED="$requested"
  SMS_DAILY_LIMIT_SENT=0
  return 0
}

# Release previously reserved capacity from the counter.
sms_daily_limit_release() {
  local amount="$1"

  if ! sms_daily_limit_enabled
  then
    return 0
  fi

  if [[ -z "$amount" || ! "$amount" =~ ^[0-9]+$ ]] || (( amount <= 0 ))
  then
    return 0
  fi

  if (( ${#SMS_DAILY_LIMIT_ACTIVE_KEYS[@]} == 0 ))
  then
    return 0
  fi

  local today
  today="$(date +%Y-%m-%d)"

  local rc=0
  local entry
  for entry in "${SMS_DAILY_LIMIT_ACTIVE_KEYS[@]}"
  do
    local file="${SMS_DAILY_LIMIT_ACTIVE_FILES[$entry]:-}"
    local label="${SMS_DAILY_LIMIT_ACTIVE_LABELS[$entry]:-}"
    local limit="${SMS_DAILY_LIMIT_ACTIVE_LIMITS[$entry]:-}"

    if [[ -z "$file" ]]
    then
      continue
    fi

    local lock_handle
    if ! sms_daily_limit_lock_acquire "$file" lock_handle
    then
      echo_warning "daily limit: could not lock counter to release quota for ${label}"
      rc=1
      continue
    fi

    local current=0
    local current_failed=0
    local current_incoming=0
    local stored_label
    local stored_msisdn
    sms_daily_state_read_today \
      --file "$file" \
      --today "$today" \
      --out-sent-var current \
      --out-failed-var current_failed \
      --out-incoming-var current_incoming \
      --out-label-var stored_label \
      --out-msisdn-var stored_msisdn

    local new_count=0
    if (( amount >= current ))
    then
      new_count=0
    else
      new_count=$((current - amount))
    fi

    local label_for_write="$label"
    if [[ -z "$label_for_write" && -n "$stored_label" ]]
    then
      label_for_write="$stored_label"
    fi

    if ! sms_daily_limit_write_state \
      --file "$file" \
      --date "$today" \
      --sent "$new_count" \
      --failed "$current_failed" \
      --incoming "$current_incoming" \
      --label "$label_for_write" \
      --msisdn "$stored_msisdn"
    then
      echo_warning "daily limit: failed to update counter while releasing quota for ${label}"
      rc=1
      sms_daily_limit_lock_release "$lock_handle"
      continue
    fi

    sms_daily_limit_lock_release "$lock_handle"
    if [[ -n "$limit" ]]
    then
      echo_debug "daily limit: released $amount message(s) for ${label} (used=$new_count/$limit)"
    else
      echo_debug "daily limit: released $amount message(s) for ${label} (used=$new_count)"
    fi
  done

  return $rc
}

# Reset per-message tracking variables after a send attempt finishes.
sms_daily_limit_reset_state() {
  SMS_DAILY_LIMIT_RESERVED=0
  SMS_DAILY_LIMIT_SENT=0
  SMS_DAILY_LIMIT_ACTIVE_KEYS=()
  SMS_DAILY_LIMIT_ACTIVE_FILES=()
  SMS_DAILY_LIMIT_ACTIVE_LABELS=()
  SMS_DAILY_LIMIT_ACTIVE_LIMITS=()
  SMS_DAILY_LIMIT_ACTIVE_COUNTS=()
}

# Finalize a send attempt, optionally releasing unused quota on failure.
sms_daily_limit_finalize() {
  local success="${1:-0}"

  if (( success ))
  then
    sms_daily_limit_reset_state
    return 0
  fi

  local reserved="${SMS_DAILY_LIMIT_RESERVED:-0}"
  local sent="${SMS_DAILY_LIMIT_SENT:-0}"

  if (( reserved > sent ))
  then
    local unused=$((reserved - sent))
    if ! sms_daily_limit_release "$unused"
    then
      echo_warning "daily limit: failed to release $unused reserved message(s)"
    fi
  fi

  sms_daily_limit_reset_state
}

# Log daily usage after a successful send, updating counters when limits are disabled.
sms_daily_limit_log_success() {
  local sent_segments="$1"
  local limit_in_use="${2:-0}"

  if [[ -z "$sent_segments" || ! "$sent_segments" =~ ^[0-9]+$ ]] || (( sent_segments <= 0 ))
  then
    return 0
  fi

  local today
  today="$(date +%Y-%m-%d)"

  local global_logged=0

  if (( limit_in_use )) && (( ${#SMS_DAILY_LIMIT_ACTIVE_KEYS[@]} > 0 ))
  then
    local entry
    for entry in "${SMS_DAILY_LIMIT_ACTIVE_KEYS[@]}"
    do
      local label="${SMS_DAILY_LIMIT_ACTIVE_LABELS[$entry]:-}"
      local limit="${SMS_DAILY_LIMIT_ACTIVE_LIMITS[$entry]:-}"
      local count="${SMS_DAILY_LIMIT_ACTIVE_COUNTS[$entry]:-}"

      if [[ -z "$count" ]]
      then
        local file="${SMS_DAILY_LIMIT_ACTIVE_FILES[$entry]:-}"
        if [[ -n "$file" ]]
        then
          local stored_count=0
          sms_daily_state_read_today \
            --file "$file" \
            --today "$today" \
            --out-sent-var stored_count
          count="$stored_count"
        fi
      fi

      if [[ -z "$label" ]]
      then
        label="$entry"
      fi

      if [[ -z "$count" ]]
      then
        continue
      fi

      if [[ "$entry" == "global" ]]
      then
        global_logged=1
      fi

      if [[ -n "$limit" ]]
      then
        echo_info "daily usage: label='$label' sent ${count}/${limit} message(s) today"
      else
        echo_info "daily usage: label='$label' sent ${count} message(s) today"
      fi
    done
  else
    local identity_ok=0
    if sms_daily_limit_identity
    then
      identity_ok=1
    fi

    if (( identity_ok ))
    then
      local label="$SMS_DAILY_LIMIT_LABEL"
      local token="$SMS_DAILY_LIMIT_KEY"
      local file
      if file="$(sms_daily_limit_state_file "$token")"
      then
        local msisdn="$SMS_DAILY_LIMIT_MSISDN"
        local new_count
        if ! sms_daily_state_increment \
          --file "$file" \
          --label "$label" \
          --msisdn "$msisdn" \
          --sent-delta "$sent_segments" \
          --out-sent-var new_count
        then
          echo_warning "daily usage: failed to update counter for ${label} while limit disabled"
          return 1
        fi

        echo_info "daily usage: label='$label' sent ${new_count} message(s) today (limit disabled)"
      fi
    fi
  fi

  if (( sent_segments > 0 ))
  then
    local need_global=1
    if (( limit_in_use )) && (( global_logged ))
    then
      need_global=0
    fi

    if (( need_global ))
    then
      local global_sent
      if sms_daily_usage_update_global \
        --sent-delta "$sent_segments" \
        --out-sent-var global_sent
      then
        if [[ -n "$global_sent" ]]
        then
          echo_info "daily usage: label='global' sent ${global_sent} message(s) today"
        fi
      fi
    fi
  fi

  return 0
}

# Recompute the global statistics by aggregating all modem counters.
sms_daily_usage_refresh_global() {
  local sent_var
  local failed_var
  local incoming_var
  local dir
  local global_file
  local today
  local total_sent
  local total_failed
  local total_incoming
  local path
  local entry_sent
  local entry_failed
  local entry_incoming
  local lock_handle
  local base_label
  local msisdn_count
  local msisdn_count_json
  local opt

  total_sent=0
  total_failed=0
  total_incoming=0
  msisdn_count=0

  while (( $# > 0 ))
  do
    opt="$1"
    case "$opt" in
      --out-sent-var)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily usage: missing argument for --out-sent-var"
          return 1
        fi
        sent_var="$1"
        shift
        continue
        ;;
      --out-failed-var)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily usage: missing argument for --out-failed-var"
          return 1
        fi
        failed_var="$1"
        shift
        continue
        ;;
      --out-incoming-var)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily usage: missing argument for --out-incoming-var"
          return 1
        fi
        incoming_var="$1"
        shift
        continue
        ;;
      --)
        shift
        break
        ;;
      *)
        echo_error "daily usage: unknown argument '$opt' for sms_daily_usage_refresh_global"
        return 1
        ;;
    esac
  done

  if ! dir="$(sms_daily_limit_state_dir)"
  then
    echo_warning "daily usage: failed to access usage state directory"
    return 1
  fi

  if ! global_file="$(sms_daily_limit_state_file 'global')"
  then
    echo_warning "daily usage: failed to resolve global counter file"
    return 1
  fi

  today="$(date +%Y-%m-%d)"

  shopt -s nullglob
  for path in "$dir"/sms-count-*.state
  do
    [[ -e "$path" ]] || continue
    if [[ "$path" == "$global_file" ]]
    then
      continue
    fi

    msisdn_count=$(( msisdn_count + 1 ))

    entry_sent=0
    entry_failed=0
    entry_incoming=0
    if ! sms_daily_state_read_today \
      --file "$path" \
      --today "$today" \
      --out-sent-var entry_sent \
      --out-failed-var entry_failed \
      --out-incoming-var entry_incoming
    then
      continue
    fi

    if [[ ! "$entry_sent" =~ ^-?[0-9]+$ ]]
    then
      entry_sent=0
    fi

    if [[ ! "$entry_failed" =~ ^-?[0-9]+$ ]]
    then
      entry_failed=0
    fi

    if [[ ! "$entry_incoming" =~ ^-?[0-9]+$ ]]
    then
      entry_incoming=0
    fi

    total_sent=$(( total_sent + entry_sent ))
    total_failed=$(( total_failed + entry_failed ))
    total_incoming=$(( total_incoming + entry_incoming ))
  done
  shopt -u nullglob

  if ! sms_daily_limit_lock_acquire "$global_file" lock_handle
  then
    echo_warning "daily usage: failed to lock global counter for refresh"
    return 1
  fi

  base_label=""
  if ! sms_daily_state_read \
    --file "$global_file" \
    --out-label-var base_label \
    --msisdn-key msisdn_count
  then
    base_label=""
  fi

  if [[ -z "$base_label" ]]
  then
    base_label="global"
  fi

  msisdn_count_json="$msisdn_count"

  if ! sms_daily_state_write_locked \
    --file "$global_file" \
    --date "$today" \
    --label "$base_label" \
    --msisdn-key msisdn_count \
    --msisdn-json "$msisdn_count_json" \
    --sent "$total_sent" \
    --failed "$total_failed" \
    --incoming "$total_incoming"
  then
    sms_daily_limit_lock_release "$lock_handle"
    echo_warning "daily usage: failed to refresh global counter"
    return 1
  fi

  sms_daily_limit_lock_release "$lock_handle"

  sms_daily_usage_fix_global_state

  if [[ -n "$sent_var" ]]
  then
    printf -v "$sent_var" '%s' "$total_sent"
  fi

  if [[ -n "$failed_var" ]]
  then
    printf -v "$failed_var" '%s' "$total_failed"
  fi

  if [[ -n "$incoming_var" ]]
  then
    printf -v "$incoming_var" '%s' "$total_incoming"
  fi

  return 0
}

# Ensure the global counter state JSON reflects aggregated totals for a day.
sms_daily_usage_fix_global_state() {
  local global_file
  if ! global_file="$(sms_daily_limit_state_file 'global')"
  then
    return 0
  fi

  local file_exists
  file_exists=0
  if [[ -e "$global_file" ]]
  then
    file_exists=1
  fi

  local file_empty
  file_empty=1
  if [[ -s "$global_file" ]]
  then
    file_empty=0
  fi

  local lock_handle
  if ! sms_daily_limit_lock_acquire "$global_file" lock_handle
  then
    echo_warning "daily usage: failed to lock global counter for repair"
    return 1
  fi

  local state_date
  local state_label
  local state_sent
  local state_failed
  local state_incoming
  local state_history_json
  local state_msisdn_json
  local msisdn_changed
  local msisdn_entry_count
  local new_msisdn_json
  state_sent=0
  state_failed=0
  state_incoming=0
  state_history_json="[]"
  state_msisdn_json="null"
  msisdn_changed=0
  msisdn_entry_count=0
  new_msisdn_json="null"

  if (( file_exists ))
  then
    if sms_daily_state_read \
      --file "$global_file" \
      --out-date-var state_date \
      --out-label-var state_label \
      --out-sent-var state_sent \
      --out-failed-var state_failed \
      --out-incoming-var state_incoming \
      --out-history-json-var state_history_json \
      --msisdn-key msisdn_count
    then
      :
    else
      echo_warning "daily usage: failed to read global counter while repairing"
    fi
  fi

  if (( file_exists )) && [[ -r "$global_file" ]]
  then
    local msisdn_probe
    if msisdn_probe="$(jq -c 'if has("msisdn_count") then .msisdn_count elif has("msisdn") then .msisdn else "__MMSMS_MISSING__" end' "$global_file" 2>/dev/null)"
    then
      if [[ "$msisdn_probe" != '"__MMSMS_MISSING__"' ]]
      then
        state_msisdn_json="$msisdn_probe"
      fi
    fi
  fi

  if [[ ! "$state_sent" =~ ^-?[0-9]+$ ]]
  then
    state_sent=0
  fi

  if [[ ! "$state_failed" =~ ^-?[0-9]+$ ]]
  then
    state_failed=0
  fi

  if [[ ! "$state_incoming" =~ ^-?[0-9]+$ ]]
  then
    state_incoming=0
  fi

  local state_dir
  state_dir="$(dirname "$global_file")"

  declare -A aggregated_sent=()
  declare -A aggregated_failed=()
  declare -A aggregated_incoming=()
  declare -A aggregated_seen=()
  local -a aggregated_order=()

  if [[ -d "$state_dir" ]]
  then
    local path
    shopt -s nullglob
    for path in "$state_dir"/sms-count-*.state
    do
      if [[ ! -e "$path" ]]
      then
        continue
      fi

      if [[ "$path" == "$global_file" ]]
      then
        continue
      fi

      msisdn_entry_count=$(( msisdn_entry_count + 1 ))

      local entry_date
      local entry_sent
      local entry_failed
      local entry_incoming
      local entry_history_json
      entry_sent=0
      entry_failed=0
      entry_incoming=0
      entry_history_json="[]"

      if ! sms_daily_state_read \
        --file "$path" \
        --out-date-var entry_date \
        --out-sent-var entry_sent \
        --out-failed-var entry_failed \
        --out-incoming-var entry_incoming \
        --out-history-json-var entry_history_json
      then
        continue
      fi

      if [[ ! "$entry_sent" =~ ^-?[0-9]+$ ]]
      then
        entry_sent=0
      fi

      if [[ ! "$entry_failed" =~ ^-?[0-9]+$ ]]
      then
        entry_failed=0
      fi

      if [[ ! "$entry_incoming" =~ ^-?[0-9]+$ ]]
      then
        entry_incoming=0
      fi

      if [[ -n "$entry_date" ]]
      then
        if [[ -z "${aggregated_seen[$entry_date]:-}" ]]
        then
          aggregated_order+=("$entry_date")
          aggregated_seen["$entry_date"]=1
        fi

        local current_sent
        current_sent="${aggregated_sent[$entry_date]:-0}"
        if [[ ! "$current_sent" =~ ^-?[0-9]+$ ]]
        then
          current_sent=0
        fi

        local current_failed
        current_failed="${aggregated_failed[$entry_date]:-0}"
        if [[ ! "$current_failed" =~ ^-?[0-9]+$ ]]
        then
          current_failed=0
        fi

        local current_incoming
        current_incoming="${aggregated_incoming[$entry_date]:-0}"
        if [[ ! "$current_incoming" =~ ^-?[0-9]+$ ]]
        then
          current_incoming=0
        fi

        aggregated_sent["$entry_date"]=$((current_sent + entry_sent))
        aggregated_failed["$entry_date"]=$((current_failed + entry_failed))
        aggregated_incoming["$entry_date"]=$((current_incoming + entry_incoming))
      fi

      if [[ -n "$entry_history_json" && "$entry_history_json" != "[]" ]]
      then
        local history_lines
        history_lines="$(jq -r 'map([.date // "", (.outgoing.sent // 0), (.outgoing.failed // 0), (.incoming.received // 0)] | @tsv)[]' <<<"$entry_history_json" 2>/dev/null)"
        if [[ -n "$history_lines" ]]
        then
          local history_date
          local history_sent
          local history_failed
          local history_incoming
          local hist_sent
          local hist_failed
          local hist_incoming
          while IFS=$'\t' read -r history_date history_sent history_failed history_incoming
          do
            if [[ -z "$history_date" ]]
            then
              continue
            fi

            if [[ ! "$history_sent" =~ ^-?[0-9]+$ ]]
            then
              history_sent=0
            fi

            if [[ ! "$history_failed" =~ ^-?[0-9]+$ ]]
            then
              history_failed=0
            fi

            if [[ ! "$history_incoming" =~ ^-?[0-9]+$ ]]
            then
              history_incoming=0
            fi

            if [[ -z "${aggregated_seen[$history_date]:-}" ]]
            then
              aggregated_order+=("$history_date")
              aggregated_seen["$history_date"]=1
            fi

            hist_sent="${aggregated_sent[$history_date]:-0}"
            if [[ ! "$hist_sent" =~ ^-?[0-9]+$ ]]
            then
              hist_sent=0
            fi

            hist_failed="${aggregated_failed[$history_date]:-0}"
            if [[ ! "$hist_failed" =~ ^-?[0-9]+$ ]]
            then
              hist_failed=0
            fi

            hist_incoming="${aggregated_incoming[$history_date]:-0}"
            if [[ ! "$hist_incoming" =~ ^-?[0-9]+$ ]]
            then
              hist_incoming=0
            fi

            aggregated_sent["$history_date"]=$((hist_sent + history_sent))
            aggregated_failed["$history_date"]=$((hist_failed + history_failed))
            aggregated_incoming["$history_date"]=$((hist_incoming + history_incoming))
          done <<<"$history_lines"
        fi
      fi
    done
    shopt -u nullglob
  fi

  new_msisdn_json="$msisdn_entry_count"

  if [[ "$state_msisdn_json" != "$new_msisdn_json" ]]
  then
    msisdn_changed=1
  fi

  local history_days_config
  history_days_config="$SMS_STATS_HISTORY_DAYS"
  if [[ ! "$history_days_config" =~ ^[0-9]+$ ]]
  then
    history_days_config=7
  elif (( history_days_config < 1 ))
  then
    history_days_config=7
  fi

  local write_label
  write_label="$state_label"
  if [[ -z "$write_label" ]]
  then
    write_label="global"
  fi

  local rebuild_done
  rebuild_done=0

  local selected_date=""
  local new_sent=0
  local new_failed=0
  local new_incoming=0

  if (( ${#aggregated_order[@]} > 0 ))
  then
    local -a sorted_dates=()
    if mapfile -t sorted_dates < <(printf '%s\n' "${aggregated_order[@]}" | sed '/^$/d' | sort)
    then
      :
    else
      sorted_dates=()
    fi

    local sorted_count=${#sorted_dates[@]}
    if (( sorted_count > 0 ))
    then
      local history_days="$history_days_config"
      if [[ ! "$history_days" =~ ^[0-9]+$ ]]
      then
        history_days=7
      elif (( history_days < 1 ))
      then
        history_days=1
      fi

      local start_index=0
      if (( sorted_count > history_days ))
      then
        start_index=$((sorted_count - history_days))
      fi

      local -a write_dates=()
      local idx
      for (( idx=start_index; idx<sorted_count; idx++ ))
      do
        if [[ -n "${sorted_dates[idx]}" ]]
        then
          write_dates+=("${sorted_dates[idx]}")
        fi
      done

      if (( ${#write_dates[@]} > 0 ))
      then
        rebuild_done=1
        rm -f "$global_file"

        local date_to_write
        for date_to_write in "${write_dates[@]}"
        do
          local write_sent="${aggregated_sent[$date_to_write]:-0}"
          local write_failed="${aggregated_failed[$date_to_write]:-0}"
          local write_incoming="${aggregated_incoming[$date_to_write]:-0}"

          if [[ ! "$write_sent" =~ ^-?[0-9]+$ ]]
          then
            write_sent=0
          fi
          if [[ ! "$write_failed" =~ ^-?[0-9]+$ ]]
          then
            write_failed=0
          fi
          if [[ ! "$write_incoming" =~ ^-?[0-9]+$ ]]
          then
            write_incoming=0
          fi

          if ! sms_daily_state_write_locked \
            --file "$global_file" \
            --date "$date_to_write" \
            --label "$write_label" \
            --msisdn-key msisdn_count \
            --msisdn-json "$new_msisdn_json" \
            --sent "$write_sent" \
            --failed "$write_failed" \
            --incoming "$write_incoming"
          then
            sms_daily_limit_lock_release "$lock_handle"
            echo_warning "daily usage: failed to repair global counter"
            return 1
          fi
        done

        selected_date="${write_dates[$(( ${#write_dates[@]} - 1 ))]}"
        new_sent="${aggregated_sent[$selected_date]:-0}"
        new_failed="${aggregated_failed[$selected_date]:-0}"
        new_incoming="${aggregated_incoming[$selected_date]:-0}"

        if [[ ! "$new_sent" =~ ^-?[0-9]+$ ]]
        then
          new_sent=0
        fi
        if [[ ! "$new_failed" =~ ^-?[0-9]+$ ]]
        then
          new_failed=0
        fi
        if [[ ! "$new_incoming" =~ ^-?[0-9]+$ ]]
        then
          new_incoming=0
        fi
      fi
    fi
  fi

  if (( ! rebuild_done ))
  then
    if [[ -n "$state_date" && -n "${aggregated_seen[$state_date]:-}" ]]
    then
      selected_date="$state_date"
    fi

    if [[ -z "$selected_date" ]]
    then
      local candidate
      for candidate in "${aggregated_order[@]}"
      do
        if [[ -z "$candidate" ]]
        then
          continue
        fi

        if [[ -z "$selected_date" || "$candidate" > "$selected_date" ]]
        then
          selected_date="$candidate"
        fi
      done
    fi

    if [[ -z "$selected_date" && -n "$state_history_json" && "$state_history_json" != "[]" ]]
    then
      local history_candidate
      history_candidate="$(jq -r 'map(.date // empty) | map(select(. != "")) | .[0] // empty' <<<"$state_history_json" 2>/dev/null)"
      if [[ -n "$history_candidate" ]]
      then
        selected_date="$history_candidate"
      fi
    fi

    if [[ -z "$selected_date" && -n "$state_date" ]]
    then
      selected_date="$state_date"
    fi

    if [[ -z "$selected_date" ]]
    then
      selected_date="$(date +%Y-%m-%d)"
    fi

    new_sent=0
    new_failed=0
    new_incoming=0

    if [[ -n "$selected_date" && -n "${aggregated_seen[$selected_date]:-}" ]]
    then
      new_sent="${aggregated_sent[$selected_date]:-0}"
      new_failed="${aggregated_failed[$selected_date]:-0}"
      new_incoming="${aggregated_incoming[$selected_date]:-0}"
    fi

    if [[ ! "$new_sent" =~ ^-?[0-9]+$ ]]
    then
      new_sent=0
    fi

    if [[ ! "$new_failed" =~ ^-?[0-9]+$ ]]
    then
      new_failed=0
    fi

    if [[ ! "$new_incoming" =~ ^-?[0-9]+$ ]]
    then
      new_incoming=0
    fi

    local needs_update
    needs_update=0
    if (( ! file_exists || file_empty ))
    then
      needs_update=1
    fi

    if [[ "$selected_date" != "${state_date:-}" ]]
    then
      needs_update=1
    elif (( new_sent != state_sent || new_failed != state_failed || new_incoming != state_incoming ))
    then
      needs_update=1
    fi

    if [[ "$write_label" != "${state_label:-}" ]]
    then
      needs_update=1
    fi

    if (( msisdn_changed ))
    then
      needs_update=1
    fi

    if (( ! needs_update ))
    then
      sms_daily_limit_lock_release "$lock_handle"
      return 0
    fi

    if ! sms_daily_state_write_locked \
      --file "$global_file" \
      --date "$selected_date" \
      --label "$write_label" \
      --msisdn-key msisdn_count \
      --msisdn-json "$new_msisdn_json" \
      --sent "$new_sent" \
      --failed "$new_failed" \
      --incoming "$new_incoming"
    then
      sms_daily_limit_lock_release "$lock_handle"
      echo_warning "daily usage: failed to repair global counter"
      return 1
    fi
  fi

  sms_daily_limit_lock_release "$lock_handle"
  echo_debug "daily usage: recomputed global counter for $selected_date"
  return 0
}

# Update the global usage counters by applying the provided deltas.
sms_daily_usage_update_global() {
  local sent_delta
  local failed_delta
  local incoming_delta
  local sent_out_var
  local failed_out_var
  local incoming_out_var
  local -a refresh_args
  local opt

  sent_delta=0
  failed_delta=0
  incoming_delta=0

  while (( $# > 0 ))
  do
    opt="$1"
    case "$opt" in
      --sent-delta)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily usage: missing argument for --sent-delta"
          return 1
        fi
        sent_delta="$1"
        shift
        continue
        ;;
      --failed-delta)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily usage: missing argument for --failed-delta"
          return 1
        fi
        failed_delta="$1"
        shift
        continue
        ;;
      --incoming-delta)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily usage: missing argument for --incoming-delta"
          return 1
        fi
        incoming_delta="$1"
        shift
        continue
        ;;
      --out-sent-var)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily usage: missing argument for --out-sent-var"
          return 1
        fi
        sent_out_var="$1"
        shift
        continue
        ;;
      --out-failed-var)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily usage: missing argument for --out-failed-var"
          return 1
        fi
        failed_out_var="$1"
        shift
        continue
        ;;
      --out-incoming-var)
        shift
        if (( $# == 0 ))
        then
          echo_error "daily usage: missing argument for --out-incoming-var"
          return 1
        fi
        incoming_out_var="$1"
        shift
        continue
        ;;
      --)
        shift
        break
        ;;
      *)
        echo_error "daily usage: unknown argument '$opt' for sms_daily_usage_update_global"
        return 1
        ;;
    esac
  done

  if [[ -z "$sent_delta" || ! "$sent_delta" =~ ^-?[0-9]+$ ]]
  then
    sent_delta=0
  fi
  if [[ -z "$failed_delta" || ! "$failed_delta" =~ ^-?[0-9]+$ ]]
  then
    failed_delta=0
  fi
  if [[ -z "$incoming_delta" || ! "$incoming_delta" =~ ^-?[0-9]+$ ]]
  then
    incoming_delta=0
  fi

  if (( sent_delta == 0 && failed_delta == 0 && incoming_delta == 0 ))
  then
    return 0
  fi

  refresh_args=()

  if [[ -n "$sent_out_var" ]]
  then
    refresh_args+=("--out-sent-var" "$sent_out_var")
  fi

  if [[ -n "$failed_out_var" ]]
  then
    refresh_args+=("--out-failed-var" "$failed_out_var")
  fi

  if [[ -n "$incoming_out_var" ]]
  then
    refresh_args+=("--out-incoming-var" "$incoming_out_var")
  fi

  if ! sms_daily_usage_refresh_global "${refresh_args[@]}"
  then
    echo_warning "daily usage: failed to refresh global counter"
    return 1
  fi

  return 0
}

# Record a failed attempt to send an SMS for the current modem identity.
sms_daily_usage_record_failure() {
  local attempts="$1"

  if [[ -z "$attempts" || ! "$attempts" =~ ^[0-9]+$ ]] || (( attempts <= 0 ))
  then
    attempts=1
  fi

  if ! sms_daily_limit_identity
  then
    return 0
  fi

  local label="$SMS_DAILY_LIMIT_LABEL"
  local token="$SMS_DAILY_LIMIT_KEY"
  local msisdn="$SMS_DAILY_LIMIT_MSISDN"

  local file
  if ! file="$(sms_daily_limit_state_file "$token")"
  then
    return 0
  fi

  local updated_failed=0
  if ! sms_daily_state_increment \
    --file "$file" \
    --label "$label" \
    --msisdn "$msisdn" \
    --failed-delta "$attempts" \
    --out-failed-var updated_failed
  then
    echo_warning "daily usage: failed to record failure for ${label}"
    return 1
  fi

  echo_info "daily usage: label='$label' failures=${updated_failed} today"
  sms_daily_usage_update_global \
    --failed-delta "$attempts"
  return 0
}

# Record an incoming SMS for statistics tracking.
sms_daily_usage_record_incoming() {
  local msisdn_hint="${1:-}"

  if [[ -n "$msisdn_hint" ]]
  then
    if ! sms_daily_limit_identity "$msisdn_hint" "$msisdn_hint"
    then
      return 0
    fi
  elif ! sms_daily_limit_identity
  then
    return 0
  fi

  local label="$SMS_DAILY_LIMIT_LABEL"
  local token="$SMS_DAILY_LIMIT_KEY"
  local msisdn="$SMS_DAILY_LIMIT_MSISDN"

  local file
  if ! file="$(sms_daily_limit_state_file "$token")"
  then
    return 0
  fi

  local updated_incoming=0
  if ! sms_daily_state_increment \
    --file "$file" \
    --label "$label" \
    --msisdn "$msisdn" \
    --incoming-delta 1 \
    --out-incoming-var updated_incoming
  then
    echo_warning "daily usage: failed to record incoming message for ${label}"
    return 1
  fi

  if [[ -z "$label" ]]
  then
    label="$token"
  fi
  echo_info "daily usage: label='$label' received ${updated_incoming} message(s) today"
  sms_daily_usage_update_global \
    --incoming-delta 1
  return 0
}


# Send an SMS, handling defaults, validation, and optional chunking.
sms_send() {
  local recipient
  local text
  local recipient_was_default=0

  # Parse args: allow default recipient when not specified
  if (( $# >= 1 ))
  then
    if [[ "$1" == "-" ]]
    then
      shift
    elif [[ "$1" == +* || "$1" =~ ^[0-9]+$ ]]
    then
      recipient="$1"
      shift
    fi
  fi

  if [[ $# -eq 0 || "$1" == "-" ]]
  then
    [[ "$1" == "-" ]] && shift
    echo_info "Reading SMS text from stdin... Ctrl-D to end"
    text="$(cat)"
  else
    text="$*"
  fi

  if [[ -z "$recipient" ]]
  then
    # Try to load defaults from config when sending without explicit recipient
    # shellcheck disable=SC2031
    recipient="$(resolve_default_recipient "$MODEM")"
    if [[ -z "$recipient" ]]
    then
      echo_error "no recipient specified and no DEFAULT_RECIPIENT configured for this modem/country"
      return 2
    fi
    recipient_was_default=1
  fi

  recipient="${recipient//[[:space:]]/}"
  recipient="$(ensure_plus "$recipient")"

  SMS_LAST_RECIPIENT="$recipient"
  SMS_LAST_RECIPIENT_FROM_DEFAULT="$recipient_was_default"

  # Enforce local-only sending unless --allow-foreign is set
  if [[ -z "$ALLOW_FOREIGN" ]]
  then
    local home_cc
    # shellcheck disable=SC2031
    home_cc="$(get_home_cc "$MODEM")"
    if [[ -n "$home_cc" && "$recipient" == +([0-9]) ]]
    then
      if [[ "$recipient" != +"$home_cc"* ]]
      then
        echo_warning "blocking foreign recipient $recipient (home CC=$home_cc); use --allow-foreign to override or set HOME_CC"
        return 1
      fi
    fi
  fi

  if [[ -z "$text" ]]
  then
    echo_error "no SMS text provided"
    return 2
  fi

  # Expand common escapes and strip trailing whitespace to avoid stray spaces
  text="$(printf '%b' "$text" | sed -e 's/[[:space:]]\+$//')"

  local chunk_size
  if [[ -n "$SMS_CHUNK_SIZE" ]]
  then
    if [[ "$SMS_CHUNK_SIZE" =~ ^[0-9]+$ ]] && (( SMS_CHUNK_SIZE > 0 ))
    then
      chunk_size="$SMS_CHUNK_SIZE"
    else
      echo_error "invalid chunk size '$SMS_CHUNK_SIZE', expected positive integer"
      return 2
    fi
  fi

  local -a send_chunks=("$text")
  if [[ -n "$chunk_size" ]]
  then
    send_chunks=()
    local text_remaining="$text"
    while [[ -n "$text_remaining" ]]
    do
      local remaining_len=${#text_remaining}
      if (( remaining_len <= chunk_size ))
      then
        send_chunks+=("$text_remaining")
        break
      fi

      local chunk="${text_remaining:0:chunk_size}"
      local cut_length="$chunk_size"
      local break_pos=-1
      local i

      for (( i=cut_length-1; i>=0; i-- ))
      do
        local char="${chunk:i:1}"
        if [[ "$char" =~ [[:space:]] ]]
        then
          break_pos=$i
          break
        fi
      done

      if (( break_pos >= 0 ))
      then
        cut_length=$((break_pos + 1))
      elif [[ "${text_remaining:chunk_size:1}" =~ [[:space:]] ]]
      then
        cut_length=$((chunk_size + 1))
      fi

      while (( cut_length < remaining_len )) && [[ "${text_remaining:cut_length:1}" =~ [[:space:]] ]]
      do
        cut_length=$((cut_length + 1))
      done

      send_chunks+=( "${text_remaining:0:cut_length}" )
      text_remaining="${text_remaining:cut_length}"
    done
  fi

  local total_chunks=${#send_chunks[@]}
  local chunk_index=1
  local chunk_rc=0

  sms_daily_limit_reset_state

  local limit_in_use=0
  if (( total_chunks > 0 )) && sms_daily_limit_enabled
  then
    if ! sms_daily_limit_reserve "$total_chunks"
    then
      sms_daily_limit_reset_state
      return 1
    fi
    limit_in_use=1
  fi

  for chunk_text in "${send_chunks[@]}"
  do
    sms_send_chunk_text "$recipient" "$chunk_text" "$chunk_index" "$total_chunks" "$chunk_size"
    chunk_rc=$?
    if (( chunk_rc != 0 ))
    then
      if (( limit_in_use ))
      then
        sms_daily_limit_finalize 0
      fi
      sms_daily_usage_record_failure 1
      return $chunk_rc
    fi
    if (( limit_in_use ))
    then
      SMS_DAILY_LIMIT_SENT=$((SMS_DAILY_LIMIT_SENT + 1))
    fi
    chunk_index=$((chunk_index + 1))
  done

  if (( limit_in_use ))
  then
    sms_daily_limit_log_success "$total_chunks" 1
    sms_daily_limit_finalize 1
  else
    sms_daily_limit_log_success "$total_chunks" 0
  fi

  return 0
}

# Send a single SMS chunk with retries and logging.
sms_send_chunk_text() {
  local recipient="$1"
  local text="$2"
  local chunk_index="${3:-1}"
  local chunk_total="${4:-1}"
  local chunk_size="${5:-}"

  local chunk_label
  if (( chunk_total > 1 ))
  then
    chunk_label=" chunk ${chunk_index}/${chunk_total}"
  fi

  local chunk_size_note
  if (( chunk_total > 1 )) && [[ -n "$chunk_size" ]]
  then
    chunk_size_note=" (chunk-size=$chunk_size)"
  fi

  # Log outgoing SMS (preview) to stderr and syslog
  local log_text
  log_text="$(abbrev_text_for_log "$text")"
  local log_modem
  log_modem="$(modem_info_brief)"
  echo_info "sending sms${chunk_label}${chunk_size_note} with modem={$log_modem} recipient='$recipient' text='$log_text'"

  local tmpfile
  if ! tmpfile="$(mktemp "${TMPDIR:-/tmp}/mmsms-text.XXXXXX")"
  then
    echo_error "failed to create temporary file for SMS text${chunk_label}"
    return 1
  fi

  if ! printf '%s' "$text" >"$tmpfile"
  then
    rm -f "$tmpfile"
    echo_error "failed to write SMS text to temporary file${chunk_label}"
    return 1
  fi

  local sms_id
  local smsc_params

  local smsc_raw
  smsc_raw="$(get_smsc_number "$MODEM")"

  local smsc
  if [[ -n "$smsc_raw" ]]
  then
    smsc="${smsc_raw//[[:space:]]/}"

    if [[ -n "$smsc" && "$smsc" != +* ]]
    then
      smsc="+$smsc"
    fi

    if [[ -n "$smsc" && "$smsc" =~ ^\+[0-9]+$ ]]
    then
      smsc_params=",smsc=$smsc"
    elif [[ -n "$smsc_raw" ]]
    then
      echo_warning "invalid smsc '$smsc_raw', skipping"
      smsc=""
    fi
  fi

  local create_attempt=1
  local max_attempts=$SMS_RETRY_COUNT
  local rc=1

  # Create the SMS first (retrying creation only if creation itself fails)
  if (( max_attempts < 1 ))
  then
    max_attempts=1
  fi

  local create_json
  while (( create_attempt <= max_attempts ))
  do
    sms_id=""
    if ! create_json="$(mmcli_cmd -J --messaging-create-sms="number=${recipient}${smsc_params}" \
      --messaging-create-sms-with-text="$tmpfile")"
    then
      if (( create_attempt >= max_attempts ))
      then
        echo_error "failed to create SMS${chunk_label} after $max_attempts attempts"
        rm -f "$tmpfile"
        return 1
      fi

      echo_warning "failed to create SMS${chunk_label} (attempt $create_attempt/$max_attempts), retrying"
      create_attempt=$((create_attempt + 1))
      continue
    fi

    if ! sms_id="$(jq -er '.modem.messaging["created-sms"] // empty' <<<"$create_json")"
    then
      if (( create_attempt == max_attempts ))
      then
        echo_error "failed to create SMS${chunk_label} after $max_attempts attempts"
        rm -f "$tmpfile"
        return 1
      fi

      echo_warning "received empty SMS id${chunk_label} (attempt $create_attempt/$max_attempts), retrying"
      create_attempt=$((create_attempt + 1))
      continue
    fi
    break
  done

  # Now retry only the send step for the created SMS id
  local send_attempt=1
  if (( max_attempts < 1 ))
  then
    max_attempts=1
  fi

  while (( send_attempt <= max_attempts ))
  do
    if mmcli_cmd --sms "$sms_id" --send --timeout="$SMS_SEND_TIMEOUT"
    then
      rc=0
      echo_success "message '${sms_id}' sent with modem={${log_modem}} recipient='$recipient'${chunk_label}"
      break
    fi

    if (( send_attempt >= max_attempts ))
    then
      echo_error "failed to send SMS '${sms_id}'${chunk_label} after $max_attempts attempts"
      break
    fi

    echo_warning "failed to send SMS '${sms_id}'${chunk_label} (attempt $send_attempt/$max_attempts), retrying"
    send_attempt=$((send_attempt + 1))
  done

  # direct send failure logs use echo_warning at call site; SYSLOG_MIRROR handles mirroring

  rm -f "$tmpfile"
  return $rc
}

# Determine if a recipient is allowed for a given modem id based on
# --allow-foreign/HOME_CC. Returns 0 if allowed, 1 if blocked.
recipient_allowed_for_modem() {
  local recipient="$1"
  local mid="$2"

  if [[ -n "$ALLOW_FOREIGN" ]]
  then
    return 0
  fi

  local hcc
  hcc="$(get_home_cc "$mid")"

  if [[ -z "$hcc" ]]
  then
    echo_warning "Failed to determine home CC for modem id '$mid', blocking foreign recipient '$recipient'"
    return 1
  fi

  recipient=$(ensure_plus "$recipient")
  if [[ "$recipient" == +"$hcc"* ]]
  then
    return 0
  fi

  return 1
}

# Retry sending an SMS on alternate modems when fallback is enabled.
sms_send_with_fallback() {
  local orig_args=("$@")
  local args=("$@")
  local recipient
  local text

  # First attempt with the original arguments
  if sms_send "${orig_args[@]}"
  then
    return 0
  fi

  if [[ -z "$FALLBACK" ]]
  then
    return 1
  fi

  # Parse optional recipient from arguments
  if (( ${#args[@]} > 0 ))
  then
    case "${args[0]}" in
      -)
        args=("${args[@]:1}")
        ;;
      +*|[0-9]*)
        recipient="${args[0]}"
        args=("${args[@]:1}")
        ;;
    esac
  fi

  if (( ${#args[@]} > 0 )) && [[ "${args[0]}" == "-" ]]
  then
    args=("${args[@]:1}")
  fi

  if (( ${#args[@]} > 0 ))
  then
    text="${args[*]}"
  fi

  if [[ -z "$text" ]]
  then
    echo_warning "fallback: message text unavailable for resend"
    return 1
  fi

  local resolved_recipient="${SMS_LAST_RECIPIENT:-$recipient}"
  local orig_recipient_default_flag="${SMS_LAST_RECIPIENT_FROM_DEFAULT:-0}"
  recipient="$resolved_recipient"

  # Gather other modems
  local cur_id="$MODEM"

  if [[ "$cur_id" == "any" ]]
  then
    local _j
    if _j="$(mmcli_cmd -J)"
    then
      cur_id="$(jq -r '.modem["dbus-path"] | split("/")[-1] // empty' <<<"$_j")"
    fi
  fi

  local mids
  if ! mapfile -t mids < <(list_modem_ids_sorted)
  then
    return 1
  fi

  local mid
  for mid in "${mids[@]}"
  do
    [[ -z "$mid" || "$mid" == "$cur_id" ]] && continue
    local prev_mode="$MODEM"
    MODEM="$mid"
    local candidate_recipient="$recipient"
    local used_auto
    local auto_tried=0

    if ! recipient_allowed_for_modem "$candidate_recipient" "$mid"
    then
      if [[ -n "$AUTO_RECIPIENT" && "$orig_recipient_default_flag" == "1" ]]
      then
        auto_tried=1
        local auto_recipient
        if auto_recipient="$(resolve_default_recipient "$mid")"
        then
          auto_recipient="${auto_recipient//[[:space:]]/}"
          auto_recipient="$(ensure_plus "$auto_recipient")"
        else
          auto_recipient=""
        fi

        if [[ -n "$auto_recipient" ]] && ! recipient_allowed_for_modem "$auto_recipient" "$mid"
        then
          auto_recipient=""
        fi

        if [[ -n "$auto_recipient" ]]
        then
          candidate_recipient="$auto_recipient"
          used_auto=1
        fi
      fi

      if [[ -z "$used_auto" ]]
      then
        local info
        info="$(modem_info_brief)"
        if [[ "$auto_tried" == 1 ]]
        then
          echo_warning "fallback: modem=$info has no eligible default recipient (auto-recipient unavailable)"
        else
          echo_warning "fallback: cannot use modem=$info for recipient $recipient (foreign not allowed; use --allow-foreign)"
        fi
        MODEM="$prev_mode"
        continue
      fi
    fi

    if [[ -n "$used_auto" ]]
    then
      local info
      info="$(modem_info_brief)"
      echo_info "fallback: using modem=$info default_recipient='$candidate_recipient'"
    fi

    echo_debug "fallback: sending text='$text'"
    echo_debug "fallback: trying modem $mid"

    if sms_send "$candidate_recipient" "$text"
    then
      local info
      info="$(modem_info_brief)"
      MODEM="$prev_mode"

      echo_info "fallback send succeeded using modem=$info"
      return 0
    fi
    MODEM="$prev_mode"
  done

  echo_warning "fallback: no eligible modem could send the message"
  return 1
}

# Delete all SMS messages on the currently selected modem.
sms_prune_all() {
  local ids
  mapfile -t ids < <(mmcli_cmd --messaging-list-sms -J | \
    jq -r '."modem.messaging.sms"[]? | split("/")[-1]' | sort -n)

  local total=${#ids[@]}
  if (( total == 0 ))
  then
    return 0
  fi

  local i=0 sms_id
  for sms_id in "${ids[@]}"
  do
    [[ -z "$sms_id" ]] && continue
    i=$((i + 1))
    echo_info "deleting SMS $sms_id ($i/$total)"
    if ! mmcli_cmd --messaging-delete-sms="$sms_id"
    then
      echo_error "failed to delete SMS $sms_id"
    fi
  done
}

# Delete sent outgoing SMS messages on the current modem.
sms_prune_sent() {
  # Delete only messages that are outgoing and already sent
  local list ids id js state pdu sent_ids=()

  if ! list="$(mmcli_cmd --messaging-list-sms -J)"
  then
    return 0
  fi

  mapfile -t ids < <(jq -r '
    ."modem.messaging.sms"[]? | split("/")[-1]
  ' <<<"$list" | sort -n)

  if (( ${#ids[@]} == 0 ))
  then
    return 0
  fi

  # First collect sent IDs
  for id in "${ids[@]}"
  do
    [[ -z "$id" ]] && continue
    if ! js="$(mmcli_cmd --sms "$id" -J)"
    then
      echo_warning "failed to read SMS $id, skipping"
      continue
    fi
    state="$(jq -r '.sms.properties.state // empty' <<<"$js")"
    pdu="$(jq -r '.sms.properties["pdu-type"] // empty' <<<"$js")"
    if [[ "$state" == "sent" && "$pdu" == "submit" ]]
    then
      sent_ids+=("$id")
    fi
  done

  local total=${#sent_ids[@]}
  if (( total == 0 ))
  then
    return 0
  fi

  local i=0
  for id in "${sent_ids[@]}"
  do
    i=$((i + 1))
    echo_info "deleting sent SMS $id ($i/$total)"
    mmcli_cmd --messaging-delete-sms="$id"
  done
}

# Delete sent SMS messages across all detected modems.
sms_prune_sent_modems() {
  local mids mid

  if ! mapfile -t mids < <(list_modem_ids_sorted)
  then
    echo_error "failed to list modems for pruning"
    return 1
  fi

  if (( ${#mids[@]} == 0 ))
  then
    echo_info "no modems detected"
    return 0
  fi

  for mid in "${mids[@]}"
  do
    [[ -z "$mid" ]] && continue
    echo_info "pruning sent messages on modem $mid"
    MODEM=$mid sms_prune_sent || echo_error "failed to prune sent messages on modem $mid"
  done
}

# Delete all SMS messages across all detected modems.
sms_prune_all_modems() {
  local mids mid
  if ! mapfile -t mids < <(list_modem_ids_sorted)
  then
    echo_error "failed to list modems for pruning"
    return 1
  fi

  if (( ${#mids[@]} == 0 ))
  then
    echo_info "no modems detected"
    return 0
  fi

  for mid in "${mids[@]}"
  do
    [[ -z "$mid" ]] && continue
    echo_info "pruning modem $mid"
    MODEM="$mid" sms_prune_all || echo_error "failed to prune on modem $mid"
  done
}

# Print the header row for SMS listing output.
sms_list_print_header() {
  local include_mid
  local header

  while (( $# > 0 ))
  do
    case "$1" in
      --include-modem-id)
        include_mid=1
        shift
        ;;
      *)
        echo_error "sms_list_print_header: unknown option '$1'"
        return 2
        ;;
    esac
  done

  if [[ -n "$include_mid" ]]
  then
    header="$(printf '%-4s %-4s %-10s %-18s %s' 'MID' 'ID' 'TYPE' 'RECIPIENT' 'MSG')"
  else
    header="$(printf '%-4s %-10s %-18s %s' 'ID' 'TYPE' 'RECIPIENT' 'MSG')"
  fi

  if [[ -n "$NO_COLOR" || -n "$CRON" ]]
  then
    printf '%s\n' "$header"
  else
    printf '\e[1m%s\e[0m\n' "$header"
  fi
}

# Print a formatted table row for a single SMS entry.
sms_list_print_entry() {
  local mid="$1"
  local id="$2"
  local js="$3"
  shift 3

  local include_mid
  local maxlen=80
  local sender text msg_type pdu

  while (( $# > 0 ))
  do
    case "$1" in
      --include-modem-id)
        include_mid=1
        shift
        ;;
      --max-length)
        if (( $# < 2 ))
        then
          echo_error "sms_list_print_entry: missing value for --max-length"
          return 2
        fi
        if [[ ! "$2" =~ ^[0-9]+$ ]]
        then
          echo_error "sms_list_print_entry: --max-length requires a non-negative integer"
          return 2
        fi
        maxlen="$2"
        shift 2
        ;;
      --max-length=*)
        local value
        value="${1#*=}"
        if [[ -z "$value" ]]
        then
          echo_error "sms_list_print_entry: missing value for --max-length"
          return 2
        fi
        if [[ ! "$value" =~ ^[0-9]+$ ]]
        then
          echo_error "sms_list_print_entry: --max-length requires a non-negative integer"
          return 2
        fi
        maxlen="$value"
        shift
        ;;
      *)
        echo_error "sms_list_print_entry: unknown option '$1'"
        return 2
        ;;
    esac
  done

  sender="$(jq -r '.sms.content.number // "--"' <<<"$js")"
  sender="$(ensure_plus "$sender")"
  pdu="$(jq -r '.sms.properties["pdu-type"] // ""' <<<"$js")"
  msg_type="$(pdu_to_type "$pdu")"
  text="$(jq -r '.sms.content.text // ""' <<<"$js")"
  text=${text//$'\r'/}
  text=${text//$'\n'/\\n}
  if (( ${#text} > maxlen ))
  then
    text="${text:0:maxlen}…"
  fi

  local id_display
  printf -v id_display '%-4s' "$id"

  local type_display
  printf -v type_display '%-10s' "$msg_type"

  local recipient_display
  printf -v recipient_display '%-18s' "$sender"

  local message_display="$text"

  local mid_display
  if [[ -n "$include_mid" ]]
  then
    printf -v mid_display '%-4s' "$mid"
  fi

  if [[ -z "$NO_COLOR" && -z "$CRON" ]]
  then
    local color_reset
    color_reset="$(ansi_escape "$COLOR_RESET")"

    if [[ -n "$color_reset" ]]
    then
      local type_color_code
      type_color_code="$(sms_type_color "$msg_type")"

      if [[ -n "$type_color_code" ]]
      then
        local type_color_seq
        type_color_seq="$(ansi_escape "$type_color_code")"
        if [[ -n "$type_color_seq" ]]
        then
          type_display="${type_color_seq}${type_display}${color_reset}"
        fi
      fi

      local recipient_color_seq
      recipient_color_seq="$(ansi_escape "$COLOR_BOLD_MAGENTA")"
      if [[ -n "$recipient_color_seq" ]]
      then
        recipient_display="${recipient_color_seq}${recipient_display}${color_reset}"
      fi

      local message_color_seq
      message_color_seq="$(ansi_escape "$COLOR_BOLD_YELLOW")"
      if [[ -n "$message_color_seq" ]]
      then
        message_display="${message_color_seq}${message_display}${color_reset}"
      fi

      if [[ -n "$include_mid" ]]
      then
        local mid_color_code
        mid_color_code="$(sms_mid_color "$mid")"

        if [[ -n "$mid_color_code" ]]
        then
          local mid_color_seq
          mid_color_seq="$(ansi_escape "$mid_color_code")"
          if [[ -n "$mid_color_seq" ]]
          then
            mid_display="${mid_color_seq}${mid_display}${color_reset}"
            id_display="${mid_color_seq}${id_display}${color_reset}"
          fi
        fi
      fi
    fi
  fi

  if [[ -n "$include_mid" ]]
  then
    printf '%s %s %s %s %s\n' "$mid_display" "$id_display" "$type_display" "$recipient_display" "$message_display"
  else
    printf '%s %s %s %s\n' "$id_display" "$type_display" "$recipient_display" "$message_display"
  fi
}

# List SMS messages respecting the selected output mode and scope.
sms_list_pretty() {
  local list_json ids id js sender text msg_type pdu line maxlen=80
  local empty_msg="*no messages*"
  if [[ -z $NO_COLOR && -z $CRON ]]
  then
    empty_msg="$(ansi_escape "$COLOR_BOLD_YELLOW")${empty_msg}$(ansi_escape "$COLOR_RESET")"
  fi

  # When listing for all modems, iterate them explicitly
  if [[ -n "$ALL_MODEMS" ]]
  then
    local mids mid had_any
    if ! mapfile -t mids < <(list_modem_ids_sorted)
    then
      echo_error "failed to list modems"
      return 1
    fi

    if (( ${#mids[@]} == 0 ))
    then
      if json_like_requested
      then
        printf '[]\n'
      else
        echo -e "$empty_msg"
      fi

      return 0
    fi

    if [[ -z "$MODEM_DETAILS_LOGGED" ]]
    then
      echo_debug "modems in scope:"
      for mid in "${mids[@]}"
      do
        [[ -z "$mid" ]] && continue
        log_modem_details "$mid"
      done
      MODEM_DETAILS_LOGGED=1
    fi

    if raw_json_requested
    then
        local raw_items
        raw_items="$(
          for mid in "${mids[@]}"
          do
            [[ -z "$mid" ]] && continue

            if ! list_json="$(mmcli --modem "$mid" --messaging-list-sms -J)"
            then
              continue
            fi

            mapfile -t ids < <(jq -r '."modem.messaging.sms"[]? | split("/")[-1]' <<<"$list_json")

            for id in "${ids[@]}"
            do
              [[ -z "$id" ]] && continue
              js="$(mmcli --modem "$mid" --sms "$id" -J)"

              if [[ -n "$js" ]]
              then
                jq -e -c --arg mid "$mid" '{modem_id: ($mid|tonumber), sms: .}' <<<"$js"
              fi
            done
          done
        )"
        if [[ -z "$raw_items" ]]
        then
          printf '[]\n'
        else
          printf '%s\n' "$raw_items" | jq -s '.'
        fi
        return 0
    elif raw_plain_requested
    then
        local first=1 out
        for mid in "${mids[@]}"
        do
          [[ -z "$mid" ]] && continue
          out="$(mmcli --modem "$mid" --messaging-list-sms 2>&1)"
          if [[ -z "$out" ]]
          then
            continue
          fi
          if (( ! first ))
          then
            printf '\n'
          fi
          first=0
          printf '%s' "$out"
          [[ "$out" == *$'\n' ]] || printf '\n'
        done
        return 0
    fi

    if custom_json_requested
    then
      local -a json_items=()
      local mid own info_json mid_from_info

      for mid in "${mids[@]}"
      do
        [[ -z "$mid" ]] && continue

        if ! list_json="$(mmcli --modem "$mid" --messaging-list-sms -J)"
        then
          continue
        fi

        mapfile -t ids < <(jq -r '."modem.messaging.sms"[]? | split("/")[-1]' <<<"$list_json")
        (( ${#ids[@]} == 0 )) && continue

        own=""
        if info_json="$(mmcli --modem "$mid" -J)"
        then
          own="$(jq -r '(.modem.generic["own-numbers"][0] // empty)' <<<"$info_json")"
          own=$(ensure_plus "$own")
          if [[ -n "$own" ]]
          then
            remember_modem_own_number "$mid" "$own"
            mid_from_info="$(modem_json_extract_id "$info_json")"
            if [[ -n "$mid_from_info" && "$mid_from_info" != "$mid" ]]
            then
              remember_modem_own_number "$mid_from_info" "$own"
            fi
          fi
        fi

        for id in "${ids[@]}"
        do
          [[ -z "$id" ]] && continue
          if ! js="$(mmcli --modem "$mid" --sms "$id" -J)"
          then
            continue
          fi
          pdu="$(jq -r '.sms.properties["pdu-type"] // ""' <<<"$js")"
          msg_type="$(pdu_to_type "$pdu")"
          local json_item
          json_item="$(jq -c \
            --arg mid "$mid" \
            --arg id "$id" \
            --arg type "$msg_type" \
            --arg own "$own" '
              {
                modem_id: ($mid|tonumber),
                id: ($id|tonumber),
                sender: (.sms.content.number // ""),
                text: (.sms.content.text // ""),
                class: (.sms.content.class // ""),
                state: (.sms.properties.state // ""),
                pdu: (.sms.properties["pdu-type"] // ""),
                storage: (.sms.properties.storage // ""),
                type: $type,
                recipient: (if $type == "received" then $own else (.sms.content.number // "") end)
              }
            ' <<<"$js")"
          if [[ -n "$json_item" && "$json_item" != "null" ]]
          then
            json_items+=("$json_item")
          fi
        done
      done

      if (( ${#json_items[@]} == 0 ))
      then
        printf '[]\n'
      else
        printf '%s\n' "${json_items[@]}" | jq -s '.'
      fi

      return 0
    fi

    # Pretty output across all modems: add a MID column
    sms_list_print_header --include-modem-id

    for mid in "${mids[@]}"
    do
      [[ -z "$mid" ]] && continue

      if ! list_json="$(mmcli --modem "$mid" --messaging-list-sms -J)"
      then
        continue
      fi

      mapfile -t ids < <(jq -r '."modem.messaging.sms"[]? | split("/")[-1]' <<<"$list_json")
      for id in "${ids[@]}"
      do
        [[ -z "$id" ]] && continue
        if ! js="$(mmcli --modem "$mid" --sms "$id" -J)"
        then
          continue
        fi
        sms_list_print_entry "$mid" "$id" "$js" --include-modem-id --max-length "$maxlen"
        had_any=1
      done
    done
    [[ -n "$had_any" ]] || echo -e "$empty_msg"
    return 0
  fi

  if raw_plain_requested
  then
    mmcli_cmd --messaging-list-sms
    return $?
  fi

  if ! list_json="$(mmcli_cmd --messaging-list-sms -J)"
  then
    echo_error "failed to list SMS messages"
    return 1
  fi

  mapfile -t ids < <(jq -r '."modem.messaging.sms"[]? | split("/")[-1]' <<<"$list_json")
  if (( ${#ids[@]} == 0 ))
  then
    if json_like_requested
    then
      printf '[]\n'
    else
      echo -e "$empty_msg"
    fi
    return 0
  fi

  if raw_json_requested
  then
    if ! jq <<<"$list_json"
    then
      return 1
    fi
    return 0
  fi

  if custom_json_requested
  then
    # Emit one compact JSON object per SMS, then wrap into an array
    # Determine our own number for recipient mapping of received messages
    local own
    own="$(query_modem_number)" || own=""
    {
      for id in "${ids[@]}"
      do
        [[ -z "$id" ]] && continue
        if ! js="$(mmcli_cmd --sms "$id" -J)"
        then
          continue
        fi
        pdu="$(jq -r '.sms.properties["pdu-type"] // ""' <<<"$js")"
        msg_type="$(pdu_to_type "$pdu")"
        jq -c --arg id "$id" --arg type "$msg_type" --arg own "$own" '
          {
            id: ($id|tonumber),
            sender: (.sms.content.number // ""),
            text: (.sms.content.text // ""),
            class: (.sms.content.class // ""),
            state: (.sms.properties.state // ""),
            pdu: (.sms.properties["pdu-type"] // ""),
            storage: (.sms.properties.storage // ""),
            type: $type,
            recipient: (if $type == "received" then $own else (.sms.content.number // "") end)
          }
        ' <<<"$js"
      done
    } | jq -s '.'
    return 0
  fi

  # Header for human-readable list (make entire line bold to preserve alignment)
  sms_list_print_header

  for id in "${ids[@]}"
  do
    [[ -z "$id" ]] && continue
    if ! js="$(mmcli_cmd --sms "$id" -J)"
    then
      continue
    fi
    sms_list_print_entry "" "$id" "$js" --max-length "$maxlen"
  done
}

# Resolve and enable a modem, optionally waiting for it to appear.
enable_modem() {
  local selector_input="${1:-}"
  local selector="$selector_input"
  local wait_enabled="${ENABLE_WAIT_MODEM:-}"
  local wait_timeout="${ENABLE_WAIT_TIMEOUT:-0}"
  local wait_timeout_default="$ENABLE_WAIT_TIMEOUT_DEFAULT"
  local sleep_period="$ENABLE_WAIT_SLEEP_INTERVAL"
  local service_wait_timeout=600
  local elapsed=0

  if [[ -z "$selector" ]]
  then
    selector="$MODEM"
  fi
  if [[ -z "$selector" ]]
  then
    selector="any"
  fi

  echo_info "waiting for D-Bus system socket"
  until [[ -S /var/run/dbus/system_bus_socket ]]
  do
    if (( elapsed >= service_wait_timeout ))
    then
      echo_warning "timeout waiting for D-Bus socket"
      return 1
    fi

    sleep "$sleep_period"
    elapsed=$((elapsed + sleep_period))
  done

  echo_info "waiting for ModemManager"
  elapsed=0
  until mmcli -L >/dev/null 2>&1
  do
    if (( elapsed >= service_wait_timeout ))
    then
      echo_warning "timeout waiting for ModemManager"
      return 1
    fi

    sleep "$sleep_period"
    elapsed=$((elapsed + sleep_period))
  done

  local detection_timeout=0
  if [[ -n "$wait_enabled" ]]
  then
    if [[ ! "$wait_timeout" =~ ^[0-9]+$ ]] || (( wait_timeout <= 0 ))
    then
      wait_timeout="$wait_timeout_default"
    fi
    detection_timeout="$wait_timeout"
  fi

  if [[ -n "$wait_enabled" ]]
  then
    echo_info "waiting for modem detection"
  else
    echo_info "checking for modem detection"
  fi

  local detection_elapsed=0
  local resolved_id
  local resolve_output
  local resolve_status=0
  local last_error
  local last_error_is_custom
  local selector_is_any
  local should_return

  if [[ "$selector" == "any" ]]
  then
    selector_is_any=1
  fi

  local -a any_ids=()
  while :
  do
    unset should_return

    if [[ -n "$selector_is_any" ]]
    then
      if mapfile -t any_ids < <(list_modem_ids_sorted)
      then
        if (( ${#any_ids[@]} > 0 ))
        then
          resolved_id="any"
          resolve_status=0
          break
        fi
        last_error="no modems detected"
        last_error_is_custom=1
        resolve_status=1
      else
        last_error="could not query modem list via mmcli"
        last_error_is_custom=1
        resolve_status=1
      fi
    else
      resolve_output="$(get_modem_id "$selector")"
      resolve_status=$?
      if (( resolve_status == 0 ))
      then
        resolved_id="$resolve_output"
        break
      fi
      last_error="$resolve_output"
      last_error_is_custom=""
    fi

    if (( resolve_status == 2 ))
    then
      should_return=1
    elif (( resolve_status != 0 )) && [[ -z "$wait_enabled" ]]
    then
      should_return=1
    fi

    if [[ -n $should_return ]]
    then
      if [[ -n "$last_error_is_custom" ]]
      then
        echo_error "$last_error"
      else
        [[ -n "$last_error" ]] && printf '%s\n' "$last_error" >&2
      fi
      return "$resolve_status"
    fi

    if (( detection_timeout > 0 )) && (( detection_elapsed >= detection_timeout ))
    then
      if [[ -n "$last_error_is_custom" ]]
      then
        echo_error "$last_error"
      else
        [[ -n "$last_error" ]] && printf '%s\n' "$last_error" >&2
      fi
      echo_warning "timeout waiting for modem detection of '$selector'"
      return 1
    fi

    sleep "$sleep_period"
    detection_elapsed=$((detection_elapsed + sleep_period))
  done

  if [[ -z "$resolved_id" ]]
  then
    echo_warning "failed to resolve modem selector '$selector'"
    return 1
  fi

  MODEM="$resolved_id"

  if [[ "$MODEM" == "any" ]]
  then
    local _j _id
    if _j="$(mmcli_cmd -J)"
    then
      _id="$(jq -r '.modem["dbus-path"] | split("/")[-1] // empty' <<<"$_j")"
      if [[ -n "$_id" ]]
      then
        MODEM="$_id"
      fi
    fi
  fi

  local enable_target="$MODEM"

  if [[ -z "$QUIET" ]]
  then
    local _info
    if _info="$(get_modem_info "$enable_target" "detected ")"
    then
      echo_info "$_info"
    else
      echo_info "resolved modem selector '$selector' to '$enable_target'"
    fi
    MODEM_DETAILS_LOGGED=1
  fi

  if mmcli_cmd --enable
  then
    echo_info "modem enabled"
    # Log enabled modem details similar to selection log
    if [[ -z $QUIET ]]
    then
      local _json _formatted
      if _json="$(get_modem "$enable_target")"
      then
        configure_modem_vendor "$_json"
        if _formatted="$(modem_info_string_from_json "$_json" "$enable_target")"
        then
          echo_info "enabled modem={$_formatted}"
        else
          echo_info "enabled modem={id='${enable_target}'}"
        fi
      else
        echo_info "enabled modem={id='${enable_target}'}"
      fi
    fi
    return 0
  fi

  echo_warning "failed to enable modem"
  return 1
}

# Enable each detected modem in sequence.
enable_all_modems() {
  local mids mid
  if ! mapfile -t mids < <(list_modem_ids_sorted)
  then
    echo_error "failed to list modems to enable"
    return 1
  fi
  if (( ${#mids[@]} == 0 ))
  then
    echo_info "no modems detected"
    return 0
  fi
  local ok_count=0
  local fail_ids=()
  for mid in "${mids[@]}"
  do
    [[ -z "$mid" ]] && continue
    echo_info "enabling modem $mid"
    if ! enable_modem "$mid"
    then
      echo_warning "failed to enable modem $mid"
      fail_ids+=("$mid")
    else
      ok_count=$((ok_count + 1))
    fi
  done
  if (( ${#fail_ids[@]} > 0 ))
  then
    echo_info "enabled $ok_count/${#mids[@]} modems (failed: ${fail_ids[*]})"
  else
    echo_info "enabled $ok_count/${#mids[@]} modems"
  fi
}

# Reset the current modem with optional service restarts and USB replugging.
modem_reset() {
  local service="/etc/init.d/modemmanager"
  local has_service

  if [[ -x "$service" ]]
  then
    has_service=1
  else
    echo_warning "modemmanager init script not found or not executable at $service"
  fi

  local info_json vendor
  if info_json="$(mmcli_cmd -J)"
  then
    if ! vendor="$(modem_vendor_from_info_json "$info_json")"
    then
      vendor=""
    fi
    echo_debug "modem_reset: detected vendor '${vendor:-unknown}'"
  else
    echo_warning "could not query modem to determine vendor; proceeding with generic reset"
  fi

  if [[ -n "$HARD_RESET" && -n "$has_service" ]]
  then
    reset_log "stopping ModemManager"
    if ! "$service" stop
    then
      echo_error "failed to stop ModemManager service"
      return 1
    fi
  fi

  reset_modem_vendor "$info_json" "$vendor"

  if [[ -n "$USB_REPLUG" ]]
  then
    if ! modem_usb_replug "$info_json"
    then
      echo_error "USB replug failed"
      return 1
    fi
  fi

  if [[ -n "$HARD_RESET" && -n "$has_service" ]]
  then
    reset_log "starting ModemManager"
    if ! "$service" start
    then
      echo_error "failed to start ModemManager service"
      return 1
    fi
  fi

  reset_log "enabling modem"
  local prev_wait_mode="${ENABLE_WAIT_MODEM:-}"
  local prev_wait_timeout="${ENABLE_WAIT_TIMEOUT:-}"
  ENABLE_WAIT_MODEM=1
  if [[ ! "$ENABLE_WAIT_TIMEOUT" =~ ^[0-9]+$ ]] || (( ENABLE_WAIT_TIMEOUT <= 0 ))
  then
    ENABLE_WAIT_TIMEOUT="$ENABLE_WAIT_TIMEOUT_DEFAULT"
  fi
  if ! enable_modem "$MODEM"
  then
    echo_warning "failed to enable modem after reset, retrying in 5s"
    sleep 5
    if ! enable_modem "$MODEM"
    then
      ENABLE_WAIT_MODEM="$prev_wait_mode"
      ENABLE_WAIT_TIMEOUT="$prev_wait_timeout"
      echo_error "failed to enable modem after reset"
      return 1
    fi
  fi
  ENABLE_WAIT_MODEM="$prev_wait_mode"
  ENABLE_WAIT_TIMEOUT="$prev_wait_timeout"

  return 0
}

# Reset every detected modem using modem_reset.
modem_reset_all() {
  local mids mid
  if ! mapfile -t mids < <(list_modem_ids_sorted)
  then
    echo_error "failed to list modems to reset"
    return 1
  fi
  if (( ${#mids[@]} == 0 ))
  then
    echo_info "no modems detected"
    return 0
  fi
  for mid in "${mids[@]}"
  do
    [[ -z "$mid" ]] && continue
    echo_info "resetting modem $mid"
    MODEM="$mid" modem_reset || echo_error "failed to reset modem $mid"
  done
}

# Log reset operations when not running in quiet mode.
reset_log() {
  if [[ -z $QUIET ]]
  then
    echo_info "$*"
  fi
}

# Clean up watcher resources and background processes.
watch_cleanup() {
  watch_stop_workers

  if [[ -n "$WATCH_DBUS_PID" ]]
  then
    if ! kill "$WATCH_DBUS_PID"
    then
      echo_warning "could not stop dbus-monitor (pid $WATCH_DBUS_PID)"
    fi
    WATCH_DBUS_PID=""
  fi

  if [[ -n "$WATCH_MODEM_MONITOR_PID" ]]
  then
    if ! kill "$WATCH_MODEM_MONITOR_PID"
    then
      echo_warning "could not stop modem monitor (pid $WATCH_MODEM_MONITOR_PID)"
    fi
    WATCH_MODEM_MONITOR_PID=""
  fi

  if [[ -n "$WATCH_FIFO" ]]
  then
    if ! rm -f "$WATCH_FIFO"
    then
      echo_warning "could not remove fifo $WATCH_FIFO"
    fi
    WATCH_FIFO=""
  fi
}

# Return the queue key used to group watcher workers per modem.
watch_queue_key() {
  local modem_hint="$1"

  if [[ -n "$modem_hint" ]]
  then
    printf '%s' "$modem_hint"
  else
    printf '%s' "any"
  fi
}

# Create or reuse the async work directory for watcher jobs.
watch_async_dir_prepare() {
  if [[ -n "$WATCH_ASYNC_DIR" && -d "$WATCH_ASYNC_DIR" ]]
  then
    printf '%s\n' "$WATCH_ASYNC_DIR"
    return 0
  fi

  local base="${TMPDIR:-/tmp}"
  local dir

  if dir="$(mktemp -d "$base/mmsms-watch.XXXXXX")"
  then
    :
  else
    dir="$base/mmsms-watch.$$"
    if ! mkdir -p "$dir"
    then
      echo_warning "watch: failed to create async directory in $base"
      return 1
    fi
  fi

  WATCH_ASYNC_DIR="$dir"
  printf '%s\n' "$WATCH_ASYNC_DIR"
  return 0
}

# Check if a PID still corresponds to a running non-zombie process.
watch_pid_alive() {
  local pid="$1"

  if [[ -z "$pid" ]]
  then
    return 1
  fi

  local status_file="/proc/$pid/status"
  if [[ ! -r "$status_file" ]]
  then
    return 1
  fi

  local line
  while IFS= read -r line
  do
    case "$line" in
      State:*)
        [[ "$line" == *"(zombie)"* ]] && return 1
        return 0
        ;;
    esac
  done <"$status_file"

  return 0
}

# Remove the filesystem lock held by a watcher worker.
watch_worker_release_lock() {
  local lock_path="$1"

  if [[ -z "$lock_path" ]]
  then
    return
  fi

  if [[ -d "$lock_path" ]]
  then
    if ! rmdir "$lock_path"
    then
      echo_warning "watch: failed to remove lock directory $lock_path"
    fi
  fi
}

# Track a newly spawned watcher worker PID for a modem queue.
watch_worker_register() {
  local modem_key="$1"
  local pid="$2"

  if [[ -z "$modem_key" || -z "$pid" ]]
  then
    return
  fi

  local existing
  existing="${WATCH_WORKER_PIDS[$modem_key]:-}"

  if [[ -n "$existing" ]]
  then
    WATCH_WORKER_PIDS["$modem_key"]="$existing $pid"
  else
    WATCH_WORKER_PIDS["$modem_key"]="$pid"
  fi
}

# Prune exited watcher workers for a given modem queue.
watch_worker_prune_for_modem() {
  local modem_key="$1"

  local pids
  pids="${WATCH_WORKER_PIDS[$modem_key]:-}"

  if [[ -z "$pids" ]]
  then
    return
  fi

  local -a alive=()
  local pid
  for pid in $pids
  do
    if watch_pid_alive "$pid"
    then
      alive+=("$pid")
    else
      wait "$pid"
    fi
  done

  if (( ${#alive[@]} > 0 ))
  then
    WATCH_WORKER_PIDS["$modem_key"]="${alive[*]}"
  else
    unset 'WATCH_WORKER_PIDS[$modem_key]'
  fi
}

# Prune exited watcher workers for all modem queues.
watch_worker_prune_all() {
  local modem_key

  for modem_key in "${!WATCH_WORKER_PIDS[@]}"
  do
    watch_worker_prune_for_modem "$modem_key"
  done
}

# Count active watcher workers for a modem queue.
watch_worker_pending_count() {
  local modem_key="$1"

  local pids
  pids="${WATCH_WORKER_PIDS[$modem_key]:-}"

  if [[ -z "$pids" ]]
  then
    printf '%s' '0'
    return
  fi

  local -a pid_list=()
  local IFS=' '
  read -ra pid_list <<< "$pids"

  printf '%s' "${#pid_list[@]}"
}

# Spawn an asynchronous worker to handle an incoming SMS.
watch_spawn_worker() {
  local id="$1"
  local modem_hint="$2"
  local modem_key="$3"

  local dir
  if ! dir="$(watch_async_dir_prepare)"
  then
    return 1
  fi

  local lock_path="$dir/modem-${modem_key}.lock"

  (
    while ! mkdir "$lock_path"
    do
      sleep "$WATCH_WORKER_LOCK_SLEEP"
    done

    # shellcheck disable=SC2064
    trap "watch_worker_release_lock '$lock_path'" EXIT INT TERM

    echo_debug "watch: worker $$ handling SMS $id for modem $modem_key"
    watch_handle_sms "$id" "$modem_hint"
    echo_debug "watch: worker $$ finished SMS $id for modem $modem_key"
  ) &
  local pid=$!

  watch_worker_register "$modem_key" "$pid"
  echo_debug "watch: started async SMS worker pid=$pid for modem $modem_key (id=$id)"

  return 0
}

# Queue an SMS for asynchronous handling, falling back to synchronous work when needed.
watch_enqueue_sms() {
  local id="$1"
  local modem_hint="$2"
  local modem_key
  modem_key="$(watch_queue_key "$modem_hint")"

  watch_worker_prune_for_modem "$modem_key"

  local pending
  pending="$(watch_worker_pending_count "$modem_key")"

  if (( pending >= WATCH_MAX_PENDING_PER_MODEM ))
  then
    echo_warning "watch: modem $modem_key pending workers at limit ($pending); processing SMS $id synchronously"
    watch_handle_sms "$id" "$modem_hint"
    return
  fi

  if watch_spawn_worker "$id" "$modem_hint" "$modem_key"
  then
    return
  fi

  echo_warning "watch: failed to start async worker for modem $modem_key; processing SMS $id synchronously"
  watch_handle_sms "$id" "$modem_hint"
}

# Terminate and reap all watcher worker processes.
watch_stop_workers() {
  watch_worker_prune_all

  local modem_key
  for modem_key in "${!WATCH_WORKER_PIDS[@]}"
  do
    local pids="${WATCH_WORKER_PIDS[$modem_key]}"
    local pid
    for pid in $pids
    do
      if watch_pid_alive "$pid"
      then
        if ! kill "$pid"
        then
          echo_warning "watch: failed to terminate worker pid=$pid for modem $modem_key"
        fi
      fi
    done
  done

  for modem_key in "${!WATCH_WORKER_PIDS[@]}"
  do
    local pids="${WATCH_WORKER_PIDS[$modem_key]}"
    local pid
    for pid in $pids
    do
      if ! wait "$pid"
      then
        echo_warning "watch: worker pid=$pid for modem $modem_key exited with error"
      fi
    done
    unset 'WATCH_WORKER_PIDS[$modem_key]'
  done

  if [[ -n "$WATCH_ASYNC_DIR" ]]
  then
    if [[ -d "$WATCH_ASYNC_DIR" ]]
    then
      if ! rm -rf "$WATCH_ASYNC_DIR"
      then
        echo_warning "watch: failed to remove async directory $WATCH_ASYNC_DIR"
      fi
    fi
    WATCH_ASYNC_DIR=""
  fi
}

# Continuously auto-enable modems while watch mode is active.
watch_enable_monitor_loop() {
  local target_modem="${1:-}"
  local enable_all="${2:-}"
  local interval="$WATCH_ENABLE_POLL_INTERVAL"

  declare -A enabled_modems=()
  local -a mids=()

  if mapfile -t mids < <(list_modem_ids_sorted)
  then
    local mid
    for mid in "${mids[@]}"
    do
      [[ -z "$mid" ]] && continue
      if [[ -n "$enable_all" ]]
      then
        enabled_modems["$mid"]=1
      elif [[ -n "$target_modem" && "$target_modem" != "any" && "$mid" == "$target_modem" ]]
      then
        enabled_modems["$mid"]=1
      fi
    done
  fi

  while :
  do
    mids=()
    if mapfile -t mids < <(list_modem_ids_sorted)
    then
      local mid
      for mid in "${mids[@]}"
      do
        [[ -z "$mid" ]] && continue
        if [[ -n "$enable_all" ]]
        then
          if [[ -z "${enabled_modems[$mid]:-}" ]]
          then
            echo_info "watch: auto-enabling modem $mid"
            if enable_modem "$mid"
            then
              enabled_modems["$mid"]=1
            else
              echo_warning "watch: failed to auto-enable modem $mid"
            fi
          fi
        else
          if [[ -z "$target_modem" || "$target_modem" == "any" ]]
          then
            if [[ -z "${enabled_modems[$mid]:-}" ]]
            then
              echo_info "watch: auto-enabling modem $mid"
              if enable_modem "$mid"
              then
                enabled_modems["$mid"]=1
                target_modem="$mid"
              else
                echo_warning "watch: failed to auto-enable modem $mid"
              fi
            fi
          elif [[ "$mid" == "$target_modem" ]]
          then
            if [[ -z "${enabled_modems[$mid]:-}" ]]
            then
              echo_info "watch: auto-enabling target modem $mid"
              if enable_modem "$mid"
              then
                enabled_modems["$mid"]=1
              else
                echo_warning "watch: failed to auto-enable target modem $mid"
              fi
            fi
          fi
        fi
      done

      local known mid_present present
      for known in "${!enabled_modems[@]}"
      do
        present=0
        for mid_present in "${mids[@]}"
        do
          if [[ "$mid_present" == "$known" ]]
          then
            present=1
            break
          fi
        done
        if (( present == 0 ))
        then
          unset 'enabled_modems[$known]'
        fi
      done
    fi

    sleep "$interval"
  done
}

# Start the background loop that auto-enables modems for watch mode.
watch_start_enable_monitor() {
  if [[ -z "$WATCH_ENABLE" ]]
  then
    return 0
  fi

  if [[ -n "$WATCH_MODEM_MONITOR_PID" ]]
  then
    return 0
  fi

  local target_modem="$MODEM"
  local enable_all="$ALL_MODEMS"

  watch_enable_monitor_loop "$target_modem" "$enable_all" &
  WATCH_MODEM_MONITOR_PID=$!
}

# Normalize a phone number to digits for whitelist comparisons.
watch_canon_number() {
  local n="${1:-}"
  n="${n//[^0-9]/}"
  printf '%s' "$n"
}

# Check whether a sender number is present in the whitelist.
watch_in_whitelist() {
  local original="${1:-}"

  local num
  num="$(watch_canon_number "$original")"
  if [[ -z "$num" ]]
  then
    echo_warning "watch: sender '${original}' not whitelisted (empty canonical number); whitelist='${SMS_WHITELIST[*]}'"
    return 1
  fi

  local allowed canon_allowed
  for allowed in "${SMS_WHITELIST[@]}"
  do
    canon_allowed="$(watch_canon_number "$allowed")"
    if [[ -n "$canon_allowed" && "$num" == "$canon_allowed" ]]
    then
echo_info "watch: sender '${original}' matched whitelist entry '${allowed}' (whitelist='${SMS_WHITELIST[*]}')"
      return 0
    fi
  done

  echo_warning "watch: sender '${original}' not in whitelist; whitelist='${SMS_WHITELIST[*]}'"
  return 1
}

# Send an SMS reply, optionally using fallback behavior.
watch_send_reply() {
  local to="$1"
  local msg="$2"
  # Log outgoing SMS (abbreviate text and escape newlines)
  local log_text
  log_text="$(abbrev_text_for_log "$msg")"
  local log_modem
  log_modem="$(modem_info_brief)"

  echo_info "sending reply with modem={$log_modem} recipient=$to text='$log_text'"
  if [[ -n "$FALLBACK" ]]
  then
    if ! sms_send_with_fallback "$to" "$msg"
    then
      echo_warning "failed to send reply to $to (including fallback)"
      return 1
    fi
    return 0
  fi

  if ! sms_send "$to" "$msg"
  then
    echo_warning "failed to send reply to $to"
    return 1
  fi
}

# Execute a shell command for watch automation with timeout handling.
watch_run_command() {
  local user_cmd="$1"
  local cmd="NO_COLOR=1 $1"
  local output status="exit" json now
  local rc=0

  if command -v timeout &>/dev/null
  then
    output="$(timeout -k "${WATCH_CMD_KILL_TIMEOUT}s" "${WATCH_CMD_TIMEOUT}s" bash -c "NO_COLOR=1 $cmd" 2>&1)"
    rc=$?
    if (( rc == 124 ))
    then
      status="timeout"
    elif (( rc >= 128 ))
    then
      status="killed"
    fi
  else
    output="$(bash -c "NO_COLOR=1 $cmd" 2>&1)"
    rc=$?
  fi

  output="${output%$'\n'}"
  if (( ${#output} > CMD_OUTPUT_MAX_LEN ))
  then
    output="${output:0:CMD_OUTPUT_MAX_LEN}\n…(truncated)…"
  fi

  now="$(date -Iseconds)"

  jq -cen \
    --arg cmd "$user_cmd" \
    --argjson rc "$rc" \
    --arg status "$status" \
    --arg date "$now" \
    --arg output "$output" \
    '{cmd:$cmd, rc:$rc, status:$status, date:$date, output:$output}'
}

# Determine the cache key for modem-specific values.
modem_cache_key() {
  local key="$1"

  if [[ -z "$key" ]]
  then
    key="$MODEM"
  fi

  if [[ -z "$key" ]]
  then
    key="any"
  fi

  printf '%s' "$key"
}

# Remember a modem's own number for future lookups.
remember_modem_own_number() {
  local key
  key="$(modem_cache_key "$1")"
  local number="$2"

  if [[ -z "$key" || -z "$number" ]]
  then
    return 0
  fi

  MODEM_OWN_NUMBER_CACHE["$key"]="$number"
}

# Remember a modem's SMSC number for future lookups.
remember_modem_smsc_number() {
  local key
  key="$(modem_cache_key "$1")"
  local smsc="$2"

  if [[ -z "$key" || -z "$smsc" ]]
  then
    return 0
  fi

  MODEM_SMSC_NUMBER_CACHE["$key"]="$smsc"
}

# Extract the modem id from a blob of mmcli JSON output.
modem_json_extract_id() {
  local json="$1"

  if [[ -z "$json" ]]
  then
    printf ''
    return 1
  fi

  jq -r '.modem["dbus-path"] | split("/")[-1] // empty' <<<"$json" 2>/dev/null
}

# Query the modem's own number and cache it per modem.
query_modem_number() {
  local target="${1:-$MODEM}"
  local key
  key="$(modem_cache_key "$target")"

  if [[ -v MODEM_OWN_NUMBER_CACHE["$key"] ]]
  then
    printf '%s' "${MODEM_OWN_NUMBER_CACHE[$key]}"
    return 0
  fi

  local json
  if ! json="$(MODEM="$target" mmcli_cmd -J)"
  then
    return 1
  fi

  local number
  number="$(jq -r '(.modem.generic["own-numbers"][0] // empty)' <<<"$json" 2>/dev/null)"
  number="$(ensure_plus "$number")"

  if [[ -z "$number" ]]
  then
    return 2
  fi

  local actual_id
  actual_id="$(modem_json_extract_id "$json")"

  remember_modem_own_number "$target" "$number"
  if [[ -n "$actual_id" && "$actual_id" != "$target" ]]
  then
    remember_modem_own_number "$actual_id" "$number"
  fi

  printf '%s' "$number"
  return 0
}

# Retrieve and cache the SMSC number using AT+CSCA?.
get_smsc_number() {
  local target="${1:-$MODEM}"
  local key
  key="$(modem_cache_key "$target")"

  if [[ -v MODEM_SMSC_NUMBER_CACHE["$key"] ]]
  then
    printf '%s' "${MODEM_SMSC_NUMBER_CACHE[$key]}"
    if [[ -n "${MODEM_SMSC_NUMBER_CACHE[$key]}" ]]
    then
      return 0
    fi
    return 2
  fi

  # Try to retrieve the network-configured SMSC via AT+CSCA?
  # If unavailable or unsupported, return empty (do not force SMSC).
  local resp smsc
  if ! resp="$(MODEM="$target" at_command 'AT+CSCA?')"
  then
    return 1
  fi

  if [[ -n "$resp" ]]
  then
    smsc="$(at_first_quoted_decoded "$resp")"
    smsc="$(ensure_plus "$smsc")"
  fi

  if [[ -z "$smsc" ]]
  then
    return 2
  fi

  remember_modem_smsc_number "$target" "$smsc"

  printf '%s' "$smsc"
  return 0
}

# Build a structured JSON object summarizing modem status details.
modem_status_details_json() {
  local js own smsc country_code country_label payload modem_id_from_json
  local fallback_modem="$MODEM"

  if ! js="$(mmcli_cmd -J)"
  then
    if [[ -z $QUIET ]]
    then
      echo_error "failed to query modem status"
    fi
    return 1
  fi

  modem_id_from_json="$(modem_json_extract_id "$js")"

  own="$(jq -r '.modem.generic["own-numbers"][0] // ""' <<<"$js")"
  own="$(ensure_plus "$own")"
  if [[ -n "$own" ]]
  then
    remember_modem_own_number "$fallback_modem" "$own"
    if [[ -n "$modem_id_from_json" && "$modem_id_from_json" != "$fallback_modem" ]]
    then
      remember_modem_own_number "$modem_id_from_json" "$own"
    fi
  fi

  smsc="$(get_smsc_number "$fallback_modem")" || smsc=""
  smsc="$(ensure_plus "$smsc")"
  if [[ -n "$smsc" ]]
  then
    remember_modem_smsc_number "$fallback_modem" "$smsc"
    if [[ -n "$modem_id_from_json" && "$modem_id_from_json" != "$fallback_modem" ]]
    then
      remember_modem_smsc_number "$modem_id_from_json" "$smsc"
    fi
  fi

  if [[ "$own" == +* ]]
  then
    country_code="$(phone_cc "$own")"
    if [[ "$country_code" == "--" || -z "$country_code" ]]
    then
      country_code=""
    else
      country_label="$(cc_to_label "$country_code")"
      if [[ "$country_label" == "--" ]]
      then
        country_label=""
      fi
    fi
  fi

  if ! payload="$(
    jq --arg own "$own" \
       --arg smsc "$smsc" \
       --arg fallback "$fallback_modem" \
       --arg cc "$country_code" \
       --arg country "$country_label" '
      def blank_to_null:
        if . == null or . == "" then null else . end;

      def normalize_port:
        if . == null or . == "" then null
        elif startswith("/") then .
        else "/dev/" + .
        end;

      def fallback_name($name; $sid):
        if $name != "" then $name
        elif $sid != "" then $sid
        else "" end;

      def fallback_code($code; $sid; $nid):
        if $code != "" then $code
        elif $nid != "" then $nid
        elif $sid != "" then $sid
        else "" end;

      (.modem.generic.ports // []) as $ports_raw
      | ($ports_raw
          | map(split(" ") | .[0])
          | map(normalize_port)
          | map(select(. != null))) as $ports
      | ($ports_raw
          | map(select(test("\\(at\\)"; "i")) | split(" ")[0] | normalize_port)
          | map(select(. != null))) as $at_candidates
      | (.modem["dbus-path"] // "") as $modem_path
      | ($modem_path | split("/")[-1]) as $mid_str
      | (.modem["3gpp"]["operator-name"] // "") as $carrier_name_raw
      | (.modem["3gpp"]["operator-code"] // "") as $carrier_code_raw
      | (.modem.cdma.sid // "") as $cdma_sid_raw
      | (.modem.cdma.nid // "") as $cdma_nid_raw
      | fallback_name($carrier_name_raw; $cdma_sid_raw) as $carrier_name
      | fallback_code($carrier_code_raw; $cdma_sid_raw; $cdma_nid_raw) as $carrier_code
      | {
          modem_id: ($mid_str | tonumber?),
          modem_label: (
            if ($mid_str // "") != "" then $mid_str
            elif ($fallback | test("^[0-9]+$")) then $fallback
            elif ($fallback | blank_to_null) then $fallback
            else "unknown" end
          ),
          state: (.modem.generic.state // null),
          power: (.modem.generic["power-state"] // null),
          registered: (.modem["3gpp"]["registration-state"] // null),
          signal: (.modem.generic["signal-quality"].value // null | tonumber?),
          carrier: (
            if $carrier_name != "" and $carrier_code != "" then
              if $carrier_name == $carrier_code then $carrier_name else $carrier_name + " (" + $carrier_code + ")" end
            elif $carrier_name != "" then $carrier_name
            elif $carrier_code != "" then $carrier_code
            else null end
          ),
          carrier_name: (if $carrier_name == "" then null else $carrier_name end),
          carrier_code: (if $carrier_code == "" then null else $carrier_code end),
          phone: ($own | blank_to_null),
          smsc: ($smsc | blank_to_null),
          manufacturer: ((.modem.generic.manufacturer // "") | blank_to_null),
          model: ((.modem.generic.model // "") | blank_to_null),
          plugin: ((.modem.generic.plugin // "") | blank_to_null),
          primary_port: ((.modem.generic["primary-port"] // "") | normalize_port),
          at_port: ($at_candidates[0] // null),
          ports: $ports,
          firmware: ((.modem.generic.revision // "") | blank_to_null),
          hardware_revision: ((.modem.generic["hardware-revision"] // "") | blank_to_null),
          equipment_id: ((.modem.generic["equipment-identifier"] // "") | blank_to_null),
          device: ((.modem.generic.device // "") | blank_to_null),
          device_identifier: ((.modem.generic["device-identifier"] // "") | blank_to_null),
          carrier_configuration: ((.modem.generic["carrier-configuration"] // "") | blank_to_null),
          carrier_configuration_revision: ((.modem.generic["carrier-configuration-revision"] // "") | blank_to_null),
          imei: ((.modem["3gpp"].imei // "") | blank_to_null),
          meid: ((.modem.cdma.meid // "") | blank_to_null),
          country_code: (if $cc == "" then null else ($cc | tonumber? // $cc) end),
          country: (if $country == "" then null else $country end)
        }
    ' <<<"$js"
  )"
  then
    return 1
  fi

  printf '%s\n' "$payload"
}

# Output status for the current modem in the requested format.
modem_status_single() {
  local payload raw


  if raw_plain_requested
  then
    mmcli_cmd
    return $?
  fi

  if raw_json_requested
  then
    if [[ -n "$ALL_MODEMS" ]]
    then
      local mids mid raw_items=()
      if mapfile -t mids < <(list_modem_ids_sorted)
      then
        for mid in "${mids[@]}"
        do
          [[ -z "$mid" ]] && continue
          if raw="$(MODEM="$mid" mmcli_cmd -J)"
          then
            raw_items+=("$raw")
          fi
        done
      fi
      if (( ${#raw_items[@]} == 0 ))
      then
        printf '[]\n'
      else
        printf '%s\n' "${raw_items[@]}" | jq -s '.'
      fi
    else
      mmcli_cmd -J | jq
    fi
    return 0
  fi

  if ! payload="$(modem_status_details_json)"
  then
    return 1

  fi

  if custom_json_requested
  then
    jq -e <<< "$payload"
    return "$?"
  fi

  local color_reset color_white color_cyan color_blue color_green color_yellow color_red color_magenta
  color_reset="$(ansi_escape "$COLOR_RESET")"
  color_white="$(ansi_escape "$COLOR_BOLD_WHITE")"
  color_cyan="$(ansi_escape "$COLOR_CYAN")"
  color_blue="$(ansi_escape "$COLOR_BOLD_BLUE")"
  color_green="$(ansi_escape "$COLOR_BOLD_GREEN")"
  color_yellow="$(ansi_escape "$COLOR_BOLD_YELLOW")"
  color_red="$(ansi_escape "$COLOR_BOLD_RED")"
  color_magenta="$(ansi_escape "$COLOR_BOLD_MAGENTA")"

  jq -r     --arg reset "$color_reset"     --arg white "$color_white"     --arg cyan "$color_cyan"     --arg blue "$color_blue"     --arg green "$color_green"     --arg yellow "$color_yellow"     --arg red "$color_red"     --arg magenta "$color_magenta" '
      def color($code; $text):
        if $code == "" then $text else $code + $text + $reset end;

      def value_or_dash($v):
        if $v == null or $v == "" then "--" else $v end;

      def split_lines($value):
        ($value // "--") | tostring | split("\n");

      def spaces($n):
        if $n <= 0 then ""
        else [range(0; $n) | " "] | add
        end;

      def format_label($label; $width):
        ($label // "") as $l
        | ($width - ($l | length)) as $pad
        | if $pad <= 0 then $l else $l + spaces($pad) end;

      def format_lines($label; $color; $lines; $width):
        if ($lines | length) == 0 then [""]
        else
          [format_label($label; $width) + "  " + color($color; $lines[0])]
          + ($lines[1:] | map(format_label(""; $width) + "  " + color($color; .)))
        end;


      def choose_state_color($state):
        if $state == null then $cyan
        else
          ($state | ascii_downcase) as $s
          | if ["connected","registered","enabled","online","on"] | index($s) then $green
            elif ["searching","initializing","connecting","locked","unknown"] | index($s) then $yellow
            elif ["failed","disabled","off"] | index($s) then $red
            else $cyan end
        end;

      def choose_power_color($power):
        if $power == null then $cyan
        else
          ($power | ascii_downcase) as $p
          | if ["on","full"] | index($p) then $green
            elif ["low"] | index($p) then $yellow
            elif ["off","unknown"] | index($p) then $red
            else $cyan end
        end;

      def choose_registration_color($reg):
        if $reg == null then $cyan
        else
          ($reg | ascii_downcase) as $r
          | if ["home","registered","attached"] | index($r) then $green
            elif ["roaming"] | index($r) then $magenta
            elif ["searching","idle","unknown"] | index($r) then $yellow
            elif ["denied","unregistered"] | index($r) then $red
            else $cyan end
        end;

      def choose_signal_color($value):
        if $value == null then $cyan
        elif $value >= 70 then $green
        elif $value >= 40 then $yellow
        else $red end;

      def join_ports($ports):
        if $ports == null or ($ports | length) == 0 then "--"
        else $ports | join(" ") end;

      def format_country($code; $label):
        if $code == null or $code == "" or $code == "null" then
          if $label == null or $label == "" then "--" else $label end
        else
          ($code | tostring) as $c
          | if $label == null or $label == "" then "+" + $c
            elif $label == $c then "+" + $c
            else $label + " (+" + $c + ")" end
        end;

      def add_row($rows; $label; $color; $value):
        $rows + [{label:$label, color:$color, value:$value}];

      def add_optional_row($rows; $label; $color; $value):
        if $value == null or $value == "" then $rows else add_row($rows; $label; $color; value_or_dash($value)) end;

      . as $m
      | ($m.modem_label // "unknown") as $modem_label
      | ($m.state // "unknown") as $state_label
      | ($m.power // "unknown") as $power_label
      | ($m.registered // "unknown") as $reg_label
      | ($m.signal // null) as $signal_value
      | (if $signal_value == null then "--" else ($signal_value | tostring) + "%" end) as $signal_display
      | ($m.carrier // null) as $carrier_display
      | ($m.phone // null) as $phone_display
      | ($m.smsc // null) as $smsc_display
      | ($m.firmware // null) as $firmware
      | ($m.hardware_revision // null) as $hardware
      | ($m.equipment_id // null) as $equipment
      | ($m.imei // null) as $imei
      | ($m.meid // null) as $meid
      | ($m.device_identifier // null) as $device_id
      | ($m.device // null) as $device
      | ($m.manufacturer // null) as $manufacturer
      | ($m.model // null) as $model
      | ($m.plugin // null) as $plugin
      | ($m.primary_port // null) as $primary_port
      | ($m.at_port // null) as $at_port
      | join_ports($m.ports) as $ports_display
      | ($m.carrier_configuration // null) as $carrier_config
      | ($m.carrier_configuration_revision // null) as $carrier_config_rev
      | (if $carrier_config != null and $carrier_config_rev != null then $carrier_config + " (" + $carrier_config_rev + ")"
         elif $carrier_config != null then $carrier_config
         elif $carrier_config_rev != null then $carrier_config_rev
         else null end) as $carrier_config_display
      | format_country($m.country_code; $m.country) as $country_display
      | (
          []
          | add_row(.; "Modem ID"; $white; value_or_dash($modem_label))
          | add_row(.; "State"; choose_state_color($m.state); value_or_dash($state_label))
          | add_row(.; "Power"; choose_power_color($m.power); value_or_dash($power_label))
          | add_row(.; "Registration"; choose_registration_color($m.registered); value_or_dash($reg_label))
          | add_row(.; "Signal"; choose_signal_color($signal_value); value_or_dash($signal_display))
          | add_row(.; "Carrier"; $blue; value_or_dash($carrier_display))
          | add_row(.; "Phone"; $blue; value_or_dash($phone_display))
          | add_row(.; "SMSC"; $blue; value_or_dash($smsc_display))
          | . + [null]
          | add_row(.; "Manufacturer"; $blue; value_or_dash($manufacturer))
          | add_row(.; "Model"; $blue; value_or_dash($model))
          | add_row(.; "Plugin"; $blue; value_or_dash($plugin))
          | add_row(.; "Primary Port"; $blue; value_or_dash($primary_port))
          | add_row(.; "AT Port"; $blue; value_or_dash($at_port))
          | add_row(.; "Ports"; $blue; value_or_dash($ports_display))
          | add_row(.; "Firmware"; $blue; value_or_dash($firmware))
          | add_row(.; "Hardware Rev"; $blue; value_or_dash($hardware))
          | add_row(.; "Equipment ID"; $blue; value_or_dash($equipment))
          | add_row(.; "IMEI"; $blue; value_or_dash($imei))
          | add_optional_row(.; "MEID"; $blue; $meid)
          | add_row(.; "Device ID"; $blue; value_or_dash($device_id))
          | add_row(.; "Device"; $blue; value_or_dash($device))
          | add_row(.; "Carrier Config"; $blue; value_or_dash($carrier_config_display))
          | add_row(.; "Country"; $blue; value_or_dash($country_display))
          | . + [null]
        ) as $rows
      | ($rows | map(select(. != null) | .label | length) | max // 0) as $width
      | $rows
      | map(
          if . == null then [""]
          else
            (.label // "") as $label
            | (.color // "") as $color
            | split_lines(.value) as $lines
            | format_lines($label; $color; $lines; $width)
          end
        )
      | (add // [])
      | .[]
    ' <<<"$payload"
}

# Display modem status for one or many modems respecting output flags.
modem_status() {
  local target_mid="${1:-}"

  if raw_plain_requested
  then
    if [[ -z "$target_mid" && -n "$ALL_MODEMS" ]]
    then
      local mids mid
      if ! mapfile -t mids < <(list_modem_ids_sorted)
      then
        echo_error "failed to list modems"
        return 1
      fi
      if (( ${#mids[@]} == 0 ))
      then
        echo_info "no modems detected"
        return 0
      fi

      local first=1
      for mid in "${mids[@]}"
      do
        [[ -z "$mid" ]] && continue
        if (( ! first ))
        then
          printf '\n'
        fi
        first=0
        MODEM="$mid" ALL_MODEMS="" modem_status_single
      done
      return 0
    fi

    modem_status_single
    return $?
  fi

  if [[ -z "$target_mid" && -n "$ALL_MODEMS" ]]
  then
    local mids mid
    if ! mapfile -t mids < <(list_modem_ids_sorted)
    then
      echo_error "failed to list modems"
      return 1
    fi
    if (( ${#mids[@]} == 0 ))
    then
      if json_like_requested
      then
        printf '[]\n'
      else
        echo_info "no modems detected"
      fi
      return 0
    fi

    if json_like_requested
    then
      local json_items=() item
      for mid in "${mids[@]}"
      do
        [[ -z "$mid" ]] && continue
        item="$(MODEM="$mid" ALL_MODEMS="" modem_status_single)"
        [[ -n "$item" ]] && json_items+=("$item")
      done
      if (( ${#json_items[@]} == 0 ))
      then
        printf '[]\n'
      else
        printf '%s\n' "${json_items[@]}" | jq -es '.'
      fi
      return 0
    fi

    local first=1
    for mid in "${mids[@]}"
    do
      [[ -z "$mid" ]] && continue
      (( first )) || printf '\n'
      first=0
      echo_debug "modem $mid:"
      MODEM="$mid" ALL_MODEMS="" modem_status_single
    done
    return 0
  fi

  modem_status_single
}

# Build a JSON object describing a modem-specific value and optional error.
modem_value_json_object() {
  local field="$1"
  local value="$2"
  local error_message="$3"
  local modem_id="$4"

  jq -cn \
    --arg field "$field" \
    --arg value "$value" \
    --arg error "$error_message" \
    --arg mid "$modem_id" '
      def blank_to_null($v):
        if $v == "" then null else $v end;
      def parse_modem($m):
        if $m == "" then null else ($m | tonumber? // $m) end;

      {modem_id: parse_modem($mid)}
      + {($field): blank_to_null($value)}
      + (if $error == "" then {} else {error: $error} end)
    '
}

# Print the modem's own phone number if available for the current modem.
modem_number_single() {
  local number
  if number="$(query_modem_number)"
  then
    if custom_json_requested
    then
      modem_value_json_object "number" "$number" "" "$MODEM"
    else
      printf '%s\n' "$number"
    fi
    return 0
  fi

  local rc=$?
  local error_message
  if (( rc == 1 ))
  then
    error_message="could not query modem for own number"
  else
    error_message="modem did not report own number"
  fi

  echo_error "$error_message"
  if custom_json_requested
  then
    modem_value_json_object "number" "" "$error_message" "$MODEM"
  fi
  return 1
}

# Print the modem's own phone number for one or all detected modems.
modem_number() {
  if [[ -z "$ALL_MODEMS" ]]
  then
    modem_number_single
    return "$?"
  fi

  local -a mids
  if ! mapfile -t mids < <(list_modem_ids_sorted)
  then
    echo_error "failed to list modems"
    return 1
  fi

  if (( ${#mids[@]} == 0 ))
  then
    if custom_json_requested
    then
      printf '[]\n'
    else
      echo_info "no modems detected"
    fi
    return 0
  fi

  local prev_modem="$MODEM"
  local prev_all="$ALL_MODEMS"
  local overall_rc=0
  local mid
  local number
  local rc
  local error_message
  local json_item
  local -a json_items=()

  for mid in "${mids[@]}"
  do
    [[ -z "$mid" ]] && continue
    MODEM="$mid"
    ALL_MODEMS=""
    if number="$(query_modem_number)"
    then
      if custom_json_requested
      then
        json_item="$(modem_value_json_object "number" "$number" "" "$mid")"
        if [[ -n "$json_item" ]]
        then
          json_items+=("$json_item")
        fi
      else
        printf 'modem %s: %s\n' "$mid" "$number"
      fi
      continue
    fi

    rc=$?
    number=""
    if (( rc == 1 ))
    then
      error_message="modem $mid: could not query own number"
    else
      error_message="modem $mid: modem did not report own number"
    fi

    echo_error "$error_message"
    if custom_json_requested
    then
      json_item="$(modem_value_json_object "number" "" "$error_message" "$mid")"
      if [[ -n "$json_item" ]]
      then
        json_items+=("$json_item")
      fi
    fi

    if (( rc > overall_rc ))
    then
      overall_rc="$rc"
    fi
  done

  MODEM="$prev_modem"
  ALL_MODEMS="$prev_all"

  if custom_json_requested
  then
    if (( ${#json_items[@]} == 0 ))
    then
      printf '[]\n'
    else
      printf '%s\n' "${json_items[@]}" | jq -s '.'
    fi
  fi

  return "$overall_rc"
}

# Print the modem's configured SMSC number for the current modem.
modem_smsc_single() {
  local smsc
  smsc="$(get_smsc_number "$MODEM")" || smsc=""

  if custom_json_requested
  then
    modem_value_json_object "smsc" "$smsc" "" "$MODEM"
  else
    printf '%s\n' "$smsc"
  fi
  return 0
}

# Print the modem's configured SMSC number for one or all detected modems.
modem_smsc() {
  if [[ -z "$ALL_MODEMS" ]]
  then
    modem_smsc_single
    return 0
  fi

  local -a mids
  if ! mapfile -t mids < <(list_modem_ids_sorted)
  then
    echo_error "failed to list modems"
    return 1
  fi

  if (( ${#mids[@]} == 0 ))
  then
    if custom_json_requested
    then
      printf '[]\n'
    else
      echo_info "no modems detected"
    fi
    return 0
  fi

  local prev_modem="$MODEM"
  local prev_all="$ALL_MODEMS"
  local mid
  local smsc
  local json_item
  local -a json_items=()

  for mid in "${mids[@]}"
  do
    [[ -z "$mid" ]] && continue
    MODEM="$mid"
    ALL_MODEMS=""
    if ! smsc="$(get_smsc_number "$mid")"
    then
      smsc=""
    fi

    if custom_json_requested
    then
      json_item="$(modem_value_json_object "smsc" "$smsc" "" "$mid")"
      if [[ -n "$json_item" ]]
      then
        json_items+=("$json_item")
      fi
    else
      if [[ -n "$smsc" ]]
      then
        printf 'modem %s: %s\n' "$mid" "$smsc"
      else
        printf 'modem %s:\n' "$mid"
      fi
    fi
  done

  MODEM="$prev_modem"
  ALL_MODEMS="$prev_all"

  if custom_json_requested
  then
    if (( ${#json_items[@]} == 0 ))
    then
      printf '[]\n'
    else
      printf '%s\n' "${json_items[@]}" | jq -s '.'
    fi
  fi

  return 0
}

# Display aggregated usage statistics from daily state files.
sms_usage_stats() {
  local dir
  if ! dir="$(sms_daily_limit_state_dir)"
  then
    echo_error "failed to access usage state directory"
    return 1
  fi

  local -a files=()
  local -a tokens=()

  if [[ -n "$ALL_MODEMS" ]]
  then
    local path
    shopt -s nullglob
    for path in "$dir"/sms-count-*.state
    do
      [[ -e "$path" ]] || continue
      local base
      base="${path##*/}"
      local token
      token="${base#sms-count-}"
      token="${token%.state}"
      tokens+=("$token")
      files+=("$path")
    done
    shopt -u nullglob
  else
    if ! sms_daily_limit_identity
    then
      echo_error "failed to determine modem identity for stats"
      return 1
    fi

    local token
    token="$SMS_DAILY_LIMIT_KEY"
    local file
    if ! file="$(sms_daily_limit_state_file "$token")"
    then
      echo_error "failed to resolve stats state file"
      return 1
    fi

    tokens+=("$token")
    files+=("$file")
  fi

  local stats_day="$STATS_DAY"
  local stats_dump="$STATS_DUMP"
  local stats_reset="$STATS_RESET"
  local include_history=0
  if [[ -n "$stats_day" || -n "$stats_dump" ]]
  then
    include_history=1
  fi

  if [[ -n "$stats_reset" ]]
  then
    local global_file=""
    if ! global_file="$(sms_daily_limit_state_file 'global')"
    then
      global_file=""
    fi
    local -a reset_targets=()
    declare -A seen_reset=()
    if [[ -n "$ALL_MODEMS" ]]
    then
      local path
      shopt -s nullglob
      for path in "$dir"/sms-count-*.state
      do
        [[ -e "$path" ]] || continue
        if [[ -z "${seen_reset[$path]:-}" ]]
        then
          reset_targets+=("$path")
          seen_reset["$path"]=1
        fi
      done
      shopt -u nullglob
    else
      local file
      for file in "${files[@]}"
      do
        if [[ -z "${seen_reset[$file]:-}" ]]
        then
          reset_targets+=("$file")
          seen_reset["$file"]=1
        fi
      done
      if [[ -n "$global_file" && -z "${seen_reset[$global_file]:-}" ]]
      then
        reset_targets+=("$global_file")
        seen_reset["$global_file"]=1
      fi
    fi

    local removed=0
    local reset_rc=0
    local reset_path
    for reset_path in "${reset_targets[@]}"
    do
      if [[ -e "$reset_path" ]]
      then
        if rm -f "$reset_path"
        then
          removed=$((removed + 1))
        else
          echo_warning "stats: failed to remove '$reset_path'"
          reset_rc=1
        fi
      fi
    done

    if custom_json_requested
    then
      jq -n --argjson removed "$removed" '{reset:true, removed:$removed}'
    else
      if (( removed == 0 ))
      then
        echo_info "no usage stats to reset"
      elif (( removed == 1 ))
      then
        echo_info "reset 1 usage stats file"
      else
        echo_info "reset ${removed} usage stats files"
      fi
    fi

    return "$reset_rc"
  fi

  if ! sms_daily_usage_refresh_global
  then
    echo_warning "daily usage: failed to refresh global stats before display"
  fi

  sms_daily_usage_fix_global_state

  if (( ${#files[@]} == 0 ))
  then
    if custom_json_requested
    then
      printf '[]\n'
    else
      if [[ -n "$stats_day" ]]
      then
        echo_info "no usage stats available for $stats_day"
      else
        echo_info "no usage stats available"
      fi
    fi
    return 0
  fi

  local -a entry_tokens=()
  local -a entry_scopes=()
  local -a entry_dates=()
  local -a entry_labels=()
  local -a entry_msisdns=()
  local -a entry_display_labels=()
  local -a entry_sent=()
  local -a entry_failed=()
  local -a entry_incoming=()
  declare -A line_incoming_totals=()

  local file_index
  local file
  local token
  local date
  local sent
  local failed
  local incoming
  local label
  local msisdn
  local scope
  local display_label
  local entry_index
  local history_json
  local history_lines
  local history_date
  local history_label
  local history_msisdn
  local history_sent
  local history_failed
  local history_incoming
  local aggregated

  for file_index in "${!files[@]}"
  do
    file="${files[$file_index]}"
    token="${tokens[$file_index]}"

    history_json="[]"
    if ! sms_daily_state_read \
      --file "$file" \
      --out-date-var date \
      --out-sent-var sent \
      --out-failed-var failed \
      --out-incoming-var incoming \
      --out-label-var label \
      --out-msisdn-var msisdn \
      --out-history-json-var history_json
    then
      continue
    fi

    if [[ ! "$sent" =~ ^-?[0-9]+$ ]]
    then
      sent=0
    fi
    if [[ ! "$failed" =~ ^-?[0-9]+$ ]]
    then
      failed=0
    fi
    if [[ ! "$incoming" =~ ^-?[0-9]+$ ]]
    then
      incoming=0
    fi

    scope="line"
    if [[ "$token" == "global" ]]
    then
      scope="global"
    fi

    display_label="$label"
    if [[ -z "$display_label" && -n "$msisdn" ]]
    then
      display_label="$msisdn"
    fi
    if [[ -z "$display_label" ]]
    then
      if [[ "$token" == msisdn:* ]]
      then
        display_label="${token#msisdn:}"
      else
        display_label="$token"
      fi
    fi

    if [[ -z "$stats_day" || "$date" == "$stats_day" ]]
    then
      entry_index=${#entry_tokens[@]}
      entry_tokens[entry_index]="$token"
      entry_scopes[entry_index]="$scope"
      entry_dates[entry_index]="$date"
      entry_labels[entry_index]="$label"
      entry_msisdns[entry_index]="$msisdn"
      entry_display_labels[entry_index]="$display_label"
      entry_sent[entry_index]="$sent"
      entry_failed[entry_index]="$failed"
      entry_incoming[entry_index]="$incoming"
    fi

    if (( include_history ))
    then
      local history_sep
      history_sep=$'\x1f'
      if history_lines="$(jq -r 'map([.date // "", .label // "", (if has("msisdn") then .msisdn elif has("msisdn_count") then (.msisdn_count | tostring) else "" end), ((.outgoing.sent // 0) | tostring), ((.outgoing.failed // 0) | tostring), ((.incoming.received // 0) | tostring)] | join("\u001f"))[]' <<<"$history_json" 2>/dev/null)"
      then
        if [[ -n "$history_lines" ]]
        then
          local history_line
          local history_fields
          while IFS= read -r history_line
          do
            if [[ -z "$history_line" ]]
            then
              continue
            fi

            printf -v history_fields '%s%s' "$history_line" "$history_sep"
            IFS=$'\x1f' read -r history_date history_label history_msisdn history_sent history_failed history_incoming <<<"$history_fields"

            if [[ -z "$history_date" ]]
            then
              continue
            fi

            if [[ ! "$history_sent" =~ ^-?[0-9]+$ ]]
            then
              history_sent=0
            fi
            if [[ ! "$history_failed" =~ ^-?[0-9]+$ ]]
            then
              history_failed=0
            fi
            if [[ ! "$history_incoming" =~ ^-?[0-9]+$ ]]
            then
              history_incoming=0
            fi

            if [[ -n "$stats_day" && "$history_date" != "$stats_day" ]]
            then
              continue
            fi

            display_label="$history_label"
            if [[ -z "$display_label" && -n "$history_msisdn" ]]
            then
              display_label="$history_msisdn"
            fi
            if [[ -z "$display_label" ]]
            then
              if [[ "$token" == msisdn:* ]]
              then
                display_label="${token#msisdn:}"
              else
                display_label="$token"
              fi
            fi

            entry_index=${#entry_tokens[@]}
            entry_tokens[entry_index]="$token"
            entry_scopes[entry_index]="$scope"
            entry_dates[entry_index]="$history_date"
            entry_labels[entry_index]="$history_label"
            entry_msisdns[entry_index]="$history_msisdn"
            entry_display_labels[entry_index]="$display_label"
            entry_sent[entry_index]="$history_sent"
            entry_failed[entry_index]="$history_failed"
            entry_incoming[entry_index]="$history_incoming"
          done <<<"$history_lines"
        fi
      fi
    fi
  done

  if (( ${#entry_tokens[@]} == 0 ))
  then
    if custom_json_requested
    then
      printf '[]\n'
    else
      if [[ -n "$stats_day" ]]
      then
        echo_info "no usage stats available for $stats_day"
      else
        echo_info "no usage stats available"
      fi
    fi
    return 0
  fi

  for entry_index in "${!entry_tokens[@]}"
  do
    scope="${entry_scopes[$entry_index]}"
    if [[ "$scope" == "global" ]]
    then
      continue
    fi
    incoming="${entry_incoming[$entry_index]}"
    if [[ ! "$incoming" =~ ^-?[0-9]+$ ]]
    then
      incoming=0
      entry_incoming[$entry_index]=0
    fi
    date="${entry_dates[$entry_index]}"
    if [[ -z "$date" ]]
    then
      continue
    fi
    aggregated="${line_incoming_totals[$date]:-0}"
    if [[ ! "$aggregated" =~ ^-?[0-9]+$ ]]
    then
      aggregated=0
    fi
    line_incoming_totals[$date]=$((aggregated + incoming))
  done

  for entry_index in "${!entry_tokens[@]}"
  do
    scope="${entry_scopes[$entry_index]}"
    if [[ "$scope" != "global" ]]
    then
      continue
    fi
    date="${entry_dates[$entry_index]}"
    if [[ -z "$date" ]]
    then
      continue
    fi
    incoming="${entry_incoming[$entry_index]}"
    if [[ ! "$incoming" =~ ^-?[0-9]+$ ]]
    then
      incoming=0
      entry_incoming[$entry_index]=0
    fi
    aggregated="${line_incoming_totals[$date]:-0}"
    if [[ ! "$aggregated" =~ ^-?[0-9]+$ ]]
    then
      aggregated=0
    fi
    if (( aggregated > incoming ))
    then
      entry_incoming[$entry_index]="$aggregated"
    fi
  done

  if custom_json_requested
  then
    local -a json_items=()
    local json_entry
    for entry_index in "${!entry_tokens[@]}"
    do
      token="${entry_tokens[$entry_index]}"
      scope="${entry_scopes[$entry_index]}"
      date="${entry_dates[$entry_index]}"
      label="${entry_labels[$entry_index]}"
      msisdn="${entry_msisdns[$entry_index]}"
      sent="${entry_sent[$entry_index]}"
      failed="${entry_failed[$entry_index]}"
      incoming="${entry_incoming[$entry_index]}"

      json_entry="$(jq -n \
        --arg token "$token" \
        --arg scope "$scope" \
        --arg date "$date" \
        --arg label "$label" \
        --arg msisdn "$msisdn" \
        --argjson sent "$sent" \
        --argjson failed "$failed" \
        --argjson incoming "$incoming" \
        '({token:$token, scope:$scope}
          + (if $date == "" then {date:null} else {date:$date} end)
          + (if $label != "" then {label:$label} else {} end)
          + (if $msisdn != "" then {msisdn:$msisdn} else {} end)
          + {outgoing:{sent:$sent, failed:$failed}, incoming:{received:$incoming}})')"
      if [[ -n "$json_entry" ]]
      then
        json_items+=("$json_entry")
      fi
    done

    if (( ${#json_items[@]} == 0 ))
    then
      printf '[]\n'
    elif (( ${#json_items[@]} == 1 )) && [[ -z "$ALL_MODEMS" ]]
    then
      printf '%s\n' "${json_items[0]}"
    else
      printf '%s\n' "${json_items[@]}" | jq -s '.'
    fi
  else
    local color_reset
    local color_blue
    local color_cyan
    local color_green
    local color_red
    local color_magenta
    local failed_color
    local failed_reset
    local date_display

    color_reset="$(ansi_escape "$COLOR_RESET")"
    color_blue="$(ansi_escape "$COLOR_BOLD_BLUE")"
    color_cyan="$(ansi_escape "$COLOR_CYAN")"
    color_green="$(ansi_escape "$COLOR_BOLD_GREEN")"
    color_red="$(ansi_escape "$COLOR_BOLD_RED")"
    color_magenta="$(ansi_escape "$COLOR_BOLD_MAGENTA")"

    for entry_index in "${!entry_tokens[@]}"
    do
      display_label="${entry_display_labels[$entry_index]}"
      scope="${entry_scopes[$entry_index]}"
      date="${entry_dates[$entry_index]}"
      sent="${entry_sent[$entry_index]}"
      failed="${entry_failed[$entry_index]}"
      incoming="${entry_incoming[$entry_index]}"

      if [[ -n "$date" ]]
      then
        date_display="$date"
      else
        date_display="--"
      fi

      failed_color=""
      failed_reset=""
      if (( failed > 0 ))
      then
        failed_color="$color_red"
        failed_reset="$color_reset"
      fi

      printf 'Stats for %s%s%s (scope=%s%s%s, date=%s%s%s)\n' \
        "$color_blue" "$display_label" "$color_reset" \
        "$color_magenta" "$scope" "$color_reset" \
        "$color_cyan" "$date_display" "$color_reset"
      printf '  outgoing sent: %s%s%s\n' "$color_green" "$sent" "$color_reset"
      printf '  outgoing failed: %s%s%s\n' "$failed_color" "$failed" "$failed_reset"
      printf '  incoming received: %s%s%s\n' "$color_blue" "$incoming" "$color_reset"

      if (( entry_index + 1 < ${#entry_tokens[@]} ))
      then
        printf '\n'
      fi
    done
  fi

  return 0
}

# Process an incoming SMS by validating, forwarding, or executing commands.
watch_handle_sms() {
  local id="$1"
  local prefer_modem_id="${2:-}"
  # Ensure replies and operations use the modem that received the message
  # by shadowing MODEM locally for mmcli_cmd invocations.
  # shellcheck disable=SC2031
  local MODEM="$MODEM"
  local modem_hint_label
  local modem_effective
  local self_number
  if [[ -n "$prefer_modem_id" ]]
  then
    MODEM="$prefer_modem_id"
    modem_hint_label="$prefer_modem_id"
  else
    echo_warning "no modem hint for SMS $id; defaulting to any"
    MODEM="any"
    modem_hint_label="--"
  fi
  modem_effective="$MODEM"
  echo_debug "watch: processing SMS $id (hint=$modem_hint_label effective=$modem_effective)"
  local tries=0
  local js state pdu sender text payload modem_id_from_sms

  self_number="$(query_modem_number "$MODEM")" || self_number=""

  while :
  do
    if ! js="$(mmcli_cmd --sms "$id" -J)"
    then
      echo_warning "watch: failed to read SMS $id details via mmcli"
      return
    fi

    state="$(jq -r '.sms.properties.state // empty' <<<"$js")"
    pdu="$(jq -r '.sms.properties."pdu-type" // empty' <<<"$js")"
    sender="$(jq -r '.sms.content.number // empty' <<<"$js")"
    text="$(jq -r '.sms.content.text // empty' <<<"$js")"

    if [[ "$state" != "received" && "$pdu" != "deliver" ]]
    then
      echo_info "ignore id=$id (state=$state pdu=$pdu)"
      return
    fi

    if [[ -n "$self_number" && "$sender" == "$self_number" ]]
    then
      echo_info "skip self-sent id=$id"
      return
    fi

    if [[ -z "$text" && $tries -lt $SMS_RETRY_COUNT ]]
    then
      tries=$((tries + 1))
      sleep "$WATCH_RETRY_SLEEP"
      continue
    fi

    # Determine recipient (SIM MSISDN) for the modem that received the SMS
    # Prefer querying the current modem directly to avoid cross-modem mixups.
    local recipient
    local om_json
    if om_json="$(mmcli_cmd -J)"
    then
      recipient="$(jq -r '.modem.generic["own-numbers"][0] // empty' <<<"$om_json")"
      recipient="$(ensure_plus "$recipient")"
      if [[ -n "$recipient" ]]
      then
        remember_modem_own_number "$MODEM" "$recipient"
        modem_id_from_sms="$(modem_json_extract_id "$om_json")"
        if [[ -n "$modem_id_from_sms" && "$modem_id_from_sms" != "$MODEM" ]]
        then
          remember_modem_own_number "$modem_id_from_sms" "$recipient"
        fi
        if [[ -z "$self_number" ]]
        then
          self_number="$recipient"
        fi
      fi
    fi

    local log_text
    log_text="$(abbrev_text_for_log "$text")"
    local log_recipient="$recipient"
    if [[ -z "$log_recipient" ]]
    then
      log_recipient="--"
    fi
    local sender_cc
    sender_cc="$(phone_cc_label "$sender")"
    echo_info "received message={id='$id' sender='$sender' (cc='$sender_cc') recipient='$log_recipient' text='$log_text'}"

    sms_daily_usage_record_incoming "$recipient"

    local sender_whitelisted
    if watch_in_whitelist "$sender"
    then
      sender_whitelisted=1
    fi

    local is_command=0
    if [[ "$text" == "!"* ]]
    then
      is_command=1
      if [[ -n $sender_whitelisted ]]
      then
        local cmd="${text#!}"
        # remove leading ws
        cmd=$(sed -E 's/^[[:space:]]+//' <<< "$cmd")

        if [[ -z "$cmd" ]]
        then
          watch_send_reply "$sender" "ERR: empty command"
        else
          echo_info "executing command from $sender: $cmd"
          local cmd_result rc status output cmd_header
          cmd_result="$(watch_run_command "$cmd")"
          rc="$(jq -r '.rc' <<<"$cmd_result")"
          status="$(jq -r '.status' <<<"$cmd_result")"
          output="$(jq -r '.output' <<<"$cmd_result")"
          cmd_header="$(jq -cr '{cmd, rc, status, date}' <<<"$cmd_result")"
          echo_info "command from $sender finished rc=$rc status=$status"
          # Before sending our reply, prune already-sent messages on this modem
          sms_prune_sent || echo_warning "failed to prune sent SMS before reply"
          watch_send_reply "$sender" "${cmd_header}\n${output:-*no output*}"
        fi

      else
        echo_info "command from $sender ignored (not whitelisted)"
      fi
    fi

    local ignore_json
    if (( is_command == 1 ))
    then
      ignore_json=true
    else
      ignore_json=false
    fi

    payload="$(jq -n \
      --arg recipient "$recipient" \
      --arg sender "$sender" \
      --arg text "$text" \
      --arg date "$(date -Iseconds)" \
      --argjson ignore "$ignore_json" \
      '{recipient:$recipient, sender:$sender, text:$text, date: $date, ignore: $ignore}')"
    echo_info "forwarding id=$id from $sender to webhook"
    local resp rc code body log_body
    resp="$(curl -sS -m 10 -H 'Content-Type: application/json' -w $'\n%{http_code}' \
      -X POST -d "$payload" "$WEBHOOK_URL" 2>&1)"
    rc=$?
    if (( rc != 0 ))
    then
      log_body="$(abbrev_text_for_log "$resp")"
      echo_warning "webhook delivery error rc='$rc' output='$log_body'"
    else
      code="${resp##*$'\n'}"
      body="${resp%$'\n'*}"

      if [[ "$code" =~ ^[0-9]{3}$ ]]
      then
        log_body="$(abbrev_text_for_log "$body")"
      else
        code="n/a"
        log_body="$(abbrev_text_for_log "$resp")"
      fi

      if [[ "$code" =~ ^2 ]]
      then
        echo_info "webhook response code='$code' body='$log_body'"
      else
        echo_warning "webhook response code='$code' body='$log_body'"
      fi
    fi

    if (( WATCH_DELETE_AFTER == 1 ))
    then
      if ! mmcli_cmd --messaging-delete-sms="$id" >/dev/null
      then
        echo_warning "failed to delete processed SMS $id"
      else
        echo_info "deleted processed SMS $id"
      fi
    fi
    return
  done
}

# Monitor D-Bus for new SMS events and dispatch handlers.
watch_messages() {
  export PATH="/usr/local/bin:/srv/bin:$PATH"
  trap watch_cleanup EXIT INT TERM
  trap watch_worker_prune_all CHLD

  WATCH_FIFO="${TMPDIR:-/tmp}/smsbus.$$"
  mkfifo "$WATCH_FIFO"

  local filter="type='signal',interface='org.freedesktop.ModemManager1.Modem.Messaging',member='Added'"
  dbus-monitor --system "$filter" >"$WATCH_FIFO" &
  WATCH_DBUS_PID=$!

  local watch_own_number
  if watch_own_number="$(query_modem_number)"
  then
    if [[ -n "$watch_own_number" ]]
    then
      echo_info "own number = $watch_own_number"
    fi
  else
    local load_rc=$?
    if (( load_rc == 1 ))
    then
      echo_warning "could not query modem for own number"
    else
      echo_warning "modem did not report own number"
    fi
  fi

  if [[ -n "$WATCH_PRUNE" ]]
  then
    if ! sms_prune_all_modems
    then
      echo_warning "failed to prune existing SMS messages on all modems"
    fi
  fi

  if [[ -n "$WATCH_ENABLE" ]]
  then
    if [[ -n "$ALL_MODEMS" ]]
    then
      enable_all_modems || echo_warning "failed to enable all modems"
    else
      enable_modem "$MODEM" || echo_warning "failed to enable modem"
    fi
    watch_start_enable_monitor
  fi

  local current_modem_id
  while IFS= read -r line
  do
    # Track the modem id from the signal's path
    if [[ "$line" =~ /org/freedesktop/ModemManager1/Modem/([0-9]+) ]]
    then
      current_modem_id="${BASH_REMATCH[1]}"
    fi

    if [[ "$line" == *"/org/freedesktop/ModemManager1/SMS/"* ]]
    then
      local local_path="${line#*\"}"
      local_path="${local_path%%\"*}"
      local id="${local_path##*/}"
      if [[ "$id" =~ ^[0-9]+$ ]]
      then
        # If not listening on all, ignore messages from other modems
        if [[ -z "$ALL_MODEMS" && -n "$current_modem_id" && "$current_modem_id" != "$MODEM" ]]
        then
          echo_warning "ignoring SMS $id from modem $current_modem_id (listening on $MODEM)"
          continue
        fi
        watch_enqueue_sms "$id" "$current_modem_id"
      fi
    fi
  done <"$WATCH_FIFO"
}

# Decide whether a command needs MODEM resolved ahead of time.
command_requires_modem_resolution() {
  local cmd="$1"

  case "$cmd" in
    logs|service|pull)
      return 1
      ;;
  esac

  return 0
}

# Resolve MODEM to a concrete modem id and log the selection context.
resolve_modem_selection() {
  local cmd="$1"
  local defer_resolution

  if [[ "$cmd" == "enable" && -n "$ENABLE_WAIT_MODEM" && -z "$ALL_MODEMS" ]]
  then
    defer_resolution=1
  fi

  if [[ -n "$DEFAULT_MODEM" ]]
  then
    echo_debug "default modem configured: $DEFAULT_MODEM"
  fi

  if [[ -z "$ALL_MODEMS" && -z "$MODEM_EXPLICIT" && -n "$DEFAULT_MODEM" ]]
  then
    MODEM="$DEFAULT_MODEM"
    echo_debug "using default modem $MODEM"
  fi

  if [[ -n "$defer_resolution" ]]
  then
    echo_debug "deferring modem resolution for enable command (--wait active)"
    return 0
  fi

  local resolved
  if ! resolved="$(get_modem_id "$MODEM")"
  then
    # get_modem_id already printed context and list
    return 2
  fi

  MODEM="$resolved"

  if [[ "$MODEM" == "any" ]]
  then
    local _j _id
    if _j="$(mmcli_cmd -J)"
    then
      _id="$(jq -r '.modem["dbus-path"] | split("/")[-1] // empty' <<<"$_j")"
      if [[ -n "$_id" ]]
      then
        MODEM="$_id"
      fi
    fi
  fi

  if [[ -n $QUIET ]]
  then
    [[ -n $MODEM ]]
    return "$?"
  fi

  if [[ "$cmd" == "watch" && -n "$ALL_MODEMS" ]]
  then
    local _ids=()
    local _id
    if mapfile -t _ids < <(list_modem_ids_sorted)
    then
      echo_info "listening on all modems: ${#_ids[@]} detected"
      for _id in "${_ids[@]}"
      do
        [[ -z "$_id" ]] && continue
        log_modem_details "$_id"
      done
      MODEM_DETAILS_LOGGED=1
    else
      echo_info "listening on all modems"
    fi
    return 0
  fi

  if [[ -n "$ALL_MODEMS" ]]
  then
    local _ids=()
    if mapfile -t _ids < <(list_modem_ids_sorted)
    then
      if (( ${#_ids[@]} > 0 ))
      then
        echo_debug "operating on all modems: ${#_ids[@]} detected"

        local _id
        for _id in "${_ids[@]}"
        do
          [[ -z "$_id" ]] && continue
          log_modem_details "$_id"
        done
        MODEM_DETAILS_LOGGED=1
      else
        echo_warning "operating on all modems: none detected"
      fi
    else
      echo_debug "operating on all modems"
    fi
  elif [[ -n "$MODEM" && "$MODEM" != "any" ]]
  then
    local _info
    if _info="$(get_modem_info "$MODEM" "selected ")"
    then
      echo_debug "$_info"
    else
      echo_debug "selected modem={id='$MODEM'}"
    fi
  else
    local _info
    if _info="$(get_modem_info "$MODEM" "selected ")"
    then
      echo_debug "$_info"
    elif [[ "$MODEM" != "any" && -n "$MODEM" ]]
    then
      echo_debug "selected modem={id='$MODEM'}"
    else
      echo_debug "selected modem: any"
    fi
  fi

  return 0
}

# Parse CLI arguments, resolve configuration, and dispatch the requested command.
main() {
  local command
  local -a PRE_ARGS=()
  local -a ARGS=()
  local -a DEBUG_FLAGS=()

  while (( $# > 0 ))
  do
    case "$1" in
      -m|--modem)
        if (( $# < 2 ))
        then
          echo_error "missing value for $1"
          return 2
        fi
        DEBUG_FLAGS+=("$1=$2")
        MODEM="$2"
        MODEM_EXPLICIT=1
        shift 2
        continue
        ;;
      -d|--debug)
        DEBUG_FLAGS+=("$1")
        # shellcheck disable=SC2034
        DEBUG=1
        shift
        continue
        ;;
      -q|--quiet|--silent)
        DEBUG_FLAGS+=("$1")
        QUIET=1
        shift
        continue
        ;;
      -x|--trace)
        DEBUG_FLAGS+=("$1")
        PS4='+ [${BASH_SOURCE##*/}:${LINENO}] ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
        set -x
        shift
        continue
        ;;
      -s|--syslog)
        DEBUG_FLAGS+=("$1")
        # shellcheck disable=SC2034
        ECHO_SYSLOG=1
        shift
        continue
        ;;
      -c|--config)
        if (( $# < 2 ))
        then
          echo_error "missing value for $1"
          return 2
        fi
        DEBUG_FLAGS+=("$1=$2")
        CONFIG_FILE="$2"
        shift 2
        continue
        ;;
      --skip-modem-init)
        if (( $# < 2 ))
        then
          echo_error "missing value for $1"
          return 2
        fi
        DEBUG_FLAGS+=("$1=$2")
        add_skip_modem_init_pattern "$2"
        shift 2
        continue
        ;;
      --skip-modem-init=*)
        local pattern
        pattern="${1#*=}"
        if [[ -z "$pattern" ]]
        then
          echo_error "missing value for --skip-modem-init"
          return 2
        fi
        DEBUG_FLAGS+=("--skip-modem-init=$pattern")
        add_skip_modem_init_pattern "$pattern"
        shift
        continue
        ;;
      -h|--help)
        usage
        return 0
        ;;
      --)
        shift
        break
        ;;
      *)
        if [[ -z "$command" ]] && is_command_token "$1"
        then
          command="$1"
          shift
          break
        fi
        PRE_ARGS+=("$1")
        shift
        ;;
    esac
  done

  if [[ -z "$command" && $# -gt 0 ]]
  then
    command="$1"
    shift
  fi

  ARGS=("${PRE_ARGS[@]}")
  if (( $# > 0 ))
  then
    ARGS+=("$@")
  fi

  if [[ -z "$command" ]]
  then
    command="status"
  fi

  case "$command" in
    at|ati)
      command="at"
      ;;
    send|s)
      command="send"
      ;;
    list|ls|l|-l)
      command="list"
      ;;
    log*)
      command="logs"
      ;;
    raw|mmcli)
      command="mmcli"
      ;;
    read|get|r)
      command="read"
      ;;
    prune|clear|delete)
      command="prune"
      ;;
    -e|*enable*|en|start)
      command="enable"
      ;;
    status|stat|st)
      command="status"
      ;;
    number|phone)
      command="number"
      ;;
    reset|rst)
      command="reset"
      ;;
    service|svc)
      command="service"
      ;;
    watch|w)
      command="watch"
      ;;
    smsc)
      command="smsc"
      ;;
    help)
      local topic="${ARGS[0]:-}"
      if [[ -z "$topic" ]]
      then
        usage
      else
        case "$topic" in
          at|ati) topic="at" ;;
          en|enable|start) topic="enable" ;;
          log*) topic="logs" ;;
          l|ls|list) topic="list" ;;
          mmcli|raw) topic="mmcli" ;;
          number|phone) topic="number" ;;
          rst|reset|restart) topic="reset" ;;
          r|get|read) topic="read" ;;
          service|svc) topic="service" ;;
          smsc) topic="smsc" ;;
          st|stat|status) topic="status" ;;
          s|send) topic="send" ;;
          w|watch) topic="watch" ;;
        esac

        print_subcommand_usage "$topic"
      fi
      return 0
      ;;
  esac

  if [[ "$command" == -* ]]
  then
    echo_error "unknown option: $command"
    usage >&2
    return 2
  fi

  parse_command_args "$command" "${ARGS[@]}"
  local parse_rc=$?
  if (( parse_rc == 64 ))
  then
    return 0
  elif (( parse_rc != 0 ))
  then
    return $parse_rc
  fi

  local -a CMD_ARGS=("${PARSED_ARGS[@]}")

  if ! load_config post-args
  then
    return $?
  fi

  if [[ "$command" == "watch" && -n "$WATCH_DELETE_AFTER_CLI_OVERRIDE" ]]
  then
    WATCH_DELETE_AFTER=1
  fi

  if [[ -n "$RAW_OUTPUT_FORCED" ]]
  then
    RAW_OUTPUT=1
  fi
  if [[ -n "$JSON_OUTPUT_FORCED" ]]
  then
    JSON_OUTPUT=1
  fi

  if command_requires_modem_resolution "$command"
  then
    local resolve_rc
    resolve_modem_selection "$command"
    resolve_rc=$?
    if (( resolve_rc != 0 ))
    then
      return "$resolve_rc"
    fi
  fi

  local dbg_args dbg_flags
  if (( ${#DEBUG_FLAGS[@]} > 0 ))
  then
    local dbg_flags_str
    printf -v dbg_flags_str '%q ' "${DEBUG_FLAGS[@]}"
    dbg_flags=" flags=${dbg_flags_str%% }"
  fi
  if (( ${#CMD_ARGS[@]} > 0 ))
  then
    local dbg_args_str
    printf -v dbg_args_str '%q ' "${CMD_ARGS[@]}"
    dbg_args=" args=${dbg_args_str%% }"
  fi
  echo_debug "command=$command${dbg_flags}${dbg_args}"

  case "$command" in
    at)
      if [[ -n ${CMD_ARGS[0]} ]]
      then
        at_command "${CMD_ARGS[@]}"
      else
        at_command_interactive
      fi
      ;;
    send)
      if [[ -n "$FALLBACK" ]]
      then
        if ! sms_send_with_fallback "${CMD_ARGS[@]}"
        then
          return 1
        fi
      else
        if ! sms_send "${CMD_ARGS[@]}"
        then
          echo_warning "send failed. fallback disabled, not trying other modems"
          return 1
        fi
      fi
      ;;
    list)
      sms_list_pretty
      ;;
    logs)
      mmsms_logread "${CMD_ARGS[@]}"
      ;;
    mmcli)
      if ! mmcli_passthrough "${CMD_ARGS[@]}"
      then
        return $?
      fi
      ;;
    read)
      if (( ${#CMD_ARGS[@]} < 1 ))
      then
        echo_error "No SMS ID/path specified"
        # Show the message list in the same pretty/JSON/raw style
        sms_list_pretty || echo_error "failed to list SMS messages"
        return 2
      fi
        if raw_json_requested
        then
          mmcli_cmd --sms "${CMD_ARGS[0]}" -J | jq -e
        elif raw_plain_requested
        then
          sms_read_raw "${CMD_ARGS[@]}"
        elif custom_json_requested
        then
          sms_read_json "${CMD_ARGS[0]}"
        else
          sms_read_pretty "${CMD_ARGS[0]}"
        fi
      ;;
    service)
      if (( ${#CMD_ARGS[@]} > 0 )) && [[ "${CMD_ARGS[0]}" == "debug" ]]
      then
        mmsms_service_debug "${CMD_ARGS[@]:1}"
      else
        mmsms_service_action "${CMD_ARGS[@]}"
      fi
      ;;
    pull)
      if (( ${#CMD_ARGS[@]} > 0 ))
      then
        echo_error "pull does not accept additional arguments"
        return 2
      fi
      if ! mmsms_repo_pull
      then
        return 1
      fi
      ;;
    prune)
      if [[ -n "$SENT_ONLY" && -n "$ALL_MODEMS" ]]
      then
        sms_prune_sent_modems
      elif [[ -n "$SENT_ONLY" ]]
      then
        sms_prune_sent
      elif [[ -n "$ALL_MODEMS" ]]
      then
        sms_prune_all_modems
      else
        sms_prune_all
      fi
      ;;
    enable)
      if [[ -n "$ALL_MODEMS" ]]
      then
        enable_all_modems
      else
        enable_modem "$MODEM"
      fi
      ;;
    status)
      modem_status "${CMD_ARGS[@]}"
      ;;
    number)
      modem_number
      ;;
    smsc)
      modem_smsc
      ;;
    stats)
      sms_usage_stats
      ;;
    reset)
      if [[ -n "$ALL_MODEMS" ]]
      then
        modem_reset_all
      else
        modem_reset
      fi
      ;;
    watch)
      # Config already sourced earlier; ensure whitelist is populated
      if (( ${#SMS_WHITELIST[@]} == 0 ))
      then
        echo_error "watch requires at least one whitelisted number (SMS_WHITELIST)"
        return 2
      fi
      watch_messages
      ;;
    *)
      echo_error "unknown command: $command"
      usage >&2
      return 2
      ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "$0" ]]
then
  main "$@"
fi
