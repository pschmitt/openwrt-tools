#!/usr/bin/env bash

SCRIPT_NAME="$(basename "${BASH_SOURCE[0]}")"

cd "$(dirname "$(readlink -f "$0")")" || return 9

# shellcheck source=lib/echo.sh
source lib/echo.sh || exit 2

CONFIG_FILE="${CONFIG_FILE:-/etc/mmsms.conf}"

MODEM="${MODEM:-any}"
ALL_MODEMS="${ALL_MODEMS:-}"
DEFAULT_MODEM="${DEFAULT_MODEM:-}"

OWN_NUMBER="${OWN_NUMBER:-}"
SMSC_NUMBER="${SMSC_NUMBER:-}"

SMS_SEND_TIMEOUT="${SMS_SEND_TIMEOUT:-30}"
SMS_RETRY_COUNT="${SMS_RETRY_COUNT:-${SMS_SEND_RETRY_COUNT:-${MAX_RETRY:-3}}}"
CMD_OUTPUT_MAX_LEN="${CMD_OUTPUT_MAX_LEN:-4000}"

AT_FALLBACK_MAX_READS="${AT_FALLBACK_MAX_READS:-25}"
AT_FALLBACK_READ_TIMEOUT="${AT_FALLBACK_READ_TIMEOUT:-0.2}"

AT_WAIT_TIMEOUT_DEFAULT="${AT_WAIT_TIMEOUT_DEFAULT:-60}"
AT_WAIT_SLEEP_INTERVAL="${AT_WAIT_SLEEP_INTERVAL:-2}"
AT_WAIT_MODEM="${AT_WAIT_MODEM:-}"
AT_WAIT_TIMEOUT="${AT_WAIT_TIMEOUT:-0}"

WEBHOOK_URL="${WEBHOOK_URL:-}"

WATCH_DELETE_AFTER="${DELETE_AFTER:-1}"
WATCH_RETRY_SLEEP="${RETRY_SLEEP:-1}"
WATCH_CMD_TIMEOUT="${CMD_TIMEOUT:-8}"
WATCH_CMD_KILL_TIMEOUT="${WATCH_CMD_KILL_TIMEOUT:-${CMD_KILL_TIMEOUT:-20}}"
WATCH_ENABLE="${WATCH_ENABLE:-}"
WATCH_ENABLE_POLL_INTERVAL="${WATCH_ENABLE_POLL_INTERVAL:-5}"
WATCH_PRUNE="${WATCH_PRUNE:-}"

QUIET="${QUIET:-}"
JSON_OUTPUT="${JSON_OUTPUT:-}"
RAW_OUTPUT="${RAW_OUTPUT:-}"
HARD_RESET="${HARD_RESET:-}"
USB_REPLUG="${USB_REPLUG:-}"
SENT_ONLY="${SENT_ONLY:-}"
ALLOW_FOREIGN="${ALLOW_FOREIGN:-}"
HOME_CC="${HOME_CC:-}"
FALLBACK="${FALLBACK:-}"
AUTO_RECIPIENT="${AUTO_RECIPIENT:-}"

PARSED_ARGS=()
PARSE_SHIFT=0

MODEM_EXPLICIT=""
LOG_ABBREV_LEN="${LOG_ABBREV_LEN:-80}"

load_config() {
  echo_debug "loading config: $CONFIG_FILE"

  # shellcheck disable=SC1090
  if ! source "$CONFIG_FILE"
  then
    echo_warning "failed to load config: $CONFIG_FILE"
    return 1
  fi
}

# Ensure SMS_WHITELIST is defined as an array if provided by the config
if ! declare -p SMS_WHITELIST &>/dev/null
then
  SMS_WHITELIST=()
fi

# Allow overriding the whitelist via SMS_WHITELIST_OVERRIDE (comma or space separated digits)
if [[ -n "${SMS_WHITELIST_OVERRIDE:-}" ]]
then
  # shellcheck disable=SC2206
  SMS_WHITELIST=( ${SMS_WHITELIST_OVERRIDE//,/ } )
elif (( ${#SMS_WHITELIST[@]} == 0 )) && \
     declare -p SMS_WHITELIST_DEFAULT &>/dev/null
then
  SMS_WHITELIST=("${SMS_WHITELIST_DEFAULT[@]}")
fi

WATCH_FIFO=""
WATCH_DBUS_PID=""
WATCH_MODEM_MONITOR_PID=""
WATCH_CMD_RC=0
MODEM_DETAILS_LOGGED=""

# DIRTYFIX OpenWrt's jq is not compiled with ONIGURUMA
jq() {
  if [[ -x /srv/bin/jq ]]
  then
    /srv/bin/jq "$@"
    return $?
  fi

  command jq "$@"
}

usage() {
  cat <<USAGE
Usage: $SCRIPT_NAME [OPTIONS] COMMAND [ARGS]

Options:
  -A, --auto            Fallback: if foreign blocked, use modem's default recipient
  -a, --all             List/Prune/Enable/Reset: operate on all modems
  -c, --config PATH     Use alternate config file for watch
  -d, --debug           Enable debug output
  -F, --fallback        Send/Watch: on failure, try other modem(s)
  -f, --allow-foreign   Send: allow sending to foreign country codes
  -H, --hard            Reset: also stop/start modemmanager (hard reset)
      --replug         Reset: temporarily deauthorize the modem's USB device via sysfs
  -j, --json            Output JSON (for list/status/read)
  -m, --modem MODEM     Modem selector or id (default: $MODEM)
                        Accepts id (e.g. 2), dbus path, 'any', or
                        a string matching manufacturer/plugin/ttyUSB/phone-number
                        or country (fr/de/us) or country name (france/germany/us)
  -q, --quiet           Suppress info output (warnings/errors only) and status output (exit code only)
      --silent          Same as --quiet
  -r, --raw             List: output array of raw mmcli SMS objects; Read: raw mmcli JSON; Status: raw mmcli JSON
  -R, --retry COUNT     Set SMS send retry attempts (default: ${SMS_RETRY_COUNT})
  -s, --syslog          Mirror logs to syslog (in addition to stderr)
  -S, --sent            Prune: delete only sent outgoing messages
  -x, --trace           Enable shell tracing (set -x)
  -h, --help            Show this help and exit

Commands:
  at [AT_COMMAND]            Issue AT command to modem (interactive if no COMMAND)
  enable                     Wait for ModemManager and enable the modem
  list                       List SMS messages on the modem
  logs [LOGREAD_ARGS]        Show log entries from logread
  number|phone               Print modem's own phone number
  prune                      Delete all SMS messages from the modem
  read MESSAGE_ID            Show details for a specific SMS
  restart                    Restart modemmanager, issue vendor reset, re-enable modem
  send RECIPIENT [TEXT|-]    Send SMS; use '-' or stdin for TEXT
  service [ACTION]           Control the ${SCRIPT_NAME} service (start|stop|restart|status)
  smsc                       Print modem's configured SMSC number
  status                     Show modem status summary
  watch                      Monitor incoming SMS and forward/execute actions
USAGE
}

# Subcommand-specific usage helpers (concise, focused on per-command flags)
usage_at() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] at [OPTIONS] [COMMAND]

Issue and AT command to the modem's AT port. If COMMAND is omitted, enters interactive mode.

Relevant flags:
  -w, --wait[=SECONDS]  Wait for the modem AT port before running the command.
                        Defaults to ${AT_WAIT_TIMEOUT_DEFAULT}s when no value is provided.
                        Use 0 to wait indefinitely.
USAGE
}

# Subcommand-specific usage helpers (concise, focused on per-command flags)
usage_send() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] send [RECIPIENT] TEXT|-

Sends an SMS. If RECIPIENT is omitted, uses DEFAULT_RECIPIENT_XX/CC/DEFAULT.

Relevant flags:
  -A, --auto, --auto-recipient  When fallback, use modem defaults if original blocked
  -c, --config PATH    Load config for defaults (only needed outside 'watch')
  -F, --fallback       Try other modems on failure (sorted by id)
  -f, --allow-foreign Allow sending outside the modem's home country code
  -R, --retry COUNT    Override SMS resend attempts
USAGE
}

usage_list() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] list [-a|--all] [-j|--json] [-r|--raw]

Lists SMS messages. Pretty by default; --json prints structured JSON; --raw prints raw mmcli JSON.

Relevant flags:
  -a, --all    Include messages from all modems
  -j, --json   Output custom JSON array
  -r, --raw    Output raw mmcli objects array
USAGE
}

usage_logs() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] logs [LOGREAD_ARGS]

Prints $SCRIPT_NAME-related log entries from logread (if available). Extra args passed to logread.
USAGE
}

usage_read() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] read MESSAGE_ID [-j|--json] [-r|--raw]

Reads a single SMS. --json outputs compact structured JSON; --raw outputs mmcli JSON.
USAGE
}

usage_prune() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] prune [-a|--all] [-S|--sent]

Deletes messages. By default deletes all on the selected modem.

Relevant flags:
  -a, --all    Operate on all modems
  -S, --sent   Delete only sent (outgoing, state=sent) messages
USAGE
}

usage_enable() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] enable [-a|--all]

Enables the selected modem and waits for readiness.

Relevant flags:
  -a, --all    Enable all detected modems
USAGE
}

usage_service() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] service start|stop|restart|status"

Control the $SCRIPT_NAME service.
USAGE
}

usage_status() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] status [-a|--all] [-j|--json] [-r|--raw]

Shows modem status. --json outputs structured JSON. (Default command)

Relevant flags:
  -a, --all    Include all detected modems
  -j, --json   Output structured JSON
  -r, --raw    Output raw mmcli JSON
USAGE
}

usage_reset() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] reset [-a|--all] [-H|--hard] [--replug]

Resets the selected modem. Issues vendor-specific resets when supported.

Relevant flags:
  -a, --all    Reset all detected modems
  -H, --hard   Stop/start ModemManager around reset
      --replug Temporarily deauthorize/reauthorize the modem's USB device
USAGE
}

usage_watch() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] watch [-A|--auto-recipient] [-a|--all] [-c|--config PATH] [-E|--enable] [-F|--fallback] [-f|--allow-foreign] [-P|--prune] [-R|--retry COUNT]

Watches incoming SMS and executes reply/webhook logic.

Relevant flags:
  -A, --auto, --auto-recipient  When fallback, use modem defaults if original blocked
  -a, --all           Process messages from all modems (default: selected modem only)
  -c, --config PATH   Config file with defaults and whitelist
  -E, --enable        Enable selected modem(s) when starting watch; keep enabling new modems with --all
  -F, --fallback      When replying, try other modems on failure (sorted by id)
  -f, --allow-foreign Allow replies to recipients outside the modem's home CC
  -P, --prune         Delete existing SMS on startup before watching
  -R, --retry COUNT   Override SMS resend attempts
USAGE
}

usage_number() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] number|phone

Prints the modem's own number (MSISDN) if reported.
USAGE
}

usage_smsc() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] smsc

Prints the modem\'s configured SMSC (service center) number when available.
USAGE
}

print_subcommand_usage() {
  case "$1" in
    at)      usage_at      ;;
    send)    usage_send    ;;
    list)    usage_list    ;;
    logs)    usage_logs    ;;
    read)    usage_read    ;;
    prune)   usage_prune   ;;
    enable)  usage_enable  ;;
    status)  usage_status  ;;
    reset)   usage_reset   ;;
    service) usage_service ;;
    watch)   usage_watch   ;;
    number)  usage_number  ;;
    smsc)    usage_smsc    ;;
    *)       usage         ;;
  esac
}

is_command_token() {
  local token="$1"

  case "$token" in
    at|ati|send|s|list|ls|l|-l|logs|log*|read|get|r|prune|clear|delete|-e|*enable*|en|start|status|stat|st|number|phone|reset|rst|restart|service|svc|watch|w|smsc|help)
      return 0
      ;;
  esac

  return 1
}

parse_common_option() {
  PARSE_SHIFT=0
  local opt="$1"
  local value="${2:-}"

  case "$opt" in
    -m|--modem)
      if [[ -z "$value" ]]
      then
        echo_error "missing value for $opt"
        return 2
      fi
      DEBUG_FLAGS+=("${opt}=$value")
      MODEM="$value"
      MODEM_EXPLICIT=1
      PARSE_SHIFT=2
      return 0
      ;;
    -d|--debug)
      DEBUG_FLAGS+=("$opt")
      # shellcheck disable=SC2034
      DEBUG=1
      PARSE_SHIFT=1
      return 0
      ;;
    -q|--quiet|--silent)
      DEBUG_FLAGS+=("$opt")
      QUIET=1
      PARSE_SHIFT=1
      return 0
      ;;
    -x|--trace)
      DEBUG_FLAGS+=("$opt")
      PS4='+ [${BASH_SOURCE##*/}:${LINENO}] ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
      set -x
      PARSE_SHIFT=1
      return 0
      ;;
    -s|--syslog)
      DEBUG_FLAGS+=("$opt")
      # shellcheck disable=SC2034
      ECHO_SYSLOG=1
      PARSE_SHIFT=1
      return 0
      ;;
    -c|--config)
      if [[ -z "$value" ]]
      then
        echo_error "missing value for $opt"
        return 2
      fi
      DEBUG_FLAGS+=("${opt}=$value")
      CONFIG_FILE="$value"
      PARSE_SHIFT=2
      return 0
      ;;
  esac

  PARSE_SHIFT=0
  return 1
}

parse_at_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage at
        PARSED_ARGS=()
        return 64
        ;;
      -w|--wait)
        AT_WAIT_MODEM=1
        if [[ ! "$AT_WAIT_TIMEOUT" =~ ^[0-9]+$ ]] || (( AT_WAIT_TIMEOUT <= 0 ))
        then
          AT_WAIT_TIMEOUT="$AT_WAIT_TIMEOUT_DEFAULT"
        fi
        shift
        if [[ -n "${1:-}" && "${1:-}" =~ ^[0-9]+$ ]]
        then
          AT_WAIT_TIMEOUT="$1"
          shift
        fi
        continue
        ;;
      -w=*|--wait=*)
        local wait_value
        wait_value="${1#*=}"
        if [[ -z "$wait_value" ]]
        then
          echo_error "missing value for --wait"
          return 2
        fi
        if [[ ! "$wait_value" =~ ^[0-9]+$ ]]
        then
          echo_error "invalid value for --wait: '$wait_value' (expected integer seconds)"
          return 2
        fi
        AT_WAIT_MODEM=1
        AT_WAIT_TIMEOUT="$wait_value"
        shift
        continue
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

parse_send_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage send
        PARSED_ARGS=()
        return 64
        ;;
      -A|--auto|--auto-recipient)
        DEBUG_FLAGS+=("$1")
        AUTO_RECIPIENT=1
        shift
        continue
        ;;
      -F|--fallback)
        DEBUG_FLAGS+=("$1")
        FALLBACK=1
        shift
        continue
        ;;
      -f|--allow-foreign)
        DEBUG_FLAGS+=("$1")
        ALLOW_FOREIGN=1
        shift
        continue
        ;;
      -R|--retry)
        if (( $# < 2 ))
        then
          echo_error "missing value for $1"
          return 2
        fi
        if [[ ! "$2" =~ ^[0-9]+$ ]]
        then
          echo_error "--retry requires a non-negative integer"
          return 2
        fi
        DEBUG_FLAGS+=("$1=$2")
        SMS_RETRY_COUNT="$2"
        shift 2
        continue
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

parse_list_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage list
        PARSED_ARGS=()
        return 64
        ;;
      -a|--all)
        DEBUG_FLAGS+=("$1")
        ALL_MODEMS=1
        shift
        continue
        ;;
      -j|--json)
        DEBUG_FLAGS+=("$1")
        JSON_OUTPUT=1
        shift
        continue
        ;;
      -r|--raw)
        DEBUG_FLAGS+=("$1")
        RAW_OUTPUT=1
        shift
        continue
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

parse_logs_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage logs
        PARSED_ARGS=()
        return 64
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

parse_read_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage read
        PARSED_ARGS=()
        return 64
        ;;
      -j|--json)
        DEBUG_FLAGS+=("$1")
        JSON_OUTPUT=1
        shift
        continue
        ;;
      -r|--raw)
        DEBUG_FLAGS+=("$1")
        RAW_OUTPUT=1
        shift
        continue
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

parse_prune_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage prune
        PARSED_ARGS=()
        return 64
        ;;
      -a|--all)
        DEBUG_FLAGS+=("$1")
        ALL_MODEMS=1
        shift
        continue
        ;;
      -S|--sent)
        DEBUG_FLAGS+=("$1")
        SENT_ONLY=1
        shift
        continue
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

parse_enable_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage enable
        PARSED_ARGS=()
        return 64
        ;;
      -a|--all)
        DEBUG_FLAGS+=("$1")
        ALL_MODEMS=1
        shift
        continue
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

parse_service_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage service
        PARSED_ARGS=()
        return 64
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

parse_status_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage status
        PARSED_ARGS=()
        return 64
        ;;
      -a|--all)
        DEBUG_FLAGS+=("$1")
        ALL_MODEMS=1
        shift
        continue
        ;;
      -j|--json)
        DEBUG_FLAGS+=("$1")
        JSON_OUTPUT=1
        RAW_OUTPUT=""
        shift
        continue
        ;;
      -r|--raw)
        DEBUG_FLAGS+=("$1")
        RAW_OUTPUT=1
        JSON_OUTPUT=""
        shift
        continue
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

parse_reset_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage reset
        PARSED_ARGS=()
        return 64
        ;;
      -a|--all)
        DEBUG_FLAGS+=("$1")
        ALL_MODEMS=1
        shift
        continue
        ;;
      -H|--hard)
        DEBUG_FLAGS+=("$1")
        HARD_RESET=1
        shift
        continue
        ;;
      --replug)
        DEBUG_FLAGS+=("$1")
        USB_REPLUG=1
        shift
        continue
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

parse_watch_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage watch
        PARSED_ARGS=()
        return 64
        ;;
      -A|--auto|--auto-recipient)
        DEBUG_FLAGS+=("$1")
        AUTO_RECIPIENT=1
        shift
        continue
        ;;
      -a|--all)
        DEBUG_FLAGS+=("$1")
        ALL_MODEMS=1
        shift
        continue
        ;;
      -E|--enable)
        DEBUG_FLAGS+=("$1")
        WATCH_ENABLE=1
        shift
        continue
        ;;
      -F|--fallback)
        DEBUG_FLAGS+=("$1")
        FALLBACK=1
        shift
        continue
        ;;
      -f|--allow-foreign)
        DEBUG_FLAGS+=("$1")
        ALLOW_FOREIGN=1
        shift
        continue
        ;;
      -P|--prune)
        DEBUG_FLAGS+=("$1")
        WATCH_PRUNE=1
        shift
        continue
        ;;
      -R|--retry)
        if (( $# < 2 ))
        then
          echo_error "missing value for $1"
          return 2
        fi
        if [[ ! "$2" =~ ^[0-9]+$ ]]
        then
          echo_error "--retry requires a non-negative integer"
          return 2
        fi
        DEBUG_FLAGS+=("$1=$2")
        SMS_RETRY_COUNT="$2"
        shift 2
        continue
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

parse_number_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage number
        PARSED_ARGS=()
        return 64
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

parse_smsc_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage smsc
        PARSED_ARGS=()
        return 64
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

parse_command_args() {
  local command="$1"
  shift || true

  case "$command" in
    at)
      parse_at_args "$@"
      return $?
      ;;
    send)
      parse_send_args "$@"
      return $?
      ;;
    list)
      parse_list_args "$@"
      return $?
      ;;
    logs)
      parse_logs_args "$@"
      return $?
      ;;
    read)
      parse_read_args "$@"
      return $?
      ;;
    prune)
      parse_prune_args "$@"
      return $?
      ;;
    enable)
      parse_enable_args "$@"
      return $?
      ;;
    service)
      parse_service_args "$@"
      return $?
      ;;
    status)
      parse_status_args "$@"
      return $?
      ;;
    reset)
      parse_reset_args "$@"
      return $?
      ;;
    watch)
      parse_watch_args "$@"
      return $?
      ;;
    number)
      parse_number_args "$@"
      return $?
      ;;
    smsc)
      parse_smsc_args "$@"
      return $?
      ;;
    *)
      PARSED_ARGS=("$@")
      return 0
      ;;
  esac
}

# Map selector to a country calling code (digits) for a small set
# Supports: fr (France=33), de (Germany=49), us/usa (United States=1)
country_to_cc() {
  local s="${1,,}"

  case "$s" in
    fr|fra|france)
      printf '33'
      ;;
    de|deu|germany|deutschland)
      printf '49'
      ;;
    us|usa|"united states"|"united-states"|america)
      printf '1'
      ;;
    *)
      return 1
      ;;
  esac
}

# Determine the home country code for E.164 numbers
# Priority:
#  - HOME_CC if set (digits only, e.g., 49)
#  - Derive from OWN_NUMBER (heuristic: +1 -> 1, otherwise first two digits)
get_home_cc() {
  local target_mid="${1:-}"
  local cc=""
  if [[ -n "$HOME_CC" ]]
  then
    cc="${HOME_CC//[^0-9]/}"
    printf '%s' "$cc"
    return 0
  fi

  # Prefer using load_own_number to respect current MODEM context
  local own=""
  if [[ -n "$target_mid" ]]
  then
    if MODEM="$target_mid" load_own_number
    then
      own="$OWN_NUMBER"
    fi
  elif load_own_number
  then
    own="$OWN_NUMBER"
  fi

  if [[ -z "$own" ]]
  then
    # Fallback to direct mmcli parsing
    local j

    if [[ -n "$target_mid" ]]
    then
      j="$(mmcli -m "$target_mid" -J)"
    else
      j="$(mmcli_cmd -J)"
    fi

    if [[ -n "$j" ]]
    then
      own="$(jq -r '.modem.generic["own-numbers"][0] // empty' <<<"$j")"
    fi
  fi

  if [[ "$own" == +* ]]
  then
    local digits="${own#+}"
    if [[ "$digits" == 1* ]]
    then
      cc="1"
    else
      cc="${digits:0:2}"
    fi
    printf '%s' "$cc"
    return 0
  fi

  return 1
}

# Return a concise modem info string for logs: id=.. manufacturer=.. model=.. plugin=.. primary=..
modem_info_brief() {
  local j info id manufacturer model plugin primary own ports cc=""

  if j="$(mmcli_cmd -J)"
  then
    id="$(jq -r '.modem["dbus-path"] | split("/")[-1] // empty' <<<"$j")"
    manufacturer="$(jq -r '.modem.generic.manufacturer // "--"' <<<"$j")"
    model="$(jq -r '.modem.generic.model // "--"' <<<"$j")"
    plugin="$(jq -r '.modem.generic.plugin // "--"' <<<"$j")"
    primary="$(jq -r '.modem.generic["primary-port"] // "--"' <<<"$j")"
    ports="$(jq -r '(.modem.generic.ports // []) | map(split(" ")[0]) | join(",")' <<<"$j")"
    own="$(jq -r '.modem.generic["own-numbers"][0] // empty' <<<"$j")"
    own="$(ensure_plus "$own")"
    [[ -n "$ports" ]] || ports="--"
    [[ -n "$own" ]] || own="--"

    if [[ "$own" == +* ]]
    then
      local digits="${own#+}"
      if [[ "$digits" == 1* ]]
      then
        cc="1"
      else
        cc="${digits:0:2}"
      fi
    fi

    if [[ -n "$id" ]]
    then
      info="id='$id' manufacturer='$manufacturer' model='$model' plugin='$plugin' primary='$primary'"
      if [[ -n "$ports" ]]
      then
        info+=" ports='$ports'"
      fi
      info+=" phone='$own'"
      if [[ -n "$cc" ]]
      then
        info+=" cc='$(cc_to_label "$cc")'"
      fi
      printf '%s' "$info"
      return 0
    fi
  fi

  printf "id='%s'" "$MODEM"
}

# Derive a simple country code from a phone number in +E.164 form
phone_cc() {
  local n="$1"
  if [[ "$n" == +* ]]
  then
    local d="${n#+}"

    if [[ "$d" == 1* ]]
    then
      printf '1'
      return 0
    fi

    printf '%s' "${d:0:2}"
    return 0
  fi

  printf '%s' "--"
}

# Map a numeric country calling code to a short human-readable label
cc_to_label() {
  case "$1" in
    1) printf 'US' ;;
    33) printf 'FR' ;;
    49) printf 'DE' ;;
    *) printf '%s' "$1" ;;
  esac
}

# Return a human-readable CC label (US/FR/DE) for a +E.164 phone number
phone_cc_label() {
  local cc
  cc="$(phone_cc "$1")"
  cc_to_label "$cc"
}

# Ensure a phone/MSISDN has leading '+' when it's only digits
ensure_plus() {
  local n="${1:-}"

  if [[ -z "$n" ]]
  then
    printf '%s' ""
    return 0
  fi

  if [[ "$n" != +* && "$n" =~ ^[0-9]+$ ]]
  then
    printf '+%s' "$n"
  else
    printf '%s' "$n"
  fi
}

# Abbreviate text for logs: strip CR, escape newlines/backslashes, and truncate
abbrev_text_for_log() {
  local s="${1:-}"
  local maxlen="${2:-$LOG_ABBREV_LEN}"

  s=${s//$'\r'/}
  s=${s//$'\n'/\\n}
  s=${s//\\/\\\\}

  if [[ -z "$s" ]]
  then
    s="<empty>"
  fi

  if (( ${#s} > maxlen ))
  then
    s="${s:0:maxlen}…"
  fi

  printf '%s' "$s"
}

# Map mmcli SMS pdu-type to a friendly type label
pdu_to_type() {
  local pdu="${1,,}"
  case "$pdu" in
    deliver) printf 'received' ;;
    submit) printf 'sent' ;;
    status-report) printf 'report' ;;
    *) printf '%s' "$1" ;;
  esac
}

# List modem ids sorted numerically (one per line)
list_modem_ids_sorted() {
  local list_json
  if ! list_json="$(mmcli -L -J)"
  then
    return 1
  fi

  jq -r '."modem-list"[]? | split("/")[-1]' <<<"$list_json" | sort -n
}

log_modem_details() {
  local mid="$1" prefix="${2:-}"
  [[ -z "$mid" ]] && return 1

  local mjson fields id manufacturer model plugin primary ports phone info
  if mjson="$(mmcli -m "$mid" -J)"
  then
    fields="$(jq -r '
      .modem as $m
      | [
          ($m["dbus-path"] | split("/")[-1] // ""),
          ($m.generic.manufacturer // "--"),
          ($m.generic.model // "--"),
          ($m.generic.plugin // "--"),
          ($m.generic["primary-port"] // "--"),
          (($m.generic.ports // []) | map(split(" ")[0]) | join(",")),
          ($m.generic["own-numbers"][0] // "")
        ]
      | @tsv
    ' <<<"$mjson")"

    if [[ -z "$fields" ]]
    then
      echo_info "${prefix}modem={id='$mid'}"
      return 0
    fi

    IFS=$'\t' read -r id manufacturer model plugin primary ports phone <<<"$fields"
    phone="$(ensure_plus "$phone")"

    [[ -n "$ports" ]] || ports="--"
    [[ -n "$id" ]] || id="$mid"
    [[ -n "$phone" ]] || phone="--"

    local cc_label
    cc_label="$(phone_cc_label "$phone")"
    [[ -n "$cc_label" ]] || cc_label="--"

    printf -v info "id='%s' manufacturer='%s' model='%s' plugin='%s' primary='%s' ports='%s' phone='%s' cc='%s'" \
      "$id" "$manufacturer" "$model" "$plugin" "$primary" "$ports" "$phone" "$cc_label"
    echo_info "${prefix}modem={${info}}"
  else
    echo_info "${prefix}modem={id='$mid'}"
  fi
}

get_modem_at_port() {
  local wait_enabled="$AT_WAIT_MODEM"
  local wait_timeout="$AT_WAIT_TIMEOUT"
  local sleep_interval="$AT_WAIT_SLEEP_INTERVAL"

  if [[ ! "$wait_timeout" =~ ^[0-9]+$ ]]
  then
    wait_timeout=0
  fi

  if [[ ! "$sleep_interval" =~ ^[0-9]+(\.[0-9]+)?$ ]]
  then
    sleep_interval=2
  fi

  echo_debug "Resolving modem AT port for '$MODEM'"

  local wait_started=$SECONDS
  local wait_logged=0
  local err="no AT port detected for modem '$MODEM'"

  while :
  do
    local mmcli_out="" json="" port=""

    if ! mmcli_out="$(mmcli -m "$MODEM" -J 2>&1)"
    then
      echo_debug "get_modem_at_port: mmcli failed: ${mmcli_out//$'\n'/ }"
      err="failed to query modem JSON"
    else
      json="$mmcli_out"
      port="$(jq -r '
        def normalize_port:
          if . == null or . == "" then ""
          elif startswith("/") then .
          else "/dev/" + .
          end;
        ((.modem.generic.ports // [])
          | map(select(test("\\(at\\)"; "i")) | split(" ")[0] | normalize_port)
          | map(select(. != ""))
          | .[0])
        // ((.modem.generic["primary-port"] // "") | normalize_port)
      ' <<<"$json")"

      if [[ "$port" == "null" ]]
      then
        port=""
      fi

      if [[ -n "$port" ]]
      then
        echo_debug "resolved modem '$MODEM' AT port candidate '${port}'"
        if [[ -e "$port" ]]
        then
          echo_debug "resolved modem '$MODEM' AT port to '${port}'"
          printf '%s' "$port"
          return 0
        fi
        err="modem '$MODEM' AT port '$port' does not exist"
      else
        err="no AT port detected for modem '$MODEM'"
      fi
    fi

    if [[ -z "$wait_enabled" ]]
    then
      echo_error "$err"
      return 1
    fi

    if (( wait_logged == 0 ))
    then
      if (( wait_timeout > 0 ))
      then
        echo_info "waiting for modem '$MODEM' AT port (timeout ${wait_timeout}s)"
      else
        echo_info "waiting for modem '$MODEM' AT port"
      fi
      wait_logged=1
      wait_started=$SECONDS
    fi

    if (( wait_timeout > 0 ))
    then
      local elapsed=$(( SECONDS - wait_started ))
      if (( elapsed >= wait_timeout ))
      then
        echo_error "$err"
        return 1
      fi
    fi

    sleep "$sleep_interval"
  done
}

at_command_direct() {
  local cmd="$1"
  local port

  if ! port="$(get_modem_at_port)"
  then
    return 1
  fi

  if [[ ! -w "$port" ]]
  then
    echo_error "AT port '$port' is not writable"
    return 1
  fi

  local fd
  echo_debug "Opening connection to AT port '$port'"
  if ! exec {fd}<>"$port"
  then
    echo_error "Failed to open '$port'"
    return 1
  fi

  local _drain
  while read -r -t "$AT_FALLBACK_READ_TIMEOUT" -u $fd _drain
  do
    :
  done

  echo_debug "AT TX -> $cmd"
  printf '%s\r' "$cmd" >&$fd

  local resp="" line="" timeout_count=0
  while (( timeout_count < AT_FALLBACK_MAX_READS ))
  do
    if ! read -r -t "$AT_FALLBACK_READ_TIMEOUT" -u $fd line
    then
      timeout_count=$((timeout_count + 1))
      continue
    fi

    timeout_count=0
    line="${line%$'\r'}"

    [[ "$line" == "$cmd" ]] && continue

    if [[ -n "$line" ]]
    then
      echo_debug "AT RX <- $line"
      resp+="$line"$'\n'
      if [[ "$line" == "OK" || "$line" == "ERROR" ]]
      then
        break
      fi
    fi
  done

  exec {fd}>&- {fd}<&-

  resp="${resp%$'\n'}"
  if [[ -n "$resp" ]]
  then
    printf '%s' "$resp"
    return 0
  fi

  return 1
}

configure_huawei_modem() {
  echo_info "huawei: configuring modem for SMS text mode"

  local -A at_codes=(
    [AT]="baseline connectivity check"
    [AT&F]="restore factory defaults"
    [AT+CMEE=2]="enable verbose error codes"
    [AT+CMGF=1]="set SMS message format to text"
    [AT+CSMP=17,167,0,0]="set SMS params: submit PDU, validity ~24h, normal PID, 7-bit alphabet"
    [AT+CGSMS=3]="set SMS service to PS preferred (fallback CS)"
    [AT+CMGD=1,4]="delete all messages"
  )

  local cmd resp
  for cmd in "${!at_codes[@]}"
  do
    resp="$(at_command "$cmd")"
    echo_info "huawei: $cmd (${at_codes[$cmd]}) -> $(format_at_response "$resp")"
  done
}

configure_quectel_modem() {
  echo_debug "quectel: no vendor-specific configuration required"
  return 0
}

modem_vendor_from_info_json() {
  local info_json="$1"

  local plugin manufacturer vendor=""
  plugin="$(jq -r '.modem.generic.plugin // ""' <<<"$info_json")"
  manufacturer="$(jq -r '.modem.generic.manufacturer // ""' <<<"$info_json")"

  if [[ "${plugin,,}" == huawei || "${manufacturer,,}" == huawei* ]]
  then
    vendor="huawei"
  elif [[ "${plugin,,}" == quectel || "${manufacturer,,}" == quectel* ]]
  then
    vendor="quectel"
  fi

  if [[ -n "$vendor" ]]
  then
    printf '%s' "$vendor"
    return 0
  fi

  return 1
}

configure_modem_vendor() {
  local info_json="$1"

  local vendor
  if ! vendor="$(modem_vendor_from_info_json "$info_json")"
  then
    return 0
  fi

  case "$vendor" in
    huawei)
      configure_huawei_modem
      ;;
    quectel)
      configure_quectel_modem
      ;;
  esac
}

reset_quectel_modem() {
  reset_log "quectel: sending AT+QPOWD=0"

  local resp=""
  if ! resp="$(at_command 'AT+QPOWD=0')"
  then
    echo_error "quectel reset failed"
  fi

  local formatted_resp
  formatted_resp="$(format_at_response "$resp")"
  reset_log "quectel: AT+QPOWD=0 -> $formatted_resp"

  return 0
}

reset_modem_vendor() {
  local info_json="${1:-}"
  local vendor="${2:-}"

  if [[ -z "$vendor" ]]
  then
    if [[ -z "$info_json" ]]
    then
      return 0
    fi
    if ! vendor="$(modem_vendor_from_info_json "$info_json")"
    then
      return 0
    fi
  fi

  case "$vendor" in
    quectel)
      reset_quectel_modem
      ;;
  esac

  return 0
}

usb_sysfs_path_for_port() {
  local port="$1"
  local path=""
  local -a bases=(
    "/sys/class/tty/$port"
    "/sys/class/usbmisc/$port"
    "/sys/class/net/$port"
  )

  for path in "${bases[@]}"
  do
    if [[ -e "$path" ]]
    then
      readlink -f "$path"
      return 0
    fi
  done

  return 1
}

usb_device_dir_for_path() {
  local path="$1"
  local dir="$path"

  while [[ -n "$dir" && "$dir" != "/" ]]
  do
    if [[ -f "$dir/idVendor" && -f "$dir/idProduct" ]]
    then
      printf '%s\n' "$dir"
      return 0
    fi
    dir="$(dirname "$dir")"
  done

  return 1
}

modem_usb_replug() {
  local info_json="$1"

  if [[ -z "$info_json" ]]
  then
    echo_error "cannot replug USB device: missing modem info"
    return 1
  fi

  local -a ports=()
  local jq_status=0
  mapfile -t ports < <(jq -r '
    (.modem.generic.ports // [])
    | map(split(" ")[0])
    | map(select(length > 0)) | .[]
  ' <<<"$info_json") || jq_status=$?

  if (( jq_status != 0 )) && (( ${#ports[@]} == 0 ))
  then
    echo_warning "failed to parse modem ports for USB replug"
    return 1
  fi

  if (( ${#ports[@]} == 0 ))
  then
    echo_warning "no modem ports reported, cannot replug USB device"
    return 1
  fi

  declare -A seen_dirs=()
  declare -A dir_ports=()
  local -a device_dirs=()

  local port
  for port in "${ports[@]}"
  do
    [[ -n "$port" ]] || continue

    local sys_path
    if ! sys_path="$(usb_sysfs_path_for_port "$port")"
    then
      echo_debug "usb replug: unable to resolve sysfs path for port $port"
      continue
    fi

    local device_dir
    if ! device_dir="$(usb_device_dir_for_path "$sys_path")"
    then
      echo_debug "usb replug: no USB device directory found for port $port ($sys_path)"
      continue
    fi

    if [[ -z "${seen_dirs[$device_dir]:-}" ]]
    then
      device_dirs+=("$device_dir")
      seen_dirs["$device_dir"]=1
    fi

    if [[ -n "${dir_ports[$device_dir]:-}" ]]
    then
      dir_ports["$device_dir"]+=" $port"
    else
      dir_ports["$device_dir"]="$port"
    fi
  done

  if (( ${#device_dirs[@]} == 0 ))
  then
    echo_warning "could not resolve USB device backing modem ports (${ports[*]})"
    return 1
  fi

  local bind_path="/sys/bus/usb/drivers/usb/bind"
  local unbind_path="/sys/bus/usb/drivers/usb/unbind"
  local success

  local device_dir
  for device_dir in "${device_dirs[@]}"
  do
    local port_list="${dir_ports[$device_dir]# }"

    local dev_name
    dev_name="$(basename "$device_dir")"

    local vendor
    local product

    if [[ -f "$device_dir/idVendor" ]]
    then
      vendor="$(<"$device_dir/idVendor")"
    fi

    if [[ -f "$device_dir/idProduct" ]]
    then
      product="$(<"$device_dir/idProduct")"
    fi

    local authorized_path="$device_dir/authorized"
    if [[ -w "$authorized_path" ]]
    then
      reset_log "USB replugging device $dev_name (ports: ${port_list:-unknown}, vid:pid ${vendor:-??}:${product:-??})"
      if ! printf '0\n' >"$authorized_path"
      then
        echo_warning "failed to deauthorize USB device $dev_name"
        continue
      fi

      sleep 2

      if ! printf '1\n' >"$authorized_path"
      then
        echo_warning "failed to reauthorize USB device $dev_name"
        continue
      fi

      sleep 2
      success=1
      continue
    fi

    if [[ -w "$unbind_path" && -w "$bind_path" ]]
    then
      reset_log "USB replugging device $dev_name (ports: ${port_list:-unknown}, vid:pid ${vendor:-??}:${product:-??}) via unbind/bind"
      if ! printf '%s\n' "$dev_name" >"$unbind_path"
      then
        echo_warning "failed to unbind USB device $dev_name"
        continue
      fi

      sleep 2

      if ! printf '%s\n' "$dev_name" >"$bind_path"
      then
        echo_warning "failed to bind USB device $dev_name"
        continue
      fi

      sleep 2
      success=1
      continue
    fi

    echo_warning "no supported USB replug control for device $dev_name (ports: ${port_list:-unknown})"
  done

  if [[ -n $success ]]
  then
    return 1
  fi

  return 0
}

# Resolve default recipient based on modem/country-specific variables.
# Order:
#  - DEFAULT_RECIPIENT_<LABEL> (US/FR/DE)
#  - DEFAULT_RECIPIENT_<CC> (1/33/49)
#  - DEFAULT_RECIPIENT
resolve_default_recipient() {
  local mid="${1:-}"

  local cc
  cc="$(get_home_cc "$mid")"

  echo_debug "resolve_default_recipient: mid=${mid:-} cc=${cc:-}"

  # Guard: unknown CC → fall back to global default or fail
  if [[ -z "$cc" ]]
  then
    if [[ -n "${DEFAULT_RECIPIENT-}" ]]
    then
      echo_debug "resolve_default_recipient: cc unknown, using DEFAULT_RECIPIENT=${DEFAULT_RECIPIENT}"
      printf '%s' "${DEFAULT_RECIPIENT}"
      return 0
    fi

    echo_debug "resolve_default_recipient: cc unknown and no DEFAULT_RECIPIENT"
    return 1
  fi

  local label
  case "$cc" in
    1)
      label=US
      ;;
    33)
      label=FR
      ;;
    49)
      label=DE
      ;;
  esac

  # Try label-specific var
  local var val
  if [[ -n "$label" ]]
  then
    var="DEFAULT_RECIPIENT_${label}"
    echo_debug "resolve_default_recipient: try $var"
    if declare -p "$var" &>/dev/null
    then
      val="${!var}"
      if [[ -n "$val" ]]
      then
        echo_debug "resolve_default_recipient: matched $var=$val"
        printf '%s' "$val"
        return 0
      fi
    fi
  fi

  # Try numeric-CC specific var
  var="DEFAULT_RECIPIENT_${cc}"
  echo_debug "resolve_default_recipient: try $var"
  if declare -p "$var" &>/dev/null
  then
    val="${!var}"
    if [[ -n "$val" ]]
    then
      echo_debug "resolve_default_recipient: matched $var=$val"
      printf '%s' "$val"
      return 0
    fi
  fi

  # Global default
  if [[ -n "${DEFAULT_RECIPIENT-}" ]]
  then
    echo_debug "resolve_default_recipient: default DEFAULT_RECIPIENT=${DEFAULT_RECIPIENT}"
    printf '%s' "${DEFAULT_RECIPIENT}"
    return 0
  fi

  echo_debug "resolve_default_recipient: no default found"
  return 1
}

modemmanager_running_with_debug() {
  pgrep -a -f 'ModemManager-wrapper.*--debug' &>/dev/null
}

# Run an AT command via mmcli and return the response string
# - Strips the leading "response: '...'") wrapper printed by mmcli
# - If no such wrapper is present, returns raw stdout/stderr as-is
at_command() {
  local cmd="$1"
  local resp

  if modemmanager_running_with_debug
  then
    echo_debug "MM is in debug mode, running AT command '${cmd}' using mmcli"

    local out
    if out="$(mmcli_cmd --command="$cmd" 2>&1)"
    then
      # TODO is this really working for multiple-line responses?
      resp="$(printf '%s\n' "$out" | \
        sed -n "s/^response: '\(.*\)'$/\1/p" | head -n1)"

      if [[ -z "$resp" ]]
      then
        echo_warning "'${cmd}': empty AT command response"
        return 1
      fi

      printf '%s' "$resp"
      return 0
    fi

    echo_debug "mmcli --command='${cmd}' failed, attempting to issue AT command directly"
  fi

  if ! resp="$(at_command_direct "$cmd")"
  then
    echo_debug "direct AT command failed: '$cmd'"
    return 1
  fi

  printf '%s' "$resp"
  return 0
}

at_command_interactive() {
  local port
  if ! port="$(get_modem_at_port)"
  then
    echo_error "Failed to determine AT port for modem $MODEM"
    return 1
  fi

  socat - "${port},crnl"
}

mmsms_logread() {
  echo_debug "logread args: $*"
  logread -e "$SCRIPT_NAME" "$@"
}

mmsms_service_action() {
  "/etc/init.d/${SCRIPT_NAME}" "$@"
}

format_at_response() {
  local resp="$1"

  if [[ -z "$resp" ]]
  then
    printf '%s' '<no response>'
    return 0
  fi

  resp="${resp//$'\n'/'; '}"
  printf '%s' "$resp"
}

# Decode a UCS2 hex string like "002B0033..." by taking the low byte of each code unit
at_decode_ucs2() {
  local s="$1"

  if [[ "$s" =~ ^([0-9A-Fa-f]{4})+$ ]]
  then
    local out=""
    local pos=0 len=${#s} hb
    while (( pos < len ))
    do
      hb="${s:pos+2:2}"
      out+="$(printf '%b' "\\x$hb")"
      pos=$((pos + 4))
    done

    printf '%s' "$out"
    return 0
  fi

  printf '%s' "$s"
}

# Extract the first double-quoted field from an AT response and decode UCS2 if applicable
at_first_quoted_decoded() {
  local resp="$1"

  local q
  q="$(printf '%s\n' "$resp" | sed -n 's/^.*"\([^"]*\)".*$/\1/p' | head -n1)"

  if [[ -z "$q" ]]
  then
    return 1
  fi

  if [[ "$q" =~ ^([0-9A-Fa-f]{4})+$ ]]
  then
    q="$(at_decode_ucs2 "$q")"
  fi

  printf '%s' "$q"
}

# Resolve a human-friendly modem selector to a concrete modem id
# - Accepts: numeric id (e.g., 2), D-Bus path, 'any', or a substring
#   matching manufacturer, plugin, primary-port, or any ttyUSB/wwan port.
# - On multiple matches, prints a modem list to stderr and returns non-zero.
# - On no match, reports an error and shows the list.
get_modem_id() {
  local sel_raw="${1:-}"
  local sel

  # Default / passthrough cases
  if [[ -z "$sel_raw" || "$sel_raw" == any ]]
  then
    printf '%s' "any"
    return 0
  fi

  # If a D-Bus path (/org/.../Modem/N)
  if [[ "$sel_raw" == */Modem/* ]]
  then
    printf '%s' "${sel_raw##*/}"
    return 0
  fi

  # Case-insensitive substring match on fields (unless country filter applies)
  sel="${sel_raw,,}"

  local list_json ids id json
  if ! list_json="$(mmcli -L -J)"
  then
    echo_error "could not query modem list via mmcli"
    return 1
  fi

  # Collect modem ids
  mapfile -t ids < <(jq -r '."modem-list"[]? | split("/")[-1]' <<<"$list_json")
  if (( ${#ids[@]} == 0 ))
  then
    echo_error "no modems detected"
    return 1
  fi

  # If pure numeric input, treat as id only if it matches a detected id; otherwise
  # continue with fuzzy matching (e.g., phone number fragment)
  if [[ "$sel_raw" =~ ^[0-9]+$ ]]
  then
    local _id
    for _id in "${ids[@]}"
    do
      if [[ "$_id" == "$sel_raw" ]]
      then
        printf '%s' "$sel_raw"
        return 0
      fi
    done
  fi

  local matches=()
  local cc_filter=""
  cc_filter="$(country_to_cc "$sel_raw")"

  for id in "${ids[@]}"
  do
    [[ -z "$id" ]] && continue
    if ! json="$(mmcli -m "$id" -J)"
    then
      continue
    fi

    # Extract candidate fields and match
    local fields numbers sel_digits
    fields="$(jq -r '
      .modem.generic as $g
      | [
          ($g.manufacturer // ""),
          ($g.plugin // ""),
          ($g["primary-port"] // ""),
          (($g.ports // [])[]? | (split(" ")[0]))
        ] | .[]
    ' <<<"$json")"
    numbers="$(jq -r '.modem.generic["own-numbers"][]? // empty' <<<"$json")"
    sel_digits="${sel_raw//[^0-9+]/}"

    local matched=0
    if [[ -n "$cc_filter" && -n "$numbers" ]]
    then
      # Country code filter: match if any own-number starts with +<cc>
      local n
      while IFS= read -r n
      do
        [[ -z "$n" ]] && continue
        n="${n#+}"
        if [[ "$n" == "$cc_filter"* ]]
        then
          matched=1; break
        fi
      done <<< "$numbers"
    else
      # Generic substring/regex and number substring matching
      if [[ -n "$fields" ]]
      then
        local f lf
        while IFS= read -r f
        do
          lf="${f,,}"
          if [[ "$lf" == *"$sel"* ]]
          then
            matched=1; break
          fi
        done <<< "$fields"
      fi

      if (( matched == 0 )) && [[ -n "$numbers" ]]
      then
        local n nd
        while IFS= read -r n
        do
          [[ -z "$n" ]] && continue
          nd="${n//[^0-9+]/}"
          if [[ "${n,,}" == *"${sel_raw,,}"* ]] || { [[ -n "$sel_digits" ]] && [[ "$nd" == *"$sel_digits"* ]]; }
          then
            matched=1; break
          fi

          if printf '%s\n' "$n" | grep -Eq -- "$sel_raw"
          then
            matched=1; break
          fi
        done <<< "$numbers"
      fi
    fi

    if (( matched == 1 ))
    then
      matches+=("$id")
    fi
  done

  if (( ${#matches[@]} == 1 ))
  then
    printf '%s' "${matches[0]}"
    return 0
  fi

  # Helper to show available modems for disambiguation
  echo_error "${SCRIPT_NAME}: modem selector '${sel_raw}' matched ${#matches[@]} modem(s)"
  echo_info "Available modems:"

  for id in "${ids[@]}"
  do
    [[ -z "$id" ]] && continue

    if ! json="$(mmcli -m "$id" -J)"
    then
      continue
    fi

    jq -r '
      .modem as $m
      | {
          id: ($m["dbus-path"] | split("/")[-1]),
          manufacturer: ($m.generic.manufacturer // "--"),
          model: ($m.generic.model // "--"),
          plugin: ($m.generic.plugin // "--"),
          primary: ($m.generic["primary-port"] // "--"),
          ports: (($m.generic.ports // []) | map(split(" ")[0]) | join(","))
        }
      | ("  " + .id + ": " + .manufacturer + " " + .model
         + " plugin=" + .plugin
         + " primary=" + .primary
         + " ports=" + .ports)
    ' <<<"$json" >&2
  done

  if (( ${#matches[@]} == 0 ))
  then
    return 1
  fi

  # FIXME Ambiguous
  return 2
}

# Log and run generic mmcli calls (no implicit --modem)
mmcli() {
  echo_debug "\$ mmcli $*"
  command mmcli "$@"
}

mmcli_cmd() {
  command mmcli --modem "$MODEM" "$@"
}

sms_read() {
  local msg_id="$1"
  mmcli_cmd --sms "$msg_id"
}

sms_read_json() {
  local msg_id="$1"
  local js pdu msg_type own=""

  if ! js="$(mmcli_cmd --sms "$msg_id" -J)"
  then
    return 1
  fi

  pdu="$(jq -r '.sms.properties["pdu-type"] // ""' <<<"$js")"
  msg_type="$(pdu_to_type "$pdu")"

  if load_own_number
  then
    own="$OWN_NUMBER"
  fi

  jq --arg type "$msg_type" --arg own "$own" '
    .sms as $s
    | {
        id: ($s["dbus-path"] | split("/")[-1] | tonumber?),
        sender: ($s.content.number // ""),
        text: ($s.content.text // ""),
        class: ($s.properties.class // ""),
        state: ($s.properties.state // ""),
        pdu: ($s.properties["pdu-type"] // ""),
        storage: ($s.properties.storage // ""),
        smsc: ($s.properties.smsc // ""),
        timestamp: ($s.properties.timestamp // ""),
        discharge_timestamp: ($s.properties["discharge-timestamp"] // ""),
        delivery_state: ($s.properties["delivery-state"] // ""),
        delivery_report: ($s.properties["delivery-report"] // ""),
        type: $type,
        recipient: (if $type == "received" then $own else ($s.content.number // "") end)
      }
  ' <<<"$js"
}

sms_send() {
  local recipient=""
  local text=""
  local recipient_was_default=0

  # Parse args: allow default recipient when not specified
  if (( $# >= 1 ))
  then
    if [[ "$1" == "-" ]]
    then
      shift
    elif [[ "$1" == +* || "$1" =~ ^[0-9]+$ ]]
    then
      recipient="$1"
      shift
    fi
  fi

  if (( $# == 0 ))
  then
    if [[ -t 0 ]]
    then
      echo_error "no SMS text provided"
      return 2
    fi
    text="$(cat)"
  elif [[ "$1" == "-" ]]
  then
    shift
    text="$(cat)"
  else
    text="$*"
  fi

  if [[ -z "$recipient" ]]
  then
    # Try to load defaults from config when sending without explicit recipient
    # shellcheck disable=SC2031
    recipient="$(resolve_default_recipient "$MODEM")"
    if [[ -z "$recipient" ]]
    then
      echo_error "no recipient specified and no DEFAULT_RECIPIENT configured for this modem/country"
      return 2
    fi
    recipient_was_default=1
  fi

  recipient="${recipient//[[:space:]]/}"
  recipient="$(ensure_plus "$recipient")"

  SMS_LAST_RECIPIENT="$recipient"
  SMS_LAST_RECIPIENT_FROM_DEFAULT="$recipient_was_default"

  # Enforce local-only sending unless --allow-foreign is set
  if [[ -z "$ALLOW_FOREIGN" ]]
  then
    local home_cc
    # shellcheck disable=SC2031
    home_cc="$(get_home_cc "$MODEM")"
    if [[ -n "$home_cc" && "$recipient" == +([0-9]) ]]
    then
      if [[ "$recipient" != +"$home_cc"* ]]
      then
        echo_warning "blocking foreign recipient $recipient (home CC=$home_cc); use --allow-foreign to override or set HOME_CC"
        return 1
      fi
    fi
  fi

  if [[ -z "$text" ]]
  then
    echo_error "no SMS text provided"
    return 2
  fi

  # Expand common escapes and strip trailing whitespace to avoid stray spaces
  text="$(printf '%b' "$text" | sed -e 's/[[:space:]]\+$//')"

  # Log outgoing SMS (preview) to stderr and syslog
  local log_text
  log_text="$(abbrev_text_for_log "$text")"
  local log_modem
  log_modem="$(modem_info_brief)"
  echo_info "sending sms with modem={$log_modem} recipient='$recipient' text='$log_text'"

  local tmpfile
  if ! tmpfile="$(mktemp "${TMPDIR:-/tmp}/mmsms-text.XXXXXX")"
  then
    echo_error "failed to create temporary file for SMS text"
    return 1
  fi

  if ! printf '%s' "$text" >"$tmpfile"
  then
    rm -f "$tmpfile"
    echo_error "failed to write SMS text to temporary file"
    return 1
  fi

  local sms_id=""
  local smsc_raw
  local smsc
  local smsc_params=""
  smsc_raw="$(get_smsc_number)"
  if [[ -n "$smsc_raw" ]]
  then
    smsc="${smsc_raw//[[:space:]]/}"

    if [[ -n "$smsc" && "$smsc" != +* ]]
    then
      smsc="+$smsc"
    fi

    if [[ -n "$smsc" && "$smsc" =~ ^\+[0-9]+$ ]]
    then
      smsc_params=",smsc=$smsc"
    elif [[ -n "$smsc_raw" ]]
    then
      echo_warning "invalid smsc '$smsc_raw', skipping"
      smsc=""
    fi
  fi

  local create_attempt=1
  local max_attempts=$SMS_RETRY_COUNT
  local rc=1

  # Create the SMS first (retrying creation only if creation itself fails)
  if (( max_attempts < 1 )); then max_attempts=1; fi

  while (( create_attempt <= max_attempts ))
  do
    sms_id=""
    local create_json
    create_json=""
    if ! create_json="$(mmcli_cmd -J --messaging-create-sms="number=${recipient}${smsc_params}" \
      --messaging-create-sms-with-text="$tmpfile")"
    then
      if (( create_attempt == max_attempts ))
      then
        echo_error "failed to create SMS after $max_attempts attempts"
        rm -f "$tmpfile"
        return 1
      fi

      echo_warning "failed to create SMS (attempt $create_attempt/$max_attempts), retrying"
      create_attempt=$((create_attempt + 1))
      continue
    fi

    if ! sms_id="$(jq -r '.modem.messaging["created-sms"] // empty' <<<"$create_json")"
    then
      sms_id=""
    fi

    if [[ -z "$sms_id" ]]
    then
      if (( create_attempt == max_attempts ))
      then
        echo_error "failed to create SMS after $max_attempts attempts"
        rm -f "$tmpfile"
        return 1
      fi

      echo_warning "received empty SMS id (attempt $create_attempt/$max_attempts), retrying"
      create_attempt=$((create_attempt + 1))
      continue
    fi
    break
  done

  # Now retry only the send step for the created SMS id
  local send_attempt=1
  if (( max_attempts < 1 )); then max_attempts=1; fi

  while (( send_attempt <= max_attempts ))
  do
    if mmcli_cmd --sms "$sms_id" --send --timeout="$SMS_SEND_TIMEOUT"
    then
      rc=0
      echo_success "message sent with modem={$log_modem} recipient='$recipient'"
      break
    fi

    if (( send_attempt == max_attempts ))
    then
      echo_error "failed to send SMS after $max_attempts attempts"
      break
    fi

    echo_warning "failed to send SMS (attempt $send_attempt/$max_attempts), retrying"
    send_attempt=$((send_attempt + 1))
  done

  # direct send failure logs use echo_warning at call site; SYSLOG_MIRROR handles mirroring

  rm -f "$tmpfile"
  return $rc
}

# Determine if a recipient is allowed for a given modem id based on
# --allow-foreign/HOME_CC. Returns 0 if allowed, 1 if blocked.
recipient_allowed_for_modem() {
  local recipient="$1"
  local mid="$2"

  if [[ -n "$ALLOW_FOREIGN" ]]
  then
    return 0
  fi

  local hcc
  hcc="$(get_home_cc "$mid")"

  if [[ -z "$hcc" ]]
  then
    echo_warning "Failed to determine home CC for modem id '$mid', blocking foreign recipient $recipient"
    return 1
  fi

  if [[ "$recipient" == +"$hcc"* ]]
  then
    return 0
  fi

  return 1
}

sms_send_with_fallback() {
  local orig_args=("$@")
  local args=("$@")
  local recipient=""
  local text=""

  # First attempt with the original arguments
  if sms_send "${orig_args[@]}"
  then
    return 0
  fi

  if [[ -z "$FALLBACK" ]]
  then
    return 1
  fi

  # Parse optional recipient from arguments
  if (( ${#args[@]} > 0 ))
  then
    case "${args[0]}" in
      -)
        args=("${args[@]:1}")
        ;;
      +*|[0-9]*)
        recipient="${args[0]}"
        args=("${args[@]:1}")
        ;;
    esac
  fi

  if (( ${#args[@]} > 0 )) && [[ "${args[0]}" == "-" ]]
  then
    args=("${args[@]:1}")
  fi

  if (( ${#args[@]} > 0 ))
  then
    text="${args[*]}"
  fi

  if [[ -z "$text" ]]
  then
    echo_warning "fallback: message text unavailable for resend"
    return 1
  fi

  local resolved_recipient="${SMS_LAST_RECIPIENT:-$recipient}"
  local orig_recipient_default_flag="${SMS_LAST_RECIPIENT_FROM_DEFAULT:-0}"
  recipient="$resolved_recipient"

  # Gather other modems
  local mids mid cur_id
  cur_id="$MODEM"
  if [[ "$cur_id" == "any" ]]
  then
    local _j
    if _j="$(mmcli_cmd -J)"
    then
      cur_id="$(jq -r '.modem["dbus-path"] | split("/")[-1] // empty' <<<"$_j")"
    fi
  fi

  if ! mapfile -t mids < <(list_modem_ids_sorted)
  then
    return 1
  fi

  for mid in "${mids[@]}"
  do
    [[ -z "$mid" || "$mid" == "$cur_id" ]] && continue
    local prev_mode="$MODEM"
    MODEM="$mid"
    local candidate_recipient="$recipient"
    local used_auto=""
    local auto_tried=0

    if ! recipient_allowed_for_modem "$candidate_recipient" "$mid"
    then
      if [[ -n "$AUTO_RECIPIENT" && "$orig_recipient_default_flag" == "1" ]]
      then
        auto_tried=1
        local auto_recipient
        if auto_recipient="$(resolve_default_recipient "$mid")"
        then
          auto_recipient="${auto_recipient//[[:space:]]/}"
          auto_recipient="$(ensure_plus "$auto_recipient")"
        else
          auto_recipient=""
        fi

        if [[ -n "$auto_recipient" ]] && ! recipient_allowed_for_modem "$auto_recipient" "$mid"
        then
          auto_recipient=""
        fi

        if [[ -n "$auto_recipient" ]]
        then
          candidate_recipient="$auto_recipient"
          used_auto=1
        fi
      fi

      if [[ -z "$used_auto" ]]
      then
        local info
        info="$(modem_info_brief)"
        if [[ "$auto_tried" == 1 ]]
        then
          echo_warning "fallback: modem=$info has no eligible default recipient (auto-recipient unavailable)"
        else
          echo_warning "fallback: cannot use modem=$info for recipient $recipient (foreign not allowed; use --allow-foreign)"
        fi
        MODEM="$prev_mode"
        continue
      fi
    fi

    if [[ -n "$used_auto" ]]
    then
      local info
      info="$(modem_info_brief)"
      echo_info "fallback: using modem=$info default_recipient='$candidate_recipient'"
    fi

    echo_debug "fallback: sending text='$text'"
    echo_debug "fallback: trying modem $mid"

    if sms_send "$candidate_recipient" "$text"
    then
      local info
      info="$(modem_info_brief)"
      MODEM="$prev_mode"

      echo_info "fallback send succeeded using modem=$info"
      return 0
    fi
    MODEM="$prev_mode"
  done

  echo_warning "fallback: no eligible modem could send the message"
  return 1
}

sms_prune_all() {
  local ids
  mapfile -t ids < <(mmcli_cmd --messaging-list-sms -J | \
    jq -r '."modem.messaging.sms"[]? | split("/")[-1]' | sort -n)

  local total=${#ids[@]}
  if (( total == 0 ))
  then
    return 0
  fi

  local i=0 sms_id
  for sms_id in "${ids[@]}"
  do
    [[ -z "$sms_id" ]] && continue
    i=$((i + 1))
    echo_info "deleting SMS $sms_id ($i/$total)"
    if ! mmcli_cmd --messaging-delete-sms="$sms_id"
    then
      echo_error "failed to delete SMS $sms_id"
    fi
  done
}

sms_prune_sent() {
  # Delete only messages that are outgoing and already sent
  local list ids id js state pdu sent_ids=()

  if ! list="$(mmcli_cmd --messaging-list-sms -J)"
  then
    return 0
  fi

  mapfile -t ids < <(jq -r '
    ."modem.messaging.sms"[]? | split("/")[-1] | sort
  ' <<<"$list")

  if (( ${#ids[@]} == 0 ))
  then
    return 0
  fi

  # First collect sent IDs
  for id in "${ids[@]}"
  do
    [[ -z "$id" ]] && continue
    if ! js="$(mmcli_cmd --sms "$id" -J)"
    then
      echo_warning "failed to read SMS $id, skipping"
      continue
    fi
    state="$(jq -r '.sms.properties.state // empty' <<<"$js")"
    pdu="$(jq -r '.sms.properties["pdu-type"] // empty' <<<"$js")"
    if [[ "$state" == "sent" && "$pdu" == "submit" ]]
    then
      sent_ids+=("$id")
    fi
  done

  local total=${#sent_ids[@]}
  if (( total == 0 ))
  then
    return 0
  fi

  local i=0
  for id in "${sent_ids[@]}"
  do
    i=$((i + 1))
    echo_info "deleting sent SMS $id ($i/$total)"
    mmcli_cmd --messaging-delete-sms="$id"
  done
}

sms_prune_sent_modems() {
  local mids mid

  if ! mapfile -t mids < <(list_modem_ids_sorted)
  then
    echo_error "failed to list modems for pruning"
    return 1
  fi

  if (( ${#mids[@]} == 0 ))
  then
    echo_info "no modems detected"
    return 0
  fi

  for mid in "${mids[@]}"
  do
    [[ -z "$mid" ]] && continue
    echo_info "pruning sent messages on modem $mid"
    MODEM=$mid sms_prune_sent || echo_error "failed to prune sent messages on modem $mid"
  done
}

sms_prune_all_modems() {
  local mids mid
  if ! mapfile -t mids < <(list_modem_ids_sorted)
  then
    echo_error "failed to list modems for pruning"
    return 1
  fi

  if (( ${#mids[@]} == 0 ))
  then
    echo_info "no modems detected"
    return 0
  fi

  for mid in "${mids[@]}"
  do
    [[ -z "$mid" ]] && continue
    echo_info "pruning modem $mid"
    MODEM="$mid" sms_prune_all || echo_error "failed to prune on modem $mid"
  done
}

sms_list_print_header() {
  local include_mid="$1"
  local noc="$2"
  local header

  if [[ "$include_mid" == "1" ]]
  then
    header="$(printf '%-4s %-4s %-10s %-18s %s' 'MID' 'ID' 'TYPE' 'RECIPIENT' 'MSG')"
  else
    header="$(printf '%-4s %-10s %-18s %s' 'ID' 'TYPE' 'RECIPIENT' 'MSG')"
  fi

  if [[ -n "$noc" ]]
  then
    printf '%s\n' "$header"
  else
    printf '\e[1m%s\e[0m\n' "$header"
  fi
}

sms_list_print_entry() {
  local mid="$1"
  local id="$2"
  local js="$3"
  local include_mid="$4"
  local maxlen="${5:-80}"
  local sender text msg_type pdu

  sender="$(jq -r '.sms.content.number // "--"' <<<"$js")"
  sender="$(ensure_plus "$sender")"
  pdu="$(jq -r '.sms.properties["pdu-type"] // ""' <<<"$js")"
  msg_type="$(pdu_to_type "$pdu")"
  text="$(jq -r '.sms.content.text // ""' <<<"$js")"
  text=${text//$'\r'/}
  text=${text//$'\n'/\\n}
  if (( ${#text} > maxlen ))
  then
    text="${text:0:maxlen}…"
  fi

  if [[ "$include_mid" == "1" ]]
  then
    printf '%-4s %-4s %-10s %-18s %s\n' "$mid" "$id" "$msg_type" "$sender" "$text"
  else
    printf '%-4s %-10s %-18s %s\n' "$id" "$msg_type" "$sender" "$text"
  fi
}

sms_list_pretty() {
  local list_json ids id js sender text msg_type pdu line maxlen=80

  # When listing for all modems, iterate them explicitly
  if [[ -n "$ALL_MODEMS" ]]
  then
    local mids mid had_any=""
    if ! mapfile -t mids < <(list_modem_ids_sorted)
    then
      echo_error "failed to list modems"
      return 1
    fi

    if (( ${#mids[@]} == 0 ))
    then
      if [[ -n "$JSON_OUTPUT$RAW_OUTPUT" ]]
      then
        printf '[]\n'
      else
        echo_info "no SMS messages"
      fi

      return 0
    fi

    if [[ -z "$MODEM_DETAILS_LOGGED" ]]
    then
      echo_info "modems in scope:"
      for mid in "${mids[@]}"
      do
        [[ -z "$mid" ]] && continue
        log_modem_details "$mid"
      done
      MODEM_DETAILS_LOGGED=1
    fi

    if [[ -n "$RAW_OUTPUT" ]]
    then
      local raw_items
      raw_items="$(
        for mid in "${mids[@]}"
        do
          [[ -z "$mid" ]] && continue

          if ! list_json="$(mmcli --modem "$mid" --messaging-list-sms -J)"
          then
            continue
          fi

          mapfile -t ids < <(jq -r '."modem.messaging.sms"[]? | split("/")[-1]' <<<"$list_json")

          for id in "${ids[@]}"
          do
            [[ -z "$id" ]] && continue
            js="$(mmcli --modem "$mid" --sms "$id" -J)"

            if [[ -n "$js" ]]
            then
              jq -e -c --arg mid "$mid" '{modem_id: ($mid|tonumber), sms: .}' <<<"$js"
            fi
          done
        done
      )"
      if [[ -z "$raw_items" ]]
      then
        printf '[]\n'
      else
        printf '%s\n' "$raw_items" | jq -s '.'
      fi
      return 0
    fi

    if [[ -n "$JSON_OUTPUT" ]]
    then
      if [[ -n "$ALL_MODEMS" && -z "$target_mid" ]]
      then
        local mids mid json_items=()

        if mapfile -t mids < <(list_modem_ids_sorted)
        then
          for mid in "${mids[@]}"
          do
            [[ -z "$mid" ]] && continue
            local item
            item="$(MODEM="$mid" ALL_MODEMS="" JSON_OUTPUT=1 RAW_OUTPUT="" modem_status_single)"
            [[ -n "$item" ]] && json_items+=("$item")
          done
        fi

        if (( ${#json_items[@]} == 0 ))
        then
          printf '[]\n'
        else
          printf '%s\n' "${json_items[@]}" | jq -s '.'
        fi

        return 0
      fi

      local json_output
      json_output="$(JSON_OUTPUT=1 RAW_OUTPUT="" modem_status_single)"
      if [[ -n "$json_output" ]]
      then
        printf '%s
  ' "$json_output"
        return 0
      fi
    fi

    # Pretty output across all modems: add a MID column
    local _nocolor=""
    if [[ -n "$NO_COLOR" || -n "$CRON" ]]
    then
      _nocolor=1
    fi
    sms_list_print_header 1 "$_nocolor"

    for mid in "${mids[@]}"
    do
      [[ -z "$mid" ]] && continue
      if ! list_json="$(mmcli --modem "$mid" --messaging-list-sms -J)"
      then
        continue
      fi
      mapfile -t ids < <(jq -r '."modem.messaging.sms"[]? | split("/")[-1]' <<<"$list_json")
      for id in "${ids[@]}"
      do
        [[ -z "$id" ]] && continue
        if ! js="$(mmcli --modem "$mid" --sms "$id" -J)"
        then
          continue
        fi
        sms_list_print_entry "$mid" "$id" "$js" 1 "$maxlen"
        had_any=1
      done
    done
    [[ -n "$had_any" ]] || echo_info "no SMS messages"
    return 0
  fi

  if ! list_json="$(mmcli_cmd --messaging-list-sms -J)"
  then
    echo_error "failed to list SMS messages"
    return 1
  fi

  mapfile -t ids < <(jq -r '."modem.messaging.sms"[]? | split("/")[-1]' <<<"$list_json")
  if (( ${#ids[@]} == 0 ))
  then
    if [[ -n "$JSON_OUTPUT$RAW_OUTPUT" ]]
    then
      printf '[]\n'
    else
      echo_info "no SMS messages"
    fi
    return 0
  fi

  if [[ -n "$RAW_OUTPUT" ]]
  then
    if [[ -n "$ALL_MODEMS" && -z "$target_mid" ]]
    then
      local mids mid raw_items=()
      if mapfile -t mids < <(list_modem_ids_sorted)
      then
        for mid in "${mids[@]}"
        do
          [[ -z "$mid" ]] && continue
          local raw
          raw="$(MODEM="$mid" ALL_MODEMS="" JSON_OUTPUT="" RAW_OUTPUT=1 modem_status_single)"
          [[ -n "$raw" ]] && raw_items+=("$raw")
        done
      fi

      if (( ${#raw_items[@]} == 0 ))
      then
        printf '[]
'
      else
        printf '%s
' "${raw_items[@]}" | jq -s '.'
      fi
      return 0
    fi

    local raw_output
    raw_output="$(JSON_OUTPUT="" RAW_OUTPUT=1 modem_status_single)"
    if [[ -n "$raw_output" ]]
    then
      printf '%s
' "$raw_output"
      return 0
    fi
  fi

  if [[ -n "$JSON_OUTPUT" ]]
  then
    # Emit one compact JSON object per SMS, then wrap into an array
    # Determine our own number for recipient mapping of received messages
    local own=""
    if load_own_number
    then
      own="$OWN_NUMBER"
    fi
    {
      for id in "${ids[@]}"
      do
        [[ -z "$id" ]] && continue
        if ! js="$(mmcli_cmd --sms "$id" -J)"
        then
          continue
        fi
        pdu="$(jq -r '.sms.properties["pdu-type"] // ""' <<<"$js")"
        msg_type="$(pdu_to_type "$pdu")"
        jq -c --arg id "$id" --arg type "$msg_type" --arg own "$own" '
          {
            id: ($id|tonumber),
            sender: (.sms.content.number // ""),
            text: (.sms.content.text // ""),
            class: (.sms.content.class // ""),
            state: (.sms.properties.state // ""),
            pdu: (.sms.properties["pdu-type"] // ""),
            storage: (.sms.properties.storage // ""),
            type: $type,
            recipient: (if $type == "received" then $own else (.sms.content.number // "") end)
          }
        ' <<<"$js"
      done
    } | jq -s '.'
    return 0
  fi

  # Header for human-readable list (make entire line bold to preserve alignment)
  local _nocolor=""
  if [[ -n "$NO_COLOR" || -n "$CRON" ]]
  then
    _nocolor=1
  fi
  sms_list_print_header 0 "$_nocolor"

  for id in "${ids[@]}"
  do
    [[ -z "$id" ]] && continue
    if ! js="$(mmcli_cmd --sms "$id" -J)"
    then
      continue
    fi
    sms_list_print_entry "" "$id" "$js" 0 "$maxlen"
  done
}

enable_modem() {
  local expect_id="${1:-}"
  local max_wait=600
  local sleep_period=2
  local elapsed=0

  echo_info "waiting for D-Bus system socket"
  until [[ -S /var/run/dbus/system_bus_socket ]]
  do
    if (( elapsed >= max_wait ))
    then
      echo_warning "timeout waiting for D-Bus socket"
      return 1
    fi

    sleep "$sleep_period"
    elapsed=$((elapsed + sleep_period))
  done

  echo_info "waiting for ModemManager"
  elapsed=0
  until mmcli -L
  do
    if (( elapsed >= max_wait ))
    then
      echo_warning "timeout waiting for ModemManager"
      return 1
    fi

    sleep "$sleep_period"
    elapsed=$((elapsed + sleep_period))
  done

  echo_info "waiting for modem detection"
  elapsed=0
  local list_json
  local modem_count=0
  while :
  do
    list_json=""
    modem_count=0
    if list_json="$(mmcli -L -J)"
    then
      if [[ -n "$expect_id" && "$expect_id" =~ ^[0-9]+$ ]]
      then
        local present
        present="$(jq -r --arg id "$expect_id" '
          (."modem-list" // [])
          | map(split("/")[-1])
          | any(. == $id)
        ' <<<"$list_json" || printf 'false')"
        if [[ "$present" == "true" ]]
        then
          # Capture brief modem details for logging once detection succeeds
          local _brief
          _brief="$(modem_info_brief "$expect_id")"
          break
        fi
      else
        modem_count="$(jq -r '((."modem-list" // []) | length) // 0' <<<"$list_json" || printf '0')"
        if [[ "$modem_count" =~ ^[0-9]+$ ]] && (( modem_count > 0 ))
        then
          break
        fi
      fi
    fi

    if (( elapsed >= max_wait ))
    then
      echo_warning "timeout waiting for modem detection"
      return 1
    fi

    sleep "$sleep_period"
    elapsed=$((elapsed + sleep_period))
  done

  if [[ -n "$expect_id" && "$expect_id" =~ ^[0-9]+$ ]]
  then
    if [[ -n "$list_json" ]]
    then
      local _detected_info
      _detected_info="$(jq -r --arg id "$expect_id" '
        (."modem-list" // [])
        | map(select(split("/")[-1] == $id))
        | first
        | select(. != null)
        | {
            id: (split("/")[-1]),
            manufacturer: "--",
            model: "--",
            plugin: "--",
            primary: "--",
            ports: "--"
          }
        | ("detected expected modem: id=" + .id
             + " manufacturer=" + .manufacturer
             + " model=" + .model
             + " plugin=" + .plugin
             + " primary=" + .primary
             + " ports=" + .ports)
      ' <<<"$list_json")"
      if [[ -z "$_detected_info" || "$_detected_info" == "null" ]]
      then
        _detected_info="detected expected modem id=$expect_id"
      fi
      echo_info "$_detected_info"
    else
      echo_info "detected expected modem id=$expect_id"
    fi
  else
    echo_info "detected $modem_count modem(s)"
  fi

  # Use the expected modem id if provided; otherwise rely on MODEM
  # shellcheck disable=SC2031
  local enable_target="$MODEM"

  if [[ -n "$expect_id" ]]
  then
    enable_target="$expect_id"
  fi

  local MODEM="$enable_target"

  if mmcli_cmd --enable
  then
    echo_info "modem enabled"
    # Log enabled modem details similar to selection log
    if [[ -z $QUIET ]]
    then
      local _ej _eln
      _ej="$(mmcli -m "$enable_target" -J)"
      if [[ -n "$_ej" ]]
      then
        _eln="$(jq -r '
          .modem as $m
          | {
              id: ($m["dbus-path"] | split("/")[-1]),
              manufacturer: ($m.generic.manufacturer // "--"),
              model: ($m.generic.model // "--"),
              plugin: ($m.generic.plugin // "--"),
              primary: ($m.generic["primary-port"] // "--"),
              ports: (($m.generic.ports // []) | map(split(" ")[0]) | join(",")),
              phone: (($m.generic["own-numbers"][0] // "")
                      | if . == "" then "--"
                        else (if startswith("+") then . else "+" + . end) end),
              cc: ((($m.generic["own-numbers"][0] // "") ) as $p
                   | if $p|startswith("+1") then "1"
                     elif $p|startswith("+") then ($p[1:3])
                     else "--" end)
            }
          | ("enabled modem: id=" + .id
             + " manufacturer=" + .manufacturer
             + " model=" + .model
             + " plugin=" + .plugin
             + " primary=" + .primary
             + " ports=" + .ports
             + " phone=" + .phone
             + " cc=" + (if .phone|startswith("+1") then "US"
                         elif .phone|startswith("+33") then "FR"
                         elif .phone|startswith("+49") then "DE"
                         else "--" end))
        ' <<<"$_ej")"
        if [[ -n "$_eln" ]]
        then
          echo_info "$_eln"
        fi
        configure_modem_vendor "$_ej"
      fi
    fi
    return 0
  fi

  echo_warning "failed to enable modem"
  return 1
}

enable_all_modems() {
  local mids mid
  if ! mapfile -t mids < <(list_modem_ids_sorted)
  then
    echo_error "failed to list modems to enable"
    return 1
  fi
  if (( ${#mids[@]} == 0 ))
  then
    echo_info "no modems detected"
    return 0
  fi
  local ok_count=0
  local fail_ids=()
  for mid in "${mids[@]}"
  do
    [[ -z "$mid" ]] && continue
    echo_info "enabling modem $mid"
    if ! enable_modem "$mid"
    then
      echo_warning "failed to enable modem $mid"
      fail_ids+=("$mid")
    else
      ok_count=$((ok_count + 1))
    fi
  done
  if (( ${#fail_ids[@]} > 0 ))
  then
    echo_info "enabled $ok_count/${#mids[@]} modems (failed: ${fail_ids[*]})"
  else
    echo_info "enabled $ok_count/${#mids[@]} modems"
  fi
}

modem_reset() {
  local service="/etc/init.d/modemmanager"
  local has_service=""

  if [[ -x "$service" ]]
  then
    has_service=1
  else
    echo_warning "modemmanager init script not found or not executable at $service"
  fi

  local info_json="" vendor=""
  if info_json="$(mmcli_cmd -J)"
  then
    if ! vendor="$(modem_vendor_from_info_json "$info_json")"
    then
      vendor=""
    fi
    echo_debug "modem_reset: detected vendor '${vendor:-unknown}'"
  else
    echo_warning "could not query modem to determine vendor; proceeding with generic reset"
  fi

  if [[ -n "$HARD_RESET" && -n "$has_service" ]]
  then
    reset_log "stopping ModemManager"
    if ! "$service" stop
    then
      echo_error "failed to stop ModemManager service"
      return 1
    fi
  fi

  reset_modem_vendor "$info_json" "$vendor"

  if [[ -n "$USB_REPLUG" ]]
  then
    if ! modem_usb_replug "$info_json"
    then
      echo_error "USB replug failed"
      return 1
    fi
  fi

  if [[ -n "$HARD_RESET" && -n "$has_service" ]]
  then
    reset_log "starting ModemManager"
    if ! "$service" start
    then
      echo_error "failed to start ModemManager service"
      return 1
    fi
  fi

  reset_log "enabling modem"
  if ! enable_modem "$MODEM"
  then
    echo_warning "failed to enable modem after reset, retrying in 5s"
    sleep 5
    if ! enable_modem "$MODEM"
    then
      echo_error "failed to enable modem after reset"
      return 1
    fi
  fi

  return 0
}

modem_reset_all() {
  local mids mid
  if ! mapfile -t mids < <(list_modem_ids_sorted)
  then
    echo_error "failed to list modems to reset"
    return 1
  fi
  if (( ${#mids[@]} == 0 ))
  then
    echo_info "no modems detected"
    return 0
  fi
  for mid in "${mids[@]}"
  do
    [[ -z "$mid" ]] && continue
    echo_info "resetting modem $mid"
    MODEM="$mid" modem_reset || echo_error "failed to reset modem $mid"
  done
}

reset_log() {
  if [[ -z $QUIET ]]
  then
    echo_info "$*"
  fi
}

watch_cleanup() {
  if [[ -n "$WATCH_DBUS_PID" ]]
  then
    if ! kill "$WATCH_DBUS_PID"
    then
      echo_warning "could not stop dbus-monitor (pid $WATCH_DBUS_PID)"
    fi
    WATCH_DBUS_PID=""
  fi

  if [[ -n "$WATCH_MODEM_MONITOR_PID" ]]
  then
    if ! kill "$WATCH_MODEM_MONITOR_PID"
    then
      echo_warning "could not stop modem monitor (pid $WATCH_MODEM_MONITOR_PID)"
    fi
    WATCH_MODEM_MONITOR_PID=""
  fi

  if [[ -n "$WATCH_FIFO" ]]
  then
    if ! rm -f "$WATCH_FIFO"
    then
      echo_warning "could not remove fifo $WATCH_FIFO"
    fi
    WATCH_FIFO=""
  fi
}

watch_enable_monitor_loop() {
  local target_modem="${1:-}"
  local enable_all="${2:-}"
  local interval="$WATCH_ENABLE_POLL_INTERVAL"

  declare -A enabled_modems=()
  local -a mids=()

  if mapfile -t mids < <(list_modem_ids_sorted)
  then
    local mid
    for mid in "${mids[@]}"
    do
      [[ -z "$mid" ]] && continue
      if [[ -n "$enable_all" ]]
      then
        enabled_modems["$mid"]=1
      elif [[ -n "$target_modem" && "$target_modem" != "any" && "$mid" == "$target_modem" ]]
      then
        enabled_modems["$mid"]=1
      fi
    done
  fi

  while :
  do
    mids=()
    if mapfile -t mids < <(list_modem_ids_sorted)
    then
      local mid
      for mid in "${mids[@]}"
      do
        [[ -z "$mid" ]] && continue
        if [[ -n "$enable_all" ]]
        then
          if [[ -z "${enabled_modems[$mid]:-}" ]]
          then
            echo_info "watch: auto-enabling modem $mid"
            if enable_modem "$mid"
            then
              enabled_modems["$mid"]=1
            else
              echo_warning "watch: failed to auto-enable modem $mid"
            fi
          fi
        else
          if [[ -z "$target_modem" || "$target_modem" == "any" ]]
          then
            if [[ -z "${enabled_modems[$mid]:-}" ]]
            then
              echo_info "watch: auto-enabling modem $mid"
              if enable_modem "$mid"
              then
                enabled_modems["$mid"]=1
                target_modem="$mid"
              else
                echo_warning "watch: failed to auto-enable modem $mid"
              fi
            fi
          elif [[ "$mid" == "$target_modem" ]]
          then
            if [[ -z "${enabled_modems[$mid]:-}" ]]
            then
              echo_info "watch: auto-enabling target modem $mid"
              if enable_modem "$mid"
              then
                enabled_modems["$mid"]=1
              else
                echo_warning "watch: failed to auto-enable target modem $mid"
              fi
            fi
          fi
        fi
      done

      local known mid_present present
      for known in "${!enabled_modems[@]}"
      do
        present=0
        for mid_present in "${mids[@]}"
        do
          if [[ "$mid_present" == "$known" ]]
          then
            present=1
            break
          fi
        done
        if (( present == 0 ))
        then
          unset 'enabled_modems[$known]'
        fi
      done
    fi

    sleep "$interval"
  done
}

watch_start_enable_monitor() {
  if [[ -z "$WATCH_ENABLE" ]]
  then
    return 0
  fi

  if [[ -n "$WATCH_MODEM_MONITOR_PID" ]]
  then
    return 0
  fi

  local target_modem="$MODEM"
  local enable_all="$ALL_MODEMS"

  watch_enable_monitor_loop "$target_modem" "$enable_all" &
  WATCH_MODEM_MONITOR_PID=$!
}

watch_canon_number() {
  local n="${1:-}"
  n="${n//[^0-9]/}"
  printf '%s' "$n"
}

watch_in_whitelist() {
  local original="${1:-}"

  local num
  num="$(watch_canon_number "$original")"
  if [[ -z "$num" ]]
  then
    echo_warning "watch: sender '${original}' not whitelisted (empty canonical number); whitelist='${SMS_WHITELIST[*]}'"
    return 1
  fi

  local allowed canon_allowed
  for allowed in "${SMS_WHITELIST[@]}"
  do
    canon_allowed="$(watch_canon_number "$allowed")"
    if [[ -n "$canon_allowed" && "$num" == "$canon_allowed" ]]
    then
echo_info "watch: sender '${original}' matched whitelist entry '${allowed}' (whitelist='${SMS_WHITELIST[*]}')"
      return 0
    fi
  done

  echo_warning "watch: sender '${original}' not in whitelist; whitelist='${SMS_WHITELIST[*]}'"
  return 1
}

watch_send_reply() {
  local to="$1"
  local msg="$2"
  # Log outgoing SMS (abbreviate text and escape newlines)
  local log_text
  log_text="$(abbrev_text_for_log "$msg")"
  local log_modem
  log_modem="$(modem_info_brief)"

  echo_info "sending reply with modem={$log_modem} recipient=$to text='$log_text'"
  if [[ -n "$FALLBACK" ]]
  then
    if ! sms_send_with_fallback "$to" "$msg"
    then
      echo_warning "failed to send reply to $to (including fallback)"
      return 1
    fi
    return 0
  fi

  if ! sms_send "$to" "$msg"
  then
    echo_warning "failed to send reply to $to"
    return 1
  fi
}

watch_run_command() {
  local cmd="NO_COLOR=1 $1"
  local output rc reason="exit"
  rc=0

  if command -v timeout >/dev/null 2>&1
  then
    if ! output="$(timeout -k "${WATCH_CMD_KILL_TIMEOUT}s" "${WATCH_CMD_TIMEOUT}s" bash -c "$cmd" 2>&1)"
    then
      rc=$?
    fi
    if (( rc == 124 ))
    then
      reason="timeout"
    elif (( rc >= 128 ))
    then
      reason="killed"
    fi
  else
    if ! output="$(bash -c "$cmd" 2>&1)"
    then
      rc=$?
    fi
  fi

  WATCH_CMD_RC=$rc

  output="${output%$'\n'}"
  if (( ${#output} > CMD_OUTPUT_MAX_LEN ))
  then
    output="${output:0:CMD_OUTPUT_MAX_LEN}\n…(truncated)…"
  fi

  printf '%s' "$output"
}

load_own_number() {
  if [[ -n "$OWN_NUMBER" ]]
  then
    return 0
  fi

  local json number
  if ! json="$(mmcli_cmd -J)"
  then
    return 1
  fi

  number="$(jq -r '(.modem.generic["own-numbers"][0] // empty)' <<<"$json")"

  if [[ -z "$number" ]]
  then
    return 1
  fi

  if [[ "$number" != +* ]]
  then
    number="+$number"
  fi

  OWN_NUMBER="$number"
  return 0
}

get_smsc_number() {
  if [[ -n "$SMSC_NUMBER" ]]
  then
    printf '%s' "$SMSC_NUMBER"
    return 0
  fi

  # Try to retrieve the network-configured SMSC via AT+CSCA?
  # If unavailable or unsupported, return empty (do not force SMSC).
  local resp smsc
  resp="$(at_command 'AT+CSCA?')"
  if [[ -n "$resp" ]]
  then
    smsc="$(at_first_quoted_decoded "$resp")"
    if [[ -n "$smsc" ]]
    then
      smsc="$(ensure_plus "$smsc")"
      SMSC_NUMBER="$smsc"
      printf '%s' "$SMSC_NUMBER"
      return 0
    fi
  fi

  # No SMSC detected; leave empty so callers skip forcing one
  SMSC_NUMBER=""
  printf '%s' "$SMSC_NUMBER"
}

modem_status_single() {
  local json state power reg signal carrier own smsc mid_label
  local manufacturer model plugin primary_port ports_display ports_json="[]" at_port
  local country_code country_label country_display="unknown"
  local info_tsv

  if ! json="$(mmcli_cmd -J)"
  then
    if [[ -z $QUIET ]]
    then
      echo_error "failed to query modem status"
    fi
    return 1
  fi

  mid_label="$(jq -r '.modem["dbus-path"] | split("/")[-1] // ""' <<<"$json")"

  if [[ -n "$RAW_OUTPUT" ]]
  then
    if [[ -n "$ALL_MODEMS" ]]
    then
      local mids mid raw_items=()
      if mapfile -t mids < <(list_modem_ids_sorted)
      then
        for mid in "${mids[@]}"
        do
          [[ -z "$mid" ]] && continue
          local raw
          if raw="$(MODEM="$mid" mmcli_cmd -J)"
          then
            raw_items+=("$raw")
          fi
        done
      fi
      if (( ${#raw_items[@]} == 0 ))
      then
        printf '[\n]'
      else
        printf '%s
' "${raw_items[@]}" | jq -s '.'
      fi
    else
      printf '%s
' "$json" | jq
    fi
    return 0
  fi

  state="$(jq -r '(.modem.generic.state // empty)' <<<"$json")"
  power="$(jq -r '(.modem.generic["power-state"] // empty)' <<<"$json")"
  reg="$(jq -r '(.modem["3gpp"]["registration-state"] // empty)' <<<"$json")"
  signal="$(jq -r '(.modem.generic["signal-quality"].value // empty)' <<<"$json")"
  carrier="$(jq -r '(.modem["3gpp"]["operator-name"] // .modem["3gpp"]["operator-code"] // .modem.cdma.sid // empty)' <<<"$json")"
  own="$(jq -r '(.modem.generic["own-numbers"][0] // empty)' <<<"$json")"

  info_tsv="$(jq -r '
    def normalize_port:
      if . == null or . == "" then ""
      elif startswith("/") then .
      else "/dev/" + .
      end;

    (.modem.generic.ports // []) as $ports
    | [
        (.modem.generic.manufacturer // ""),
        (.modem.generic.model // ""),
        (.modem.generic.plugin // ""),
        ((.modem.generic["primary-port"] // "") | normalize_port),
        ($ports
          | map(split(" ")[0] | normalize_port)
          | map(select(. != ""))
          | join(", ")),
        ($ports
          | map(split(" ")[0] | normalize_port)
          | map(select(. != ""))
          | @json),
        ($ports
          | map(select(test("\\(at\\)"; "i")) | split(" ")[0] | normalize_port)
          | map(select(. != ""))
          | .[0] // "")
      ]
    | @tsv
  ' <<<"$json")"

  if [[ -n "$info_tsv" ]]
  then
    IFS=$'\t' read -r manufacturer model plugin primary_port ports_display ports_json at_port <<<"$info_tsv"
  fi

  if [[ -z "$ports_json" ]]
  then
    ports_json="[]"
  fi

  if [[ -z "$state" ]]
  then
    state=unknown
  fi
  if [[ -z "$power" ]]
  then
    power=unknown
  fi
  if [[ -z "$reg" ]]
  then
    reg=unknown
  fi
  if [[ -n "$signal" ]]
  then
    signal="${signal}%"
  else
    signal=unknown
  fi
  if [[ -z "$carrier" ]]
  then
    carrier=unknown
  fi
  own="$(ensure_plus "$own")"
  local own_for_country="$own"
  if [[ -z "$own" ]]
  then
    own=unknown
  else
    OWN_NUMBER="$own"
  fi

  if [[ "$own_for_country" == +* ]]
  then
    country_code="$(phone_cc "$own_for_country")"
    if [[ "$country_code" == "--" || -z "$country_code" ]]
    then
      country_code=""
    else
      country_label="$(cc_to_label "$country_code")"
      if [[ "$country_label" == "--" ]]
      then
        country_label=""
      fi
    fi
  fi

  if [[ -n "$country_code" ]]
  then
    if [[ -n "$country_label" && "$country_label" != "$country_code" ]]
    then
      country_display="$country_label (+$country_code)"
    else
      country_display="+$country_code"
    fi
  else
    country_display="unknown"
  fi

  local manufacturer_display="$manufacturer"
  [[ -n "$manufacturer_display" ]] || manufacturer_display="unknown"
  local model_display="$model"
  [[ -n "$model_display" ]] || model_display="unknown"
  local plugin_display="$plugin"
  [[ -n "$plugin_display" ]] || plugin_display="unknown"
  local primary_port_display="$primary_port"
  [[ -n "$primary_port_display" ]] || primary_port_display="unknown"
  local at_port_display_value="$at_port"
  [[ -n "$at_port_display_value" ]] || at_port_display_value="unknown"
  local ports_display_pretty="$ports_display"
  [[ -n "$ports_display_pretty" ]] || ports_display_pretty="unknown"

  # Derive SMSC (may use OWN_NUMBER or config); do not fail hard if empty
  smsc="$(get_smsc_number)"
  if [[ -z "$smsc" ]]
  then
    smsc=unknown
  fi

  # JSON output if requested
  if [[ -n "$JSON_OUTPUT" ]]
  then
    local sig_num_json
    sig_num_json="$(jq -r '(.modem.generic["signal-quality"].value // empty)' <<<"$json")"
    local ports_json_arg="$ports_json"
    if [[ -z "$ports_json_arg" ]]
    then
      ports_json_arg="[]"
    fi
    jq -n \
      --arg mid "$mid_label" \
      --arg state "$state" \
      --arg power "$power" \
      --arg registered "$reg" \
      --arg carrier "$carrier" \
      --arg phone "$own" \
      --arg smsc "$smsc" \
      --arg sig "$sig_num_json" \
      --arg manufacturer "$manufacturer" \
      --arg model "$model" \
      --arg plugin "$plugin" \
      --arg primary "$primary_port" \
      --arg at_port "$at_port" \
      --arg country_code "$country_code" \
      --arg country_label "$country_label" \
      --argjson ports "$ports_json_arg" \
      '{
        modem_id: ($mid|tonumber?),
        state: $state,
        power: $power,
        registered: $registered,
        carrier: $carrier,
        phone: $phone,
        smsc: $smsc,
        signal: ($sig|tonumber?),
        manufacturer: (if $manufacturer == "" then null else $manufacturer end),
        model: (if $model == "" then null else $model end),
        plugin: (if $plugin == "" then null else $plugin end),
        primary_port: (if $primary == "" then null else $primary end),
        at_port: (if $at_port == "" then null else $at_port end),
        ports: $ports,
        country_code: (if $country_code == "" then null else ($country_code|tonumber?) end),
        country: (if $country_label == "" then null else $country_label end)
      }'
    return 0
  fi

  if [[ -z $QUIET ]]
  then
    # Color helpers (respect NO_COLOR and CRON)
    local _nocolor=""
    if [[ -n "$NO_COLOR" || -n "$CRON" ]]
    then
      _nocolor=1
    fi

    colorize() { # $1=colorcode, $2=text
      if [[ -n "$_nocolor" ]]
      then
        printf '%s' "$2"
      else
        printf '\e[%sm%s\e[0m' "$1" "$2"
      fi
    }

    # Choose colors
    local state_color power_color reg_color sig_color carrier_color phone_color smsc_color info_color country_color
    case "${state,,}" in
      connected|registered|enabled|online|on) state_color='1;32';;   # bold green
      searching|initializing|connecting|locked|unknown) state_color='1;33';; # bold yellow
      failed|disabled|off) state_color='1;31';;                      # bold red
      *) state_color='36';;                                          # cyan
    esac

    case "${power,,}" in
      on|full) power_color='1;32';;
      low) power_color='1;33';;
      off|unknown) power_color='1;31';;
      *) power_color='36';;
    esac

    case "${reg,,}" in
      home|roaming|registered|attached) reg_color='1;32';;
      searching|idle|unknown) reg_color='1;33';;
      denied|unregistered) reg_color='1;31';;
      *) reg_color='36';;
    esac

    # Determine signal color based on numeric value when available
    local sig_num
    sig_num="$(jq -r '(.modem.generic["signal-quality"].value // empty)' <<<"$json")"
    if [[ "$sig_num" =~ ^[0-9]+$ ]]
    then
      if (( sig_num >= 70 ))
      then
        sig_color='1;32'
      elif (( sig_num >= 40 ))
      then
        sig_color='1;33'
      else
        sig_color='1;31'
      fi
    else
      sig_color='36'
    fi

    carrier_color='1;34' # bold blue
    phone_color='1;34'
    smsc_color='1;34'
    info_color='1;34'
    country_color="$phone_color"


    printf 'modem id: %s\n' "$(colorize "$state_color" "$mid_label")"
    printf 'modem state: %s\n' "$(colorize "$state_color" "$state")"
    printf 'power: %s\n' "$(colorize "$power_color" "$power")"
    printf 'registered: %s\n' "$(colorize "$reg_color" "$reg")"
    printf 'signal: %s\n' "$(colorize "$sig_color" "$signal")"
    printf 'carrier: %s\n' "$(colorize "$carrier_color" "$carrier")"
    printf 'phone: %s\n' "$(colorize "$phone_color" "$own")"
    printf 'smsc: %s\n' "$(colorize "$smsc_color" "$smsc")"
    printf 'manufacturer: %s\n' "$(colorize "$info_color" "$manufacturer_display")"
    printf 'model: %s\n' "$(colorize "$info_color" "$model_display")"
    printf 'plugin: %s\n' "$(colorize "$info_color" "$plugin_display")"
    printf 'primary port: %s\n' "$(colorize "$info_color" "$primary_port_display")"
    printf 'at port: %s\n' "$(colorize "$info_color" "$at_port_display_value")"
    printf 'ports: %s\n' "$(colorize "$info_color" "$ports_display_pretty")"
    printf 'country: %s\n' "$(colorize "$country_color" "$country_display")"
  fi

  return 0
}

modem_status() {
  local target_mid="${1:-}"

  if [[ -z "$target_mid" && -n "$ALL_MODEMS" ]]
  then
    local mids mid
    if ! mapfile -t mids < <(list_modem_ids_sorted)
    then
      echo_error "failed to list modems"
      return 1
    fi
    if (( ${#mids[@]} == 0 ))
    then
      if [[ -n "$JSON_OUTPUT$RAW_OUTPUT" ]]
      then
        printf '[]\n'
      else
        echo_info "no modems detected"
      fi
      return 0
    fi

    if [[ -n "$JSON_OUTPUT$RAW_OUTPUT" ]]
    then
      local json_items=() item
      for mid in "${mids[@]}"
      do
        [[ -z "$mid" ]] && continue
        item="$(MODEM="$mid" ALL_MODEMS="" modem_status_single)"
        [[ -n "$item" ]] && json_items+=("$item")
      done
      if (( ${#json_items[@]} == 0 ))
      then
        printf '[]\n'
      else
        printf '%s\n' "${json_items[@]}" | jq -s '.'
      fi
      return 0
    fi

    local first=1
    for mid in "${mids[@]}"
    do
      [[ -z "$mid" ]] && continue
      (( first )) || printf '\n'
      first=0
      echo_info "modem $mid:"
      MODEM="$mid" ALL_MODEMS="" modem_status_single
    done
    return 0
  fi

  modem_status_single
}

modem_number() {
  if ! load_own_number
  then
    local load_rc=$?
    if (( load_rc == 1 ))
    then
      echo_error "could not query modem for own number"
    else
      echo_error "modem did not report own number"
    fi
    return 1
  fi

  if [[ -z "$OWN_NUMBER" ]]
  then
    echo_error "modem did not report own number"
    return 2
  fi

  printf '%s\n' "$OWN_NUMBER"
  return 0
}

watch_handle_sms() {
  local id="$1"
  local prefer_modem_id="${2:-}"
  # Ensure replies and operations use the modem that received the message
  # by shadowing MODEM locally for mmcli_cmd invocations.
  # shellcheck disable=SC2031
  local MODEM="$MODEM"
  if [[ -n "$prefer_modem_id" ]]
  then
    MODEM="$prefer_modem_id"
  else
    echo_warning "no modem hint for SMS $id; defaulting to any"
    MODEM="any"
  fi
  local tries=0
  local js state pdu sender text payload

  while :
  do
    if ! js="$(mmcli_cmd --sms "$id" -J)"
    then
      return
    fi

    state="$(jq -r '.sms.properties.state // empty' <<<"$js")"
    pdu="$(jq -r '.sms.properties."pdu-type" // empty' <<<"$js")"
    sender="$(jq -r '.sms.content.number // empty' <<<"$js")"
    text="$(jq -r '.sms.content.text // empty' <<<"$js")"

    if [[ "$state" != "received" && "$pdu" != "deliver" ]]
    then
      echo_info "ignore id=$id (state=$state pdu=$pdu)"
      return
    fi

    if [[ -n "$OWN_NUMBER" && "$sender" == "$OWN_NUMBER" ]]
    then
      echo_info "skip self-sent id=$id"
      return
    fi

    if [[ -z "$text" && $tries -lt $SMS_RETRY_COUNT ]]
    then
      tries=$((tries + 1))
      sleep "$WATCH_RETRY_SLEEP"
      continue
    fi

    # Determine recipient (SIM MSISDN) for the modem that received the SMS
    # Prefer querying the current modem directly to avoid cross-modem mixups.
    local recipient=""
    local om_json
    if om_json="$(mmcli_cmd -J)"
    then
      recipient="$(jq -r '.modem.generic["own-numbers"][0] // empty' <<<"$om_json")"
      recipient="$(ensure_plus "$recipient")"
    fi

    local log_text
    log_text="$(abbrev_text_for_log "$text")"
    local log_recipient="$recipient"
    if [[ -z "$log_recipient" ]]
    then
      log_recipient="--"
    fi
    local sender_cc
    sender_cc="$(phone_cc_label "$sender")"
    echo_info "received message={id='$id' sender='$sender' (cc='$sender_cc') recipient='$log_recipient' text='$log_text'}"

    local sender_whitelisted
    if watch_in_whitelist "$sender"
    then
      sender_whitelisted=1
    fi

    local handled=0
    if [[ "$text" == "!"* ]]
    then
      if [[ -n $sender_whitelisted ]]
      then
        local cmd="${text#!}"
        # remove leading ws
        cmd=$(sed -E 's/^[[:space:]]+//' <<< "$cmd")

        if [[ -z "$cmd" ]]
        then
          watch_send_reply "$sender" "ERR: empty command"
        else
          echo_info "executing command from $sender: $cmd"
          local output
          output="$(watch_run_command "$cmd")"
          echo_info "command from $sender finished rc=$WATCH_CMD_RC"
          # Before sending our reply, prune already-sent messages on this modem
          sms_prune_sent || echo_warning "failed to prune sent SMS before reply"
          watch_send_reply "$sender" "rc=${WATCH_CMD_RC}\n${output}"
        fi

        handled=1
      else
        echo_info "command from $sender ignored (not whitelisted)"
      fi
    fi

    if (( handled == 0 ))
    then
      payload="$(jq -n \
        --arg recipient "$recipient" \
        --arg sender "$sender" \
        --arg text "$text" \
        --arg date "$(date -Iseconds)" \
        '{recipient:$recipient, sender:$sender, text:$text, date: $date}')"
      echo_info "forwarding id=$id from $sender to webhook"
      local resp rc code body log_body
      resp="$(curl -sS -m 10 -H 'Content-Type: application/json' -w $'\n%{http_code}' \
        -X POST -d "$payload" "$WEBHOOK_URL" 2>&1)"
      rc=$?
      if (( rc != 0 ))
      then
        log_body="$(abbrev_text_for_log "$resp")"
        echo_warning "webhook delivery error rc='$rc' output='$log_body'"
      else
        code="${resp##*$'\n'}"
        body="${resp%$'\n'*}"

        if [[ "$code" =~ ^[0-9]{3}$ ]]
        then
          log_body="$(abbrev_text_for_log "$body")"
        else
          code="n/a"
          log_body="$(abbrev_text_for_log "$resp")"
        fi

        if [[ "$code" =~ ^2 ]]
        then
          echo_info "webhook response code='$code' body='$log_body'"
        else
          echo_warning "webhook response code='$code' body='$log_body'"
        fi
      fi
    fi

    if (( WATCH_DELETE_AFTER == 1 ))
    then
      if ! mmcli_cmd --messaging-delete-sms="$id" >/dev/null
      then
        echo_warning "failed to delete processed SMS $id"
      else
        echo_info "deleted processed SMS $id"
      fi
    fi
    return
  done
}

watch_messages() {
  export PATH="/usr/local/bin:/srv/bin:$PATH"
  trap watch_cleanup EXIT INT TERM

  WATCH_FIFO="${TMPDIR:-/tmp}/smsbus.$$"
  mkfifo "$WATCH_FIFO"

  local filter="type='signal',interface='org.freedesktop.ModemManager1.Modem.Messaging',member='Added'"
  dbus-monitor --system "$filter" >"$WATCH_FIFO" &
  WATCH_DBUS_PID=$!

  if load_own_number
  then
    if [[ -n "$OWN_NUMBER" ]]
    then
      echo_info "own number = $OWN_NUMBER"
    fi
  else
    local load_rc=$?
    if (( load_rc == 1 ))
    then
      echo_warning "could not query modem for own number"
    else
      echo_warning "modem did not report own number"
    fi
  fi

  if [[ -n "$WATCH_PRUNE" ]]
  then
    if ! sms_prune_all_modems
    then
      echo_warning "failed to prune existing SMS messages on all modems"
    fi
  fi

  if [[ -n "$WATCH_ENABLE" ]]
  then
    if [[ -n "$ALL_MODEMS" ]]
    then
      enable_all_modems || echo_warning "failed to enable all modems"
    else
      enable_modem "$MODEM" || echo_warning "failed to enable modem"
    fi
    watch_start_enable_monitor
  fi

  local current_modem_id=""
  while IFS= read -r line
  do
    # Track the modem id from the signal's path
    if [[ "$line" =~ /org/freedesktop/ModemManager1/Modem/([0-9]+) ]]
    then
      current_modem_id="${BASH_REMATCH[1]}"
    fi

    if [[ "$line" == *"/org/freedesktop/ModemManager1/SMS/"* ]]
    then
      local local_path="${line#*\"}"
      local_path="${local_path%%\"*}"
      local id="${local_path##*/}"
      if [[ "$id" =~ ^[0-9]+$ ]]
      then
        # If not listening on all, ignore messages from other modems
        if [[ -z "$ALL_MODEMS" && -n "$current_modem_id" && "$current_modem_id" != "$MODEM" ]]
        then
          echo_warning "ignoring SMS $id from modem $current_modem_id (listening on $MODEM)"
          continue
        fi
        watch_handle_sms "$id" "$current_modem_id"
      fi
    fi
  done <"$WATCH_FIFO"
}

command_requires_modem_resolution() {
  local cmd="$1"

  case "$cmd" in
    logs|service)
      return 1
      ;;
  esac

  return 0
}

resolve_modem_selection() {
  local cmd="$1"

  if [[ -n "$DEFAULT_MODEM" ]]
  then
    echo_debug "default modem configured: $DEFAULT_MODEM"
  fi

  if [[ -z "$ALL_MODEMS" && -z "$MODEM_EXPLICIT" && -n "$DEFAULT_MODEM" ]]
  then
    MODEM="$DEFAULT_MODEM"
    echo_debug "using default modem $MODEM"
  fi

  local resolved
  if ! resolved="$(get_modem_id "$MODEM")"
  then
    # get_modem_id already printed context and list
    return 2
  fi

  MODEM="$resolved"

  if [[ "$MODEM" == "any" ]]
  then
    local _j _id
    if _j="$(mmcli_cmd -J)"
    then
      _id="$(jq -r '.modem["dbus-path"] | split("/")[-1] // empty' <<<"$_j")"
      if [[ -n "$_id" ]]
      then
        MODEM="$_id"
      fi
    fi
  fi

  if [[ -n $QUIET ]]
  then
    [[ -n $MODEM ]]
    return "$?"
  fi

  if [[ "$cmd" == "watch" && -n "$ALL_MODEMS" ]]
  then
    local _ids=()
    local _id
    if mapfile -t _ids < <(list_modem_ids_sorted)
    then
      echo_info "listening on all modems: ${#_ids[@]} detected"
      for _id in "${_ids[@]}"
      do
        [[ -z "$_id" ]] && continue
        log_modem_details "$_id"
      done
      MODEM_DETAILS_LOGGED=1
    else
      echo_info "listening on all modems"
    fi
    return 0
  fi

  if [[ -n "$ALL_MODEMS" ]]
  then
    local _ids=()
    local _id
    if mapfile -t _ids < <(list_modem_ids_sorted)
    then
      if (( ${#_ids[@]} > 0 ))
      then
        echo_info "operating on all modems: ${#_ids[@]} detected"
        for _id in "${_ids[@]}"
        do
          [[ -z "$_id" ]] && continue
          log_modem_details "$_id"
        done
        MODEM_DETAILS_LOGGED=1
      else
        echo_info "operating on all modems: none detected"
      fi
    else
      echo_info "operating on all modems"
    fi
  elif [[ -n "$MODEM" && "$MODEM" != "any" ]]
  then
    log_modem_details "$MODEM" "selected "
  else
    local _info
    _info="$(modem_info_brief)"
    if [[ -n "$_info" && "$_info" != "$MODEM" ]]
    then
      echo_info "selected modem={$_info}"
    elif [[ "$MODEM" != "any" && -n "$MODEM" ]]
    then
      echo_info "selected modem={id='$MODEM'}"
    else
      echo_info "selected modem: any"
    fi
  fi

  return 0
}

main() {
  local command=""
  local -a PRE_ARGS=()
  local -a ARGS=()
  local -a DEBUG_FLAGS=()

  while (( $# > 0 ))
  do
    case "$1" in
      -m|--modem)
        if (( $# < 2 ))
        then
          echo_error "missing value for $1"
          return 2
        fi
        DEBUG_FLAGS+=("$1=$2")
        MODEM="$2"
        MODEM_EXPLICIT=1
        shift 2
        continue
        ;;
      -d|--debug)
        DEBUG_FLAGS+=("$1")
        # shellcheck disable=SC2034
        DEBUG=1
        shift
        continue
        ;;
      -q|--quiet|--silent)
        DEBUG_FLAGS+=("$1")
        QUIET=1
        shift
        continue
        ;;
      -x|--trace)
        DEBUG_FLAGS+=("$1")
        PS4='+ [${BASH_SOURCE##*/}:${LINENO}] ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
        set -x
        shift
        continue
        ;;
      -s|--syslog)
        DEBUG_FLAGS+=("$1")
        # shellcheck disable=SC2034
        ECHO_SYSLOG=1
        shift
        continue
        ;;
      -c|--config)
        if (( $# < 2 ))
        then
          echo_error "missing value for $1"
          return 2
        fi
        DEBUG_FLAGS+=("$1=$2")
        CONFIG_FILE="$2"
        shift 2
        continue
        ;;
      -h|--help)
        usage
        return 0
        ;;
      --)
        shift
        break
        ;;
      *)
        if [[ -z "$command" ]] && is_command_token "$1"
        then
          command="$1"
          shift
          break
        fi
        PRE_ARGS+=("$1")
        shift
        ;;
    esac
  done

  if [[ -z "$command" && $# -gt 0 ]]
  then
    command="$1"
    shift
  fi

  ARGS=("${PRE_ARGS[@]}")
  if (( $# > 0 ))
  then
    ARGS+=("$@")
  fi

  if [[ -z "$command" ]]
  then
    command="status"
  fi

  case "$command" in
    at|ati)
      command="at"
      ;;
    send|s)
      command="send"
      ;;
    list|ls|l|-l)
      command="list"
      ;;
    log*)
      command="logs"
      ;;
    read|get|r)
      command="read"
      ;;
    prune|clear|delete)
      command="prune"
      ;;
    -e|*enable*|en|start)
      command="enable"
      ;;
    status|stat|st)
      command="status"
      ;;
    number|phone)
      command="number"
      ;;
    reset|rst)
      command="reset"
      ;;
    service|svc)
      command="service"
      ;;
    watch|w)
      command="watch"
      ;;
    smsc)
      command="smsc"
      ;;
    help)
      local topic="${ARGS[0]:-}"
      if [[ -z "$topic" ]]
      then
        usage
      else
        case "$topic" in
          at|ati) topic="at" ;;
          en|enable|start) topic="enable" ;;
          log*) topic="logs" ;;
          l|ls|list) topic="list" ;;
          number|phone) topic="number" ;;
          rst|reset|restart) topic="reset" ;;
          r|get|read) topic="read" ;;
          service|svc) topic="service" ;;
          smsc) topic="smsc" ;;
          st|stat|status) topic="status" ;;
          s|send) topic="send" ;;
          w|watch) topic="watch" ;;
        esac

        print_subcommand_usage "$topic"
      fi
      return 0
      ;;
  esac

  if [[ "$command" == -* ]]
  then
    echo_error "unknown option: $command"
    usage >&2
    return 2
  fi

  parse_command_args "$command" "${ARGS[@]}"
  local parse_rc=$?
  if (( parse_rc == 64 ))
  then
    return 0
  elif (( parse_rc != 0 ))
  then
    return $parse_rc
  fi

  local -a CMD_ARGS=("${PARSED_ARGS[@]}")

  if ! load_config post-args
  then
    return $?
  fi

  if command_requires_modem_resolution "$command"
  then
    local resolve_rc
    resolve_modem_selection "$command"
    resolve_rc=$?
    if (( resolve_rc != 0 ))
    then
      return "$resolve_rc"
    fi
  fi

  local dbg_args="" dbg_flags=""
  if (( ${#DEBUG_FLAGS[@]} > 0 ))
  then
    local dbg_flags_str
    printf -v dbg_flags_str '%q ' "${DEBUG_FLAGS[@]}"
    dbg_flags=" flags=${dbg_flags_str%% }"
  fi
  if (( ${#CMD_ARGS[@]} > 0 ))
  then
    local dbg_args_str
    printf -v dbg_args_str '%q ' "${CMD_ARGS[@]}"
    dbg_args=" args=${dbg_args_str%% }"
  fi
  echo_debug "command=$command${dbg_flags}${dbg_args}"

  case "$command" in
    at)
      if [[ -n ${CMD_ARGS[0]} ]]
      then
        at_command "${CMD_ARGS[@]}"
      else
        echo_info "Starting interactive AT command session (exit with Ctrl-D)"
        at_command_interactive
      fi
      ;;
    send)
      if [[ -n "$FALLBACK" ]]
      then
        if ! sms_send_with_fallback "${CMD_ARGS[@]}"
        then
          return 1
        fi
      else
        if ! sms_send "${CMD_ARGS[@]}"
        then
          echo_warning "send failed. fallback disabled, not trying other modems"
          return 1
        fi
      fi
      ;;
    list)
      sms_list_pretty
      ;;
    logs)
      mmsms_logread "${CMD_ARGS[@]}"
      ;;
    read)
      if (( ${#CMD_ARGS[@]} < 1 ))
      then
        echo_error "No SMS ID/path specified"
        # Show the message list in the same pretty/JSON/raw style
        sms_list_pretty || echo_error "failed to list SMS messages"
        return 1
      fi
      if [[ -n "$RAW_OUTPUT" ]]
      then
        mmcli_cmd --sms "${CMD_ARGS[0]}" -J | jq -e
      elif [[ -n "$JSON_OUTPUT" ]]
      then
        sms_read_json "${CMD_ARGS[0]}"
      else
        sms_read "${CMD_ARGS[@]}"
      fi
      ;;
    service)
      mmsms_service_action "${CMD_ARGS[@]}"
      ;;
    prune)
      if [[ -n "$SENT_ONLY" && -n "$ALL_MODEMS" ]]
      then
        sms_prune_sent_modems
      elif [[ -n "$SENT_ONLY" ]]
      then
        sms_prune_sent
      elif [[ -n "$ALL_MODEMS" ]]
      then
        sms_prune_all_modems
      else
        sms_prune_all
      fi
      ;;
    enable)
      if [[ -n "$ALL_MODEMS" ]]
      then
        enable_all_modems
      else
        enable_modem "$MODEM"
      fi
      ;;
    status)
      modem_status "${CMD_ARGS[@]}"
      ;;
    number)
      modem_number
      ;;
    smsc)
      local smsc
      smsc="$(get_smsc_number)"
      printf "%s\n" "$smsc"
      ;;
    reset)
      if [[ -n "$ALL_MODEMS" ]]
      then
        modem_reset_all
      else
        modem_reset
      fi
      ;;
    watch)
      # Config already sourced earlier; ensure whitelist is populated
      if (( ${#SMS_WHITELIST[@]} == 0 ))
      then
        echo_error "watch requires at least one whitelisted number (SMS_WHITELIST)"
        return 2
      fi
      watch_messages
      ;;
    *)
      echo_error "unknown command: $command"
      usage >&2
      return 2
      ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "$0" ]]
then
  main "$@"
fi
