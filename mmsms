#!/usr/bin/env bash

set -euo pipefail

SCRIPT_NAME="$(basename "${BASH_SOURCE[0]}")"

cd "$(dirname "$(readlink -f "$0")")" || return 9

# shellcheck source=lib/echo.sh
source lib/echo.sh || exit 2

CONFIG_FILE="${CONFIG_FILE:-/etc/mmsms.conf}"
# source configuration file
# shellcheck disable=SC1090
if ! source "$CONFIG_FILE"
then
  echo_error "$SCRIPT_NAME: could not read configuration file $CONFIG_FILE"
  exit 2
fi

MODEM="${MODEM:-any}"
OWN_NUMBER="${OWN_NUMBER:-}"
SMSC_NUMBER="${SMSC_NUMBER:-}"
SMS_SEND_TIMEOUT="${SMS_SEND_TIMEOUT:-30}"
SMS_SEND_RETRY_COUNT="${SMS_SEND_RETRY_COUNT:-2}"
CMD_OUTPUT_MAX_LEN="${CMD_OUTPUT_MAX_LEN:-4000}"

WEBHOOK_URL="${WEBHOOK_URL:-}"
WATCH_DELETE_AFTER="${DELETE_AFTER:-1}"
WATCH_MAX_RETRY="${MAX_RETRY:-3}"
WATCH_RETRY_SLEEP="${RETRY_SLEEP:-1}"
WATCH_CMD_TIMEOUT="${CMD_TIMEOUT:-8}"
WATCH_CMD_KILL_TIMEOUT="${WATCH_CMD_KILL_TIMEOUT:-${CMD_KILL_TIMEOUT:-20}}"

QUIET="${QUIET:-}"
JSON_OUTPUT="${JSON_OUTPUT:-}"
RAW_OUTPUT="${RAW_OUTPUT:-}"
HARD_RESET="${HARD_RESET:-}"
ALL_MODEMS="${ALL_MODEMS:-}"
SENT_ONLY="${SENT_ONLY:-}"
ALLOW_FOREIGN="${ALLOW_FOREIGN:-}"
HOME_CC="${HOME_CC:-}"

# Ensure SMS_WHITELIST is defined as an array if provided by the config
if ! declare -p SMS_WHITELIST >/dev/null 2>&1
then
  SMS_WHITELIST=()
fi

# Allow overriding the whitelist via SMS_WHITELIST_OVERRIDE (comma or space separated digits)
if [[ -n "${SMS_WHITELIST_OVERRIDE:-}" ]]
then
  # shellcheck disable=SC2206
  SMS_WHITELIST=( ${SMS_WHITELIST_OVERRIDE//,/ } )
else
  if (( ${#SMS_WHITELIST[@]} == 0 )) && declare -p SMS_WHITELIST_DEFAULT >/dev/null 2>&1
  then
    SMS_WHITELIST=("${SMS_WHITELIST_DEFAULT[@]}")
  fi
fi

WATCH_FIFO=""
WATCH_DBUS_PID=""
WATCH_CMD_RC=0
WATCH_CMD_REASON="exit"

usage() {
  cat <<USAGE
Usage: $SCRIPT_NAME [OPTIONS] COMMAND [ARGS]

Options:
  -m, --modem MODEM    Modem selector or id (default: $MODEM)
                       Accepts id (e.g. 2), dbus path, 'any', or
                       a string matching manufacturer/plugin/ttyUSB/phone-number
                       or country (fr/de/us) or country name (france/germany/us)
  -d, --debug          Enable debug output
  -j, --json           Output JSON (for list/status/read)
      --raw            List: output array of raw mmcli SMS objects; Read: raw mmcli JSON; Status: raw mmcli JSON
  -q, --quiet          Suppress info output (warnings/errors only)
      --silent         Same as --quiet
  -x, --trace          Enable shell tracing (set -x)
      --hard           Reset: also stop/start modemmanager (hard reset)
      --all            List/Prune/Enable/Reset: operate on all modems
      --sent           Prune: delete only sent outgoing messages
      --allow-foreign  Send: allow sending to foreign country codes
  -q, --quiet          Suppress status output (exit code only)
  -h, --help           Show this help and exit

Commands:
  send RECIPIENT [TEXT|-]   Send SMS; use '-' or stdin for TEXT
  list                      List SMS messages on the modem
  read MESSAGE_ID           Show details for a specific SMS
  prune                     Delete all SMS messages from the modem
  enable                    Wait for ModemManager and enable the modem
  status                    Show modem status summary
  restart                   Restart modemmanager, issue quectel reset, re-enable modem
  watch                     Monitor incoming SMS and forward/execute actions
  number|phone              Print modem's own phone number
  (default: status)
USAGE
}

error() {
  echo_error "$SCRIPT_NAME: $*"
}

# Map selector to a country calling code (digits) for a small set
# Supports: fr (France=33), de (Germany=49), us/usa (United States=1)
country_to_cc() {
  local s="${1,,}"
  case "$s" in
    fr|fra|france)
      printf '33'
      ;;
    de|deu|germany|deutschland)
      printf '49'
      ;;
    us|usa|"united states"|"united-states"|america)
      printf '1'
      ;;
    *)
      return 1
      ;;
  esac
}

# Determine the home country code for E.164 numbers
# Priority:
#  - HOME_CC if set (digits only, e.g., 49)
#  - Derive from OWN_NUMBER (heuristic: +1 -> 1, otherwise first two digits)
get_home_cc() {
  local cc=""
  if [[ -n "$HOME_CC" ]]
  then
    cc="${HOME_CC//[^0-9]/}"
    printf '%s' "$cc"
    return 0
  fi

  if [[ -z "$OWN_NUMBER" ]]
  then
    if ! load_own_number
    then
      return 1
    fi
  fi
  if [[ "$OWN_NUMBER" == +* ]]
  then
    local digits="${OWN_NUMBER#+}"
    # Heuristic: NANP +1, otherwise take first two digits
    if [[ "$digits" == 1* ]]
    then
      cc="1"
    else
      cc="${digits:0:2}"
    fi
    printf '%s' "$cc"
    return 0
  fi
  return 1
}

# Return a concise modem info string for logs: id=.. manufacturer=.. model=.. plugin=.. primary=..
modem_info_brief() {
  local j info id manufacturer model plugin primary
  if j="$(mmcli_cmd -J 2>/dev/null || true)"
  then
    id="$(jq -r '.modem["dbus-path"] | split("/")[-1] // empty' <<<"$j" 2>/dev/null)"
    manufacturer="$(jq -r '.modem.generic.manufacturer // "--"' <<<"$j" 2>/dev/null)"
    model="$(jq -r '.modem.generic.model // "--"' <<<"$j" 2>/dev/null)"
    plugin="$(jq -r '.modem.generic.plugin // "--"' <<<"$j" 2>/dev/null)"
    primary="$(jq -r '.modem.generic["primary-port"] // "--"' <<<"$j" 2>/dev/null)"
    if [[ -n "$id" ]]
    then
      info="id=$id manufacturer=$manufacturer model=$model plugin=$plugin primary=$primary"
      printf '%s' "$info"
      return 0
    fi
  fi
  printf '%s' "$MODEM"
}

# Send a line to the system log if `logger` is available
log_sys() {
  if command -v logger >/dev/null 2>&1
  then
    logger -t mmsms "$*"
  fi
}

# Run an AT command via mmcli and return the response string
# - Strips the leading "response: '...'") wrapper printed by mmcli
# - If no such wrapper is present, returns raw stdout/stderr as-is
at_command() {
  local cmd="$1"
  local out resp
  if ! out="$(mmcli_cmd --command="$cmd" 2>&1 || true)"
  then
    out=""
  fi
  resp="$(printf '%s\n' "$out" | sed -n "s/^response: '\(.*\)'$/\1/p" | head -n1)"
  if [[ -z "$resp" ]]
  then
    resp="$out"
  fi
  printf '%s' "$resp"
}

# Decode a UCS2 hex string like "002B0033..." by taking the low byte of each code unit
at_decode_ucs2() {
  local s="$1"
  if [[ "$s" =~ ^([0-9A-Fa-f]{4})+$ ]]
  then
    local out=""
    local pos=0 len=${#s} hb
    while (( pos < len ))
    do
      hb="${s:pos+2:2}"
      out+="$(printf '%b' "\\x$hb")"
      pos=$((pos + 4))
    done
    printf '%s' "$out"
    return 0
  fi
  printf '%s' "$s"
}

# Extract the first double-quoted field from an AT response and decode UCS2 if applicable
at_first_quoted_decoded() {
  local resp="$1"
  local q
  q="$(printf '%s\n' "$resp" | sed -n 's/^.*"\([^"]*\)".*$/\1/p' | head -n1)"
  if [[ -z "$q" ]]
  then
    return 1
  fi
  if [[ "$q" =~ ^([0-9A-Fa-f]{4})+$ ]]
  then
    q="$(at_decode_ucs2 "$q")"
  fi
  printf '%s' "$q"
}

# Log and run generic mmcli calls (no implicit --modem)
mmcli() {
  echo_debug "[mmcli] mmcli $*"
  command mmcli "$@"
}

# Resolve a human-friendly modem selector to a concrete modem id
# - Accepts: numeric id (e.g., 2), D-Bus path, 'any', or a substring
#   matching manufacturer, plugin, primary-port, or any ttyUSB/wwan port.
# - On multiple matches, prints a modem list to stderr and returns non-zero.
# - On no match, reports an error and shows the list.
get_modem_id() {
  local sel_raw="${1:-}"
  local sel

  # Default / passthrough cases
  if [[ -z "$sel_raw" || "$sel_raw" == any ]]
  then
    printf '%s' "any"
    return 0
  fi

  # If a D-Bus path (/org/.../Modem/N)
  if [[ "$sel_raw" == */Modem/* ]]
  then
    printf '%s' "${sel_raw##*/}"
    return 0
  fi

  # Case-insensitive substring match on fields (unless country filter applies)
  sel="${sel_raw,,}"

  local list_json ids id json
  if ! list_json="$(mmcli -L -J)"
  then
    error "could not query modem list via mmcli"
    return 1
  fi

  # Collect modem ids
  mapfile -t ids < <(jq -r '."modem-list"[]? | split("/")[-1]' <<<"$list_json" 2>/dev/null)
  if (( ${#ids[@]} == 0 ))
  then
    error "no modems detected"
    return 1
  fi

  # If pure numeric input, treat as id only if it matches a detected id; otherwise
  # continue with fuzzy matching (e.g., phone number fragment)
  if [[ "$sel_raw" =~ ^[0-9]+$ ]]
  then
    local _id
    for _id in "${ids[@]}"
    do
      if [[ "$_id" == "$sel_raw" ]]
      then
        printf '%s' "$sel_raw"
        return 0
      fi
    done
  fi

  local matches=()
  local cc_filter=""
  cc_filter="$(country_to_cc "$sel_raw" 2>/dev/null || true)"
  for id in "${ids[@]}"
  do
    [[ -z "$id" ]] && continue
    if ! json="$(mmcli -m "$id" -J)"
    then
      continue
    fi

    # Extract candidate fields and match
    local fields numbers sel_digits
    fields="$(jq -r '
      .modem.generic as $g
      | [
          ($g.manufacturer // ""),
          ($g.plugin // ""),
          ($g["primary-port"] // ""),
          (($g.ports // [])[]? | (split(" ")[0]))
        ] | .[]
    ' <<<"$json" 2>/dev/null || true)"
    numbers="$(jq -r '.modem.generic["own-numbers"][]? // empty' <<<"$json" 2>/dev/null || true)"
    sel_digits="${sel_raw//[^0-9+]/}"

    local matched=0
    if [[ -n "$cc_filter" && -n "$numbers" ]]
    then
      # Country code filter: match if any own-number starts with +<cc>
      local n
      while IFS= read -r n
      do
        [[ -z "$n" ]] && continue
        n="${n#+}"
        if [[ "$n" == "$cc_filter"* ]]
        then
          matched=1; break
        fi
      done <<< "$numbers"
    else
      # Generic substring/regex and number substring matching
      if [[ -n "$fields" ]]
      then
        local f lf
        while IFS= read -r f
        do
          lf="${f,,}"
          if [[ "$lf" == *"$sel"* ]]
          then
            matched=1; break
          fi
        done <<< "$fields"
      fi

      if (( matched == 0 )) && [[ -n "$numbers" ]]
      then
        local n nd
        while IFS= read -r n
        do
          [[ -z "$n" ]] && continue
          nd="${n//[^0-9+]/}"
          if [[ "${n,,}" == *"${sel_raw,,}"* ]] || { [[ -n "$sel_digits" ]] && [[ "$nd" == *"$sel_digits"* ]]; }
          then
            matched=1; break
          fi
          if printf '%s\n' "$n" | grep -Eq -- "$sel_raw" 2>/dev/null
          then
            matched=1; break
          fi
        done <<< "$numbers"
      fi
    fi

    if (( matched == 1 ))
    then
      matches+=("$id")
    fi
  done

  if (( ${#matches[@]} == 1 ))
  then
    printf '%s' "${matches[0]}"
    return 0
  fi

  # Helper to show available modems for disambiguation
  echo_error "${SCRIPT_NAME}: modem selector '${sel_raw}' matched ${#matches[@]} modem(s)" >&2
  echo_info "Available modems:" >&2
  for id in "${ids[@]}"
  do
    [[ -z "$id" ]] && continue
    if ! json="$(mmcli -m "$id" -J)"
    then
      continue
    fi
    jq -r '
      .modem as $m
      | {
          id: ($m["dbus-path"] | split("/")[-1]),
          manufacturer: ($m.generic.manufacturer // "--"),
          model: ($m.generic.model // "--"),
          plugin: ($m.generic.plugin // "--"),
          primary: ($m.generic["primary-port"] // "--"),
          ports: (($m.generic.ports // []) | map(split(" ")[0]) | join(","))
        }
      | ("  " + .id + ": " + .manufacturer + " " + .model
         + " plugin=" + .plugin
         + " primary=" + .primary
         + " ports=" + .ports)
    ' <<<"$json" >&2
  done

  if (( ${#matches[@]} == 0 ))
  then
    return 1
  fi

  # Ambiguous
  return 2
}

mmcli_cmd() {
  echo_debug "[mmcli] mmcli --modem $MODEM $*"
  command mmcli --modem "$MODEM" "$@"
}

sms_read() {
  local msg_id="$1"
  mmcli_cmd --sms "$msg_id"
}

sms_read_json() {
  local msg_id="$1"
  local js pdu msg_type own=""
  if ! js="$(mmcli_cmd --sms "$msg_id" -J)"
  then
    return 1
  fi

  pdu="$(jq -r '.sms.properties["pdu-type"] // ""' <<<"$js" 2>/dev/null)"
  case "${pdu,,}" in
    deliver) msg_type="received" ;;
    submit) msg_type="sent" ;;
    status-report) msg_type="report" ;;
    *) msg_type="$pdu" ;;
  esac

  if load_own_number
  then
    own="$OWN_NUMBER"
  fi

  jq --arg type "$msg_type" --arg own "$own" '
    .sms as $s
    | {
        id: ($s["dbus-path"] | split("/")[-1] | tonumber?),
        sender: ($s.content.number // ""),
        text: ($s.content.text // ""),
        class: ($s.properties.class // ""),
        state: ($s.properties.state // ""),
        pdu: ($s.properties["pdu-type"] // ""),
        storage: ($s.properties.storage // ""),
        smsc: ($s.properties.smsc // ""),
        timestamp: ($s.properties.timestamp // ""),
        discharge_timestamp: ($s.properties["discharge-timestamp"] // ""),
        delivery_state: ($s.properties["delivery-state"] // ""),
        delivery_report: ($s.properties["delivery-report"] // ""),
        type: $type,
        recipient: (if $type == "received" then $own else ($s.content.number // "") end)
      }
  ' <<<"$js" 2>/dev/null
}

sms_send() {
  if [[ $# -lt 2 ]]
  then
    usage >&2
    return 2
  fi

  local recipient="$1"
  shift
  local text

  recipient="${recipient//[[:space:]]/}"
  if [[ -n "$recipient" && "$recipient" != +* ]]
  then
    recipient="+$recipient"
  fi

  # Enforce local-only sending unless --allow-foreign is set
  if [[ -z "$ALLOW_FOREIGN" ]]
  then
    local home_cc
    home_cc="$(get_home_cc || true)"
    if [[ -n "$home_cc" && "$recipient" == +([0-9]) ]]
    then
      if [[ "$recipient" != +"$home_cc"* ]]
      then
        echo_warning "blocking foreign recipient $recipient (home CC=$home_cc); use --allow-foreign to override or set HOME_CC"
        return 2
      fi
    fi
  fi

  if (( $# == 0 ))
  then
    text="$(cat)"
  elif [[ "$1" == "-" ]]
  then
    shift
    text="$(cat)"
  else
    text="$*"
  fi

  if [[ -z "$text" ]]
  then
    error "no SMS text provided"
    return 2
  fi

  # Log outgoing SMS (preview) to stderr and syslog
  printf 'text=%q\n' "$text" >&2
  local log_text
  log_text="$text"
  log_text=${log_text//$'\r'/}
  log_text=${log_text//$'\n'/\\n}
  log_text=${log_text//\\/\\\\}
  if [[ -z "$log_text" ]]
  then
    log_text="<empty>"
  elif (( ${#log_text} > 200 ))
  then
    log_text="${log_text:0:200}..."
  fi
  local log_modem
  log_modem="$(modem_info_brief)"
  echo_info "sending sms modem=$log_modem to $recipient text='$log_text'"
  log_sys "sending sms modem=$log_modem to $recipient text='$log_text'"

  # DIRTYFIX For Home Assistant SMS notifications
  text="$(echo -e "$text")"

  local tmpfile
  if ! tmpfile="$(mktemp "${TMPDIR:-/tmp}/mmsms-text.XXXXXX")"
  then
    error "failed to create temporary file for SMS text"
    return 1
  fi

  if ! printf '%s' "$text" >"$tmpfile"
  then
    rm -f "$tmpfile" 2>/dev/null || true
    error "failed to write SMS text to temporary file"
    return 1
  fi

  local sms_id=""
  local smsc_raw
  local smsc
  local smsc_params=""
  smsc_raw="$(get_smsc_number)"
  if [[ -n "$smsc_raw" ]]
  then
    smsc="${smsc_raw//[[:space:]]/}"
    if [[ -n "$smsc" && "$smsc" != +* ]]
    then
      smsc="+$smsc"
    fi
    if [[ -n "$smsc" && "$smsc" =~ ^\+[0-9]+$ ]]
    then
      smsc_params=",smsc=$smsc"
    elif [[ -n "$smsc_raw" ]]
    then
      echo_warning "invalid smsc '$smsc_raw', skipping"
      smsc=""
    fi
  fi
  local attempt=1
  local max_attempts=$((SMS_SEND_RETRY_COUNT + 1))
  local rc=1

  while (( attempt <= max_attempts ))
  do
    sms_id=""
    local create_json
    create_json=""
    if ! create_json="$(mmcli_cmd -J --messaging-create-sms="number=${recipient}${smsc_params}" \
      --messaging-create-sms-with-text="$tmpfile")"
    then
      if (( attempt == max_attempts ))
      then
        error "failed to create SMS after $max_attempts attempts"
        break
      fi
      echo_warning "failed to create SMS (attempt $attempt/$max_attempts), retrying"
      attempt=$((attempt + 1))
      continue
    fi

    if ! sms_id="$(jq -r '.modem.messaging["created-sms"] // empty' <<<"$create_json" 2>/dev/null)"
    then
      sms_id=""
    fi

    if [[ -z "$sms_id" ]]
    then
      if (( attempt == max_attempts ))
      then
        error "failed to create SMS after $max_attempts attempts"
        break
      fi
      echo_warning "received empty SMS id (attempt $attempt/$max_attempts), retrying"
      attempt=$((attempt + 1))
      continue
    fi

    if mmcli_cmd --sms "$sms_id" --send --timeout="$SMS_SEND_TIMEOUT"
    then
      rc=0
      break
    fi

    if (( attempt == max_attempts ))
    then
      error "failed to send SMS after $max_attempts attempts"
      break
    fi

    echo_warning "failed to send SMS (attempt $attempt/$max_attempts), retrying"
    attempt=$((attempt + 1))
  done

  rm -f "$tmpfile" 2>/dev/null || true
  return $rc
}

sms_prune_all() {
  local ids
  if ! ids="$(mmcli_cmd --messaging-list-sms -J | \
    jq -er '."modem.messaging.sms"[]? | split("/")[-1]' 2>/dev/null)"
  then
    return 0
  fi

  if [[ -z "$ids" ]]
  then
    return 0
  fi

  while IFS= read -r sms_id
  do
    [[ -z "$sms_id" ]] && continue
    echo_info "deleting SMS $sms_id"
    if ! mmcli_cmd --messaging-delete-sms="$sms_id"
    then
      error "failed to delete SMS $sms_id"
    fi
  done <<< "$ids"
}

sms_prune_sent() {
  # Delete only messages that are outgoing and already sent
  local list ids id js state pdu
  if ! list="$(mmcli_cmd --messaging-list-sms -J 2>/dev/null)"
  then
    return 0
  fi
  mapfile -t ids < <(jq -r '."modem.messaging.sms"[]? | split("/")[-1]' <<<"$list" 2>/dev/null)
  if (( ${#ids[@]} == 0 ))
  then
    return 0
  fi
  for id in "${ids[@]}"
  do
    [[ -z "$id" ]] && continue
    if ! js="$(mmcli_cmd --sms "$id" -J 2>/dev/null)"
    then
      continue
    fi
    state="$(jq -r '.sms.properties.state // empty' <<<"$js" 2>/dev/null)"
    pdu="$(jq -r '.sms.properties["pdu-type"] // empty' <<<"$js" 2>/dev/null)"
    if [[ "$state" == "sent" && "$pdu" == "submit" ]]
    then
      echo_info "deleting sent SMS $id"
      mmcli_cmd --messaging-delete-sms="$id" >/dev/null 2>&1 || true
    fi
  done
}

sms_prune_sent_modems() {
  local list_json mids mid
  if ! list_json="$(mmcli -L -J)"
  then
    error "failed to list modems for pruning"
    return 1
  fi
  mapfile -t mids < <(jq -r '."modem-list"[]? | split("/")[-1]' <<<"$list_json" 2>/dev/null)
  if (( ${#mids[@]} == 0 ))
  then
    echo_info "no modems detected"
    return 0
  fi
  for mid in "${mids[@]}"
  do
    [[ -z "$mid" ]] && continue
    echo_info "pruning sent messages on modem $mid"
    (
      local MODEM="$mid"
      sms_prune_sent || error "failed to prune sent messages on modem $mid"
    )
  done
}

sms_prune_all_modems() {
  local list_json mids mid
  if ! list_json="$(mmcli -L -J)"
  then
    error "failed to list modems for pruning"
    return 1
  fi
  mapfile -t mids < <(jq -r '."modem-list"[]? | split("/")[-1]' <<<"$list_json" 2>/dev/null)
  if (( ${#mids[@]} == 0 ))
  then
    echo_info "no modems detected"
    return 0
  fi
  for mid in "${mids[@]}"
  do
    [[ -z "$mid" ]] && continue
    echo_info "pruning modem $mid"
    (
      local MODEM="$mid"
      sms_prune_all || error "failed to prune on modem $mid"
    )
  done
}

sms_list_pretty() {
  local list_json ids id js sender text msg_type pdu line maxlen=80

  # When listing for all modems, iterate them explicitly
  if [[ -n "$ALL_MODEMS" ]]
  then
    local mids mid had_any=""
    if ! list_json="$(mmcli -L -J)"
    then
      error "failed to list modems"
      return 1
    fi
    mapfile -t mids < <(jq -r '."modem-list"[]? | split("/")[-1]' <<<"$list_json" 2>/dev/null)
    if (( ${#mids[@]} == 0 ))
    then
      if [[ -n "$JSON_OUTPUT$RAW_OUTPUT" ]]
      then
        printf '[]\n'
      else
      echo_info "no SMS messages"
      fi
      return 0
    fi

    if [[ -n "$RAW_OUTPUT" ]]
    then
      local raw_items
      raw_items="$(
        for mid in "${mids[@]}"
        do
          [[ -z "$mid" ]] && continue
          if ! list_json="$(mmcli --modem "$mid" --messaging-list-sms -J)"
          then
            continue
          fi
          mapfile -t ids < <(jq -r '."modem.messaging.sms"[]? | split("/")[-1]' <<<"$list_json" 2>/dev/null)
          for id in "${ids[@]}"
          do
            [[ -z "$id" ]] && continue
            js="$(mmcli --modem "$mid" --sms "$id" -J || true)" || true
            if [[ -n "$js" ]]
            then
              jq -c --arg mid "$mid" '{modem_id: ($mid|tonumber), sms: .}' <<<"$js" 2>/dev/null || true
            fi
          done
        done
      )"
      if [[ -z "$raw_items" ]]
      then
        printf '[]\n'
      else
        printf '%s\n' "$raw_items" | jq -s '.'
      fi
      return 0
    fi

    if [[ -n "$JSON_OUTPUT" ]]
    then
      local json_items
      json_items="$(
        for mid in "${mids[@]}"
        do
          [[ -z "$mid" ]] && continue
          # obtain own number per modem
          local mjs own=""
          mjs="$(mmcli --modem "$mid" -J 2>/dev/null || true)"
          if [[ -n "$mjs" ]]
          then
            own="$(jq -r '.modem.generic["own-numbers"][0] // empty' <<<"$mjs" 2>/dev/null)"
            if [[ -n "$own" && "$own" != +* ]]
            then
              own="+$own"
            fi
          fi
          if ! list_json="$(mmcli --modem "$mid" --messaging-list-sms -J)"
          then
            continue
          fi
          mapfile -t ids < <(jq -r '."modem.messaging.sms"[]? | split("/")[-1]' <<<"$list_json" 2>/dev/null)
          for id in "${ids[@]}"
          do
            [[ -z "$id" ]] && continue
            if ! js="$(mmcli --modem "$mid" --sms "$id" -J)"
            then
              continue
            fi
            pdu="$(jq -r '.sms.properties["pdu-type"] // ""' <<<"$js" 2>/dev/null)"
            case "${pdu,,}" in
              deliver) msg_type="received" ;;
              submit) msg_type="sent" ;;
              status-report) msg_type="report" ;;
              *) msg_type="$pdu" ;;
            esac
            jq -c --arg id "$id" --arg type "$msg_type" --arg mid "$mid" --arg own "$own" '
              {
                modem_id: ($mid|tonumber),
                id: ($id|tonumber),
                sender: (.sms.content.number // ""),
                text: (.sms.content.text // ""),
                class: (.sms.content.class // ""),
                state: (.sms.properties.state // ""),
                pdu: (.sms.properties["pdu-type"] // ""),
                storage: (.sms.properties.storage // ""),
                type: $type,
                recipient: (if $type == "received" then $own else (.sms.content.number // "") end)
              }
            ' <<<"$js" 2>/dev/null || true
          done
        done
      )"
      if [[ -z "$json_items" ]]
      then
        printf '[]\n'
      else
        printf '%s\n' "$json_items" | jq -s '.'
      fi
      return 0
    fi

    # Pretty output across all modems: add a MID column
    local _nocolor=""
    if [[ -n "$NO_COLOR" || -n "$CRON" ]]
    then
      _nocolor=1
    fi
    local header_line
    header_line="$(printf '%-4s %-4s %-10s %-18s %s' 'MID' 'ID' 'TYPE' 'FROM' 'MSG')"
    if [[ -n "$_nocolor" ]]
    then
      printf '%s\n' "$header_line"
    else
      printf '\e[1m%s\e[0m\n' "$header_line"
    fi

    for mid in "${mids[@]}"
    do
      [[ -z "$mid" ]] && continue
      if ! list_json="$(mmcli --modem "$mid" --messaging-list-sms -J)"
      then
        continue
      fi
      mapfile -t ids < <(jq -r '."modem.messaging.sms"[]? | split("/")[-1]' <<<"$list_json" 2>/dev/null)
      for id in "${ids[@]}"
      do
        [[ -z "$id" ]] && continue
        if ! js="$(mmcli --modem "$mid" --sms "$id" -J)"
        then
          continue
        fi
        sender="$(jq -r '.sms.content.number // "--"' <<<"$js" 2>/dev/null)"
        if [[ -n "$sender" && "$sender" != "--" && "$sender" != +* ]]
        then
          sender="+$sender"
        fi
        pdu="$(jq -r '.sms.properties["pdu-type"] // ""' <<<"$js" 2>/dev/null)"
        case "${pdu,,}" in
          deliver) msg_type="received" ;;
          submit) msg_type="sent" ;;
          status-report) msg_type="report" ;;
          *) msg_type="$pdu" ;;
        esac
        text="$(jq -r '.sms.content.text // ""' <<<"$js" 2>/dev/null)"
        text=${text//$'\r'/}
        text=${text//$'\n'/\\n}
        if (( ${#text} > maxlen ))
        then
          text="${text:0:maxlen}..."
        fi
        printf '%-4s %-4s %-10s %-18s %s\n' "$mid" "$id" "$msg_type" "$sender" "$text"
        had_any=1
      done
    done
    [[ -n "$had_any" ]] || echo_info "no SMS messages"
    return 0
  fi

  if ! list_json="$(mmcli_cmd --messaging-list-sms -J)"
  then
    error "failed to list SMS messages"
    return 1
  fi

  mapfile -t ids < <(jq -r '."modem.messaging.sms"[]? | split("/")[-1]' <<<"$list_json" 2>/dev/null)
  if (( ${#ids[@]} == 0 ))
  then
    if [[ -n "$JSON_OUTPUT$RAW_OUTPUT" ]]
    then
      printf '[]\n'
    else
      echo_info "no SMS messages"
    fi
    return 0
  fi

  if [[ -n "$RAW_OUTPUT" ]]
  then
    # Collect raw mmcli JSON objects and wrap in an array
    {
      for id in "${ids[@]}"
      do
        [[ -z "$id" ]] && continue
        mmcli_cmd --sms "$id" -J || true
      done
    } | jq -s '.'
    return 0
  fi

  if [[ -n "$JSON_OUTPUT" ]]
  then
    # Emit one compact JSON object per SMS, then wrap into an array
    # Determine our own number for recipient mapping of received messages
    local own=""
    if load_own_number
    then
      own="$OWN_NUMBER"
    fi
    {
      for id in "${ids[@]}"
      do
        [[ -z "$id" ]] && continue
        if ! js="$(mmcli_cmd --sms "$id" -J)"
        then
          continue
        fi
        pdu="$(jq -r '.sms.properties["pdu-type"] // ""' <<<"$js" 2>/dev/null)"
        case "${pdu,,}" in
          deliver) msg_type="received" ;;
          submit) msg_type="sent" ;;
          status-report) msg_type="report" ;;
          *) msg_type="$pdu" ;;
        esac
        jq -c --arg id "$id" --arg type "$msg_type" --arg own "$own" '
          {
            id: ($id|tonumber),
            sender: (.sms.content.number // ""),
            text: (.sms.content.text // ""),
            class: (.sms.content.class // ""),
            state: (.sms.properties.state // ""),
            pdu: (.sms.properties["pdu-type"] // ""),
            storage: (.sms.properties.storage // ""),
            type: $type,
            recipient: (if $type == "received" then $own else (.sms.content.number // "") end)
          }
        ' <<<"$js" 2>/dev/null || true
      done
    } | jq -s '.'
    return 0
  fi

  # Header for human-readable list (make entire line bold to preserve alignment)
  local _nocolor=""
  if [[ -n "$NO_COLOR" || -n "$CRON" ]]
  then
    _nocolor=1
  fi
  local header_line
  header_line="$(printf '%-4s %-10s %-18s %s' 'ID' 'TYPE' 'FROM' 'MSG')"
  if [[ -n "$_nocolor" ]]
  then
    printf '%s\n' "$header_line"
  else
    printf '\e[1m%s\e[0m\n' "$header_line"
  fi

  for id in "${ids[@]}"
  do
    [[ -z "$id" ]] && continue
    if ! js="$(mmcli_cmd --sms "$id" -J)"
    then
      continue
    fi
    sender="$(jq -r '.sms.content.number // "--"' <<<"$js" 2>/dev/null)"
    # Normalize sender phone format: ensure leading '+' when present
    if [[ -n "$sender" && "$sender" != "--" && "$sender" != +* ]]
    then
      sender="+$sender"
    fi
    pdu="$(jq -r '.sms.properties["pdu-type"] // ""' <<<"$js" 2>/dev/null)"
    case "${pdu,,}" in
      deliver) msg_type="received" ;;
      submit) msg_type="sent" ;;
      status-report) msg_type="report" ;;
      *) msg_type="$pdu" ;;
    esac
    text="$(jq -r '.sms.content.text // ""' <<<"$js" 2>/dev/null)"
    text=${text//$'\r'/}
    text=${text//$'\n'/\\n}
    if (( ${#text} > maxlen ))
    then
      text="${text:0:maxlen}..."
    fi
    printf '%-4s %-10s %-18s %s\n' "$id" "$msg_type" "$sender" "$text"
  done
}

enable_log() {
  echo_info "$*"
}

enable_modem() {
  local expect_id="${1:-}"
  local max_wait=600
  local sleep_period=2
  local elapsed=0

  enable_log "waiting for D-Bus system socket"
  until [[ -S /var/run/dbus/system_bus_socket ]]
  do
    if (( elapsed >= max_wait ))
    then
      echo_warning "timeout waiting for D-Bus socket"
      return 1
    fi
    sleep "$sleep_period"
    elapsed=$((elapsed + sleep_period))
  done

  enable_log "waiting for ModemManager"
  elapsed=0
  until mmcli -L >/dev/null 2>&1
  do
    if (( elapsed >= max_wait ))
    then
      echo_warning "timeout waiting for ModemManager"
      return 1
    fi
    sleep "$sleep_period"
    elapsed=$((elapsed + sleep_period))
  done

  enable_log "waiting for modem detection"
  elapsed=0
  local list_json
  local modem_count=0
  while :
  do
    list_json=""
    modem_count=0
    if list_json="$(mmcli -L -J)"
    then
      if [[ -n "$expect_id" && "$expect_id" =~ ^[0-9]+$ ]]
      then
        local present
        present="$(jq -r --arg id "$expect_id" '
          (."modem-list" // [])
          | map(split("/")[-1])
          | any(. == $id)
        ' <<<"$list_json" 2>/dev/null || printf 'false')"
        if [[ "$present" == "true" ]]
        then
          break
        fi
      else
        modem_count="$(jq -r '((."modem-list" // []) | length) // 0' <<<"$list_json" 2>/dev/null || printf '0')"
        if [[ "$modem_count" =~ ^[0-9]+$ ]] && (( modem_count > 0 ))
        then
          break
        fi
      fi
    fi

    if (( elapsed >= max_wait ))
    then
      echo_warning "timeout waiting for modem detection"
      return 1
    fi
    sleep "$sleep_period"
    elapsed=$((elapsed + sleep_period))
  done

  if [[ -n "$expect_id" && "$expect_id" =~ ^[0-9]+$ ]]
  then
    enable_log "detected expected modem id=$expect_id"
  else
    enable_log "detected $modem_count modem(s)"
  fi

  # Use the expected modem id if provided; otherwise rely on MODEM
  local enable_target="$MODEM"
  if [[ -n "$expect_id" ]]
  then
    enable_target="$expect_id"
  fi
  local MODEM="$enable_target"
  if mmcli_cmd --enable >/dev/null 2>&1
  then
    enable_log "modem enabled"
    # Log enabled modem details similar to selection log
    if [[ -z $QUIET ]]
    then
      local _ej _eln
      _ej="$(mmcli -m "$enable_target" -J || true)"
      if [[ -n "$_ej" ]]
      then
        _eln="$(jq -r '
          .modem as $m
          | {
              id: ($m["dbus-path"] | split("/")[-1]),
              manufacturer: ($m.generic.manufacturer // "--"),
              model: ($m.generic.model // "--"),
              plugin: ($m.generic.plugin // "--"),
              primary: ($m.generic["primary-port"] // "--"),
              ports: (($m.generic.ports // []) | map(split(" ")[0]) | join(","))
            }
          | ("enabled modem: id=" + .id
             + " manufacturer=" + .manufacturer
             + " model=" + .model
             + " plugin=" + .plugin
             + " primary=" + .primary
             + " ports=" + .ports)
        ' <<<"$_ej" 2>/dev/null || true)"
        if [[ -n "$_eln" ]]
        then
          echo_info "$_eln"
        fi
      fi
    fi
    return 0
  fi

  echo_warning "failed to enable modem"
  return 1
}

enable_all_modems() {
  local list_json mids mid
  if ! list_json="$(mmcli -L -J)"
  then
    error "failed to list modems to enable"
    return 1
  fi
  mapfile -t mids < <(jq -r '."modem-list"[]? | split("/")[-1]' <<<"$list_json" 2>/dev/null)
  if (( ${#mids[@]} == 0 ))
  then
    echo_info "no modems detected"
    return 0
  fi
  local ok_count=0
  local fail_ids=()
  for mid in "${mids[@]}"
  do
    [[ -z "$mid" ]] && continue
    echo_info "enabling modem $mid"
    if ! enable_modem "$mid"
    then
      echo_warning "failed to enable modem $mid"
      fail_ids+=("$mid")
    else
      ok_count=$((ok_count + 1))
    fi
  done
  if (( ${#fail_ids[@]} > 0 ))
  then
    echo_info "enabled $ok_count/${#mids[@]} modems (failed: ${fail_ids[*]})"
  else
    echo_info "enabled $ok_count/${#mids[@]} modems"
  fi
}

modem_reset() {
  local service="/etc/init.d/modemmanager"
  local has_service=""
  local do_service=""

  if [[ -x "$service" ]]
  then
    has_service=1
  else
    reset_warn "modemmanager init script not found or not executable at $service"
  fi

  # Detect modem plugin/manufacturer to decide if Quectel-specific reset applies
  local j plugin manufacturer is_quectel=""
  if j="$(mmcli_cmd -J 2>/dev/null)"
  then
    plugin="$(jq -r '.modem.generic.plugin // empty' <<<"$j" 2>/dev/null)"
    manufacturer="$(jq -r '.modem.generic.manufacturer // empty' <<<"$j" 2>/dev/null)"
    if [[ "${plugin,,}" == quectel || "${manufacturer,,}" == quectel* ]]
    then
      is_quectel=1
    fi
  else
    reset_warn "could not query modem to determine vendor; proceeding without Quectel reset"
  fi

  if [[ -n "$is_quectel" ]]
  then
    if ! command -v quectel >/dev/null 2>&1
    then
      error "quectel command not found in PATH"
      return 1
    fi

    if [[ -n "$HARD_RESET" ]] && [[ -n "$has_service" ]]
    then
      reset_log "stopping ModemManager"
      if ! "$service" stop
      then
        error "failed to stop ModemManager service"
        return 1
      fi
      do_service=1
    fi

    reset_log "issuing quectel reset"
    if ! quectel reset
    then
      error "quectel reset failed"
      if [[ -n "$do_service" ]]
      then
        reset_warn "attempting to restart ModemManager after reset failure"
        "$service" start || reset_warn "could not restart ModemManager"
      fi
      return 1
    fi

    if [[ -n "$do_service" ]]
    then
      reset_log "starting ModemManager"
      if ! "$service" start
      then
        error "failed to start ModemManager service"
        return 1
      fi
    fi
  else
    # Non-Quectel: avoid vendor reset; optionally restart ModemManager to nudge detection
    if [[ -n "$HARD_RESET" ]] && [[ -n "$has_service" ]]
    then
      reset_log "restarting ModemManager (non-Quectel)"
      if ! "$service" restart
      then
        reset_warn "failed to restart ModemManager service"
      fi
    fi
  fi

  reset_log "enabling modem"
  if ! enable_modem "$MODEM"
  then
    reset_warn "failed to enable modem after reset, retrying in 5s"
    sleep 5
    if ! enable_modem "$MODEM"
    then
      error "failed to enable modem after reset"
      return 1
    fi
  fi

  return 0
}

modem_reset_all() {
  local list_json mids mid
  if ! list_json="$(mmcli -L -J)"
  then
    error "failed to list modems to reset"
    return 1
  fi
  mapfile -t mids < <(jq -r '."modem-list"[]? | split("/")[-1]' <<<"$list_json" 2>/dev/null)
  if (( ${#mids[@]} == 0 ))
  then
    echo_info "no modems detected"
    return 0
  fi
  for mid in "${mids[@]}"
  do
    [[ -z "$mid" ]] && continue
    echo_info "resetting modem $mid"
    (
      local MODEM="$mid"
      modem_reset || error "failed to reset modem $mid"
    )
  done
}

watch_log() {
  echo_info "$*"
}

watch_warn() {
  echo_warning "$*"
}

reset_log() {
  if [[ -z $QUIET ]]
  then
    echo_info "$*"
  fi
}

reset_warn() {
  echo_warning "$*"
}

watch_cleanup() {
  if [[ -n "$WATCH_DBUS_PID" ]]
  then
    if ! kill "$WATCH_DBUS_PID" 2>/dev/null
    then
      watch_warn "could not stop dbus-monitor (pid $WATCH_DBUS_PID)"
    fi
    WATCH_DBUS_PID=""
  fi
  if [[ -n "$WATCH_FIFO" ]]
  then
    if ! rm -f "$WATCH_FIFO" 2>/dev/null
    then
      watch_warn "could not remove fifo $WATCH_FIFO"
    fi
    WATCH_FIFO=""
  fi
}

watch_canon_number() {
  local n="${1:-}"
  n="${n//[^0-9]/}"
  printf '%s' "$n"
}

watch_in_whitelist() {
  local num
  num="$(watch_canon_number "${1:-}")"
  if [[ -z "$num" ]]
  then
    return 1
  fi
  local allowed canon_allowed
  for allowed in "${SMS_WHITELIST[@]}"
  do
    canon_allowed="$(watch_canon_number "$allowed")"
    if [[ -n "$canon_allowed" && "$num" == "$canon_allowed" ]]
    then
      return 0
    fi
  done
  return 1
}

watch_send_reply() {
  local to="$1"
  local msg="$2"
  # Log outgoing SMS (abbreviate text and escape newlines)
  local log_text="$msg"
  log_text=${log_text//$'\r'/}
  log_text=${log_text//$'\n'/\\n}
  # Prevent echo -e from interpreting escapes
  log_text=${log_text//\\/\\\\}
  if [[ -z "$log_text" ]]
  then
    log_text="<empty>"
  elif (( ${#log_text} > 200 ))
  then
    log_text="${log_text:0:200}..."
  fi
  local log_modem
  log_modem="$(modem_info_brief)"
  watch_log "sending reply modem=$log_modem to $to text='$log_text'"
  log_sys "sending reply modem=$log_modem to $to text='$log_text'"
  if ! sms_send "$to" "$msg"
  then
    watch_warn "failed to send reply to $to"
    return 1
  fi
}

watch_run_command() {
  local cmd="$1"
  local output rc reason="exit"
  rc=0

  if command -v timeout >/dev/null 2>&1
  then
    if ! output="$(timeout -k "${WATCH_CMD_KILL_TIMEOUT}s" "${WATCH_CMD_TIMEOUT}s" bash -c "$cmd" 2>&1)"
    then
      rc=$?
    fi
    if (( rc == 124 ))
    then
      reason="timeout"
    elif (( rc >= 128 ))
    then
      reason="killed"
    fi
  else
    if ! output="$(bash -c "$cmd" 2>&1)"
    then
      rc=$?
    fi
  fi

  WATCH_CMD_RC=$rc
  WATCH_CMD_REASON=$reason

  output="${output%$'\n'}"
  if (( ${#output} > CMD_OUTPUT_MAX_LEN ))
  then
    output="${output:0:CMD_OUTPUT_MAX_LEN}\n…(truncated)…"
  fi

  printf '%s' "$output"
}

load_own_number() {
  if [[ -n "$OWN_NUMBER" ]]
  then
    return 0
  fi

  local json number
  if ! json="$(mmcli_cmd -J)"
  then
    return 1
  fi

  number="$(jq -r '(.modem.generic["own-numbers"][0] // empty)' <<<"$json")"
  if [[ -z "$number" ]]
  then
    return 2
  fi

  if [[ "$number" != +* ]]
  then
    number="+$number"
  fi

  OWN_NUMBER="$number"
  return 0
}

get_smsc_number() {
  if [[ -n "$SMSC_NUMBER" ]]
  then
    printf '%s' "$SMSC_NUMBER"
    return 0
  fi

  # Try to retrieve the network-configured SMSC via AT+CSCA?
  # If unavailable or unsupported, return empty (do not force SMSC).
  local resp smsc
  resp="$(at_command 'AT+CSCA?')"
  if [[ -n "$resp" ]]
  then
    smsc="$(at_first_quoted_decoded "$resp" || true)"
    if [[ -n "$smsc" ]]
    then
      if [[ "$smsc" != +* && "$smsc" =~ ^[0-9]+$ ]]
      then
        smsc="+$smsc"
      fi
      SMSC_NUMBER="$smsc"
      printf '%s' "$SMSC_NUMBER"
      return 0
    fi
  fi

  # No SMSC detected; leave empty so callers skip forcing one
  SMSC_NUMBER=""
  printf '%s' "$SMSC_NUMBER"
}

modem_status() {
  local json state power reg signal carrier own smsc

  if ! json="$(mmcli_cmd -J)"
  then
    if [[ -z $QUIET ]]
    then
      error "failed to query modem status"
    fi
    return 1
  fi

  if [[ -n "$RAW_OUTPUT" ]]
  then
    printf '%s\n' "$json" | jq
    return 0
  fi

  state="$(jq -r '(.modem.generic.state // empty)' <<<"$json")"
  power="$(jq -r '(.modem.generic["power-state"] // empty)' <<<"$json")"
  reg="$(jq -r '(.modem["3gpp"]["registration-state"] // empty)' <<<"$json")"
  signal="$(jq -r '(.modem.generic["signal-quality"].value // empty)' <<<"$json")"
  carrier="$(jq -r '(.modem["3gpp"]["operator-name"] // .modem["3gpp"]["operator-code"] // .modem.cdma.sid // empty)' <<<"$json")"
  own="$(jq -r '(.modem.generic["own-numbers"][0] // empty)' <<<"$json")"

  if [[ -z "$state" ]]
  then
    state=unknown
  fi
  if [[ -z "$power" ]]
  then
    power=unknown
  fi
  if [[ -z "$reg" ]]
  then
    reg=unknown
  fi
  if [[ -n "$signal" ]]
  then
    signal="${signal}%"
  else
    signal=unknown
  fi
  if [[ -z "$carrier" ]]
  then
    carrier=unknown
  fi
  if [[ -n "$own" && "$own" != +* ]]
  then
    own="+$own"
  fi
  if [[ -z "$own" ]]
  then
    own=unknown
  else
    OWN_NUMBER="$own"
  fi

  # Derive SMSC (may use OWN_NUMBER or config); do not fail hard if empty
  smsc="$(get_smsc_number || true)"
  if [[ -z "$smsc" ]]
  then
    smsc=unknown
  fi

  # JSON output if requested
  if [[ -n "$JSON_OUTPUT" ]]
  then
    local sig_num_json
    sig_num_json="$(jq -r '(.modem.generic["signal-quality"].value // empty)' <<<"$json")"
    jq -n \
      --arg state "$state" \
      --arg power "$power" \
      --arg registered "$reg" \
      --arg carrier "$carrier" \
      --arg phone "$own" \
      --arg smsc "$smsc" \
      --arg sig "$sig_num_json" \
      '{state:$state, power:$power, registered:$registered, carrier:$carrier, phone:$phone, smsc:$smsc, signal: ($sig|tonumber?)}'
    return 0
  fi

  if [[ -z $QUIET ]]
  then
    # Color helpers (respect NO_COLOR and CRON)
    local _nocolor=""
    if [[ -n "$NO_COLOR" || -n "$CRON" ]]
    then
      _nocolor=1
    fi

    colorize() { # $1=colorcode, $2=text
      if [[ -n "$_nocolor" ]]
      then
        printf '%s' "$2"
      else
        printf '\e[%sm%s\e[0m' "$1" "$2"
      fi
    }

    # Choose colors
    local state_color power_color reg_color sig_color carrier_color phone_color smsc_color
    case "${state,,}" in
      connected|registered|enabled|online|on) state_color='1;32';;   # bold green
      searching|initializing|connecting|locked|unknown) state_color='1;33';; # bold yellow
      failed|disabled|off) state_color='1;31';;                      # bold red
      *) state_color='36';;                                          # cyan
    esac

    case "${power,,}" in
      on|full) power_color='1;32';;
      low) power_color='1;33';;
      off|unknown) power_color='1;31';;
      *) power_color='36';;
    esac

    case "${reg,,}" in
      home|roaming|registered|attached) reg_color='1;32';;
      searching|idle|unknown) reg_color='1;33';;
      denied|unregistered) reg_color='1;31';;
      *) reg_color='36';;
    esac

    # Determine signal color based on numeric value when available
    local sig_num
    sig_num="$(jq -r '(.modem.generic["signal-quality"].value // empty)' <<<"$json")"
    if [[ "$sig_num" =~ ^[0-9]+$ ]]
    then
      if (( sig_num >= 70 ))
      then
        sig_color='1;32'
      elif (( sig_num >= 40 ))
      then
        sig_color='1;33'
      else
        sig_color='1;31'
      fi
    else
      sig_color='36'
    fi

    carrier_color='1;34' # bold blue
    phone_color='1;34'
    smsc_color='1;34'

    printf 'modem state: %s\n' "$(colorize "$state_color" "$state")"
    printf 'power: %s\n' "$(colorize "$power_color" "$power")"
    printf 'registered: %s\n' "$(colorize "$reg_color" "$reg")"
    printf 'signal: %s\n' "$(colorize "$sig_color" "$signal")"
    printf 'carrier: %s\n' "$(colorize "$carrier_color" "$carrier")"
    printf 'phone: %s\n' "$(colorize "$phone_color" "$own")"
    printf 'smsc: %s\n' "$(colorize "$smsc_color" "$smsc")"
  fi

  return 0
}

modem_number() {
  if ! load_own_number
  then
    local load_rc=$?
    if (( load_rc == 1 ))
    then
      error "could not query modem for own number"
    else
      error "modem did not report own number"
    fi
    return 1
  fi

  if [[ -z "$OWN_NUMBER" ]]
  then
    error "modem did not report own number"
    return 2
  fi

  printf '%s\n' "$OWN_NUMBER"
  return 0
}

watch_handle_sms() {
  local id="$1"
  local prefer_modem_id="${2:-}"
  # Ensure replies and operations use the modem that received the message
  # by shadowing MODEM locally for mmcli_cmd invocations.
  local MODEM="$MODEM"
  if [[ -n "$prefer_modem_id" ]]
  then
    MODEM="$prefer_modem_id"
  else
    watch_warn "no modem hint for SMS $id; defaulting to any"
    MODEM="any"
  fi
  local tries=0
  local js state pdu sender text payload

  while :
  do
    if ! js="$(mmcli_cmd --sms "$id" -J)"
    then
      return
    fi

    state="$(jq -r '.sms.properties.state // empty' <<<"$js")"
    pdu="$(jq -r '.sms.properties."pdu-type" // empty' <<<"$js")"
    sender="$(jq -r '.sms.content.number // empty' <<<"$js")"
    text="$(jq -r '.sms.content.text // empty' <<<"$js")"

    if [[ "$state" != "received" && "$pdu" != "deliver" ]]
    then
      watch_log "ignore id=$id (state=$state pdu=$pdu)"
      return
    fi

    if [[ -n "$OWN_NUMBER" && "$sender" == "$OWN_NUMBER" ]]
    then
      watch_log "skip self-sent id=$id"
      return
    fi

    if [[ -z "$text" && $tries -lt $WATCH_MAX_RETRY ]]
    then
      tries=$((tries + 1))
      sleep "$WATCH_RETRY_SLEEP"
      continue
    fi

    # Determine recipient (SIM MSISDN) for the modem that received the SMS
    # Prefer querying the current modem directly to avoid cross-modem mixups.
    local recipient=""
    local om_json
    if om_json="$(mmcli_cmd -J 2>/dev/null || true)"
    then
      recipient="$(jq -r '.modem.generic["own-numbers"][0] // empty' <<<"$om_json" 2>/dev/null)"
      if [[ -n "$recipient" && "$recipient" != +* ]]
      then
        recipient="+$recipient"
      fi
    fi

    local log_text="$text"
    log_text=${log_text//$'\r'/}
    log_text=${log_text//$'\n'/\\n}
    # Prevent echo -e from interpreting escapes
    log_text=${log_text//\\/\\\\}
    if [[ -z "$log_text" ]]
    then
      log_text="<empty>"
    elif (( ${#log_text} > 200 ))
    then
      log_text="${log_text:0:200}..."
    fi
    local log_recipient="$recipient"
    if [[ -z "$log_recipient" ]]
    then
      log_recipient="--"
    fi
    watch_log "received id=$id from $sender to $log_recipient text='$log_text'"

    local handled=0
    if [[ "$text" == "!"* ]]
    then
      if watch_in_whitelist "$sender"
      then
        local cmd="${text#!}"
        while [[ "$cmd" == " "* ]]
        do
          cmd="${cmd# }"
        done
        if [[ -z "$cmd" ]]
        then
          watch_send_reply "$sender" "ERR: empty command"
        else
          watch_log "executing command from $sender: $cmd"
          local output
          output="$(watch_run_command "$cmd")"
          watch_log "command from $sender finished rc=$WATCH_CMD_RC reason=${WATCH_CMD_REASON:-exit}"
          # Before sending our reply, prune already-sent messages on this modem
          sms_prune_sent || watch_warn "failed to prune sent SMS before reply"
          watch_send_reply "$sender" "rc=$WATCH_CMD_RC (${WATCH_CMD_REASON:-exit})\n$output"
        fi
        handled=1
      else
        watch_log "command from $sender ignored (not whitelisted)"
      fi
    fi

    if (( handled == 0 ))
    then
      payload="$(jq -n \
        --arg recipient "$recipient" \
        --arg sender "$sender" \
        --arg text "$text" \
        --arg date "$(date -Iseconds)" \
        '{recipient:$recipient, sender:$sender, text:$text, date: $date}')"
      watch_log "forwarding id=$id from $sender to webhook"
      if ! curl -sS -m 10 -H 'Content-Type: application/json' \
        -X POST -d "$payload" "$WEBHOOK_URL" >/dev/null
      then
        watch_warn "webhook delivery failed for id=$id"
      fi
    fi

    if (( WATCH_DELETE_AFTER == 1 ))
    then
      if ! mmcli_cmd --messaging-delete-sms="$id" >/dev/null 2>&1
      then
        watch_warn "failed to delete processed SMS $id"
      fi
    fi
    return
  done
}

watch_messages() {
  export PATH="/usr/local/bin:/srv/bin:$PATH"
  trap watch_cleanup EXIT INT TERM

  WATCH_FIFO="${TMPDIR:-/tmp}/smsbus.$$"
  mkfifo "$WATCH_FIFO"

  local filter="type='signal',interface='org.freedesktop.ModemManager1.Modem.Messaging',member='Added'"
  dbus-monitor --system "$filter" >"$WATCH_FIFO" &
  WATCH_DBUS_PID=$!

  if load_own_number
  then
    if [[ -n "$OWN_NUMBER" ]]
    then
      watch_log "own number = $OWN_NUMBER"
    fi
  else
    local load_rc=$?
    if (( load_rc == 1 ))
    then
      watch_warn "could not query modem for own number"
    else
      watch_warn "modem did not report own number"
    fi
  fi

  if ! sms_prune_all_modems
  then
    watch_warn "failed to prune existing SMS messages on all modems"
  fi

  if [[ -n "$ALL_MODEMS" ]]
  then
    enable_all_modems || watch_warn "failed to enable all modems"
  else
    enable_modem "$MODEM" || watch_warn "failed to enable modem"
  fi

  local current_modem_id=""
  while IFS= read -r line
  do
    # Track the modem id from the signal's path
    if [[ "$line" =~ /org/freedesktop/ModemManager1/Modem/([0-9]+) ]]
    then
      current_modem_id="${BASH_REMATCH[1]}"
    elif [[ "$line" =~ "/org/freedesktop/ModemManager1/Modem/"([0-9]+) ]]
    then
      current_modem_id="${BASH_REMATCH[1]}"
    fi
    if [[ "$line" == *"/org/freedesktop/ModemManager1/SMS/"* ]]
    then
      local local_path="${line#*\"}"
      local_path="${local_path%%\"*}"
      local id="${local_path##*/}"
      if [[ "$id" =~ ^[0-9]+$ ]]
      then
        # If not listening on all, ignore messages from other modems
        if [[ -z "$ALL_MODEMS" && -n "$current_modem_id" && "$current_modem_id" != "$MODEM" ]]
        then
          watch_warn "ignoring SMS $id from modem $current_modem_id (listening on $MODEM)"
          continue
        fi
        watch_handle_sms "$id" "$current_modem_id"
      fi
    fi
  done <"$WATCH_FIFO"
}

main() {
  local command
  local -a ARGS=()

  # Global options can appear anywhere; collect non-option args into ARGS
  while (( $# > 0 ))
  do
    case "$1" in
      -m|--modem)
        if (( $# < 2 ))
        then
          error "missing value for $1"
          return 2
        fi
        MODEM="$2"
        shift 2
        ;;
      -d|--debug)
        DEBUG=1
        shift
        ;;
      -j|--json)
        JSON_OUTPUT=1
        shift
        ;;
      --raw)
        RAW_OUTPUT=1
        shift
        ;;
      --hard)
        HARD_RESET=1
        shift
        ;;
      --all)
        ALL_MODEMS=1
        shift
        ;;
      --sent)
        SENT_ONLY=1
        shift
        ;;
      --allow-foreign)
        ALLOW_FOREIGN=1
        shift
        ;;
      -q|--quiet|--silent)
        QUIET=1
        shift
        ;;
      -x|--trace)
        PS4='+ [${BASH_SOURCE##*/}:${LINENO}] ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
        set -x
        shift
        ;;
      -h|--help)
        usage
        return 0
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          ARGS+=("$1")
          shift
        done
        break
        ;;
      *)
        ARGS+=("$1")
        shift
        ;;
    esac
  done

  if (( ${#ARGS[@]} == 0 ))
  then
    command="status"
  else
    command="${ARGS[0]}"
    ARGS=("${ARGS[@]:1}")
  fi

  case "$command" in
    send|s)
      command="send"
      ;;
    list|ls|l|-l)
      command="list"
      ;;
    read|get|r)
      command="read"
      ;;
    prune|clear|delete)
      command="prune"
      ;;
    -e|*enable*|en|start)
      command="enable"
      ;;
    status|stat|st)
      command="status"
      ;;
    number|phone)
      command="number"
      ;;
    reset|rst|restart)
      command="reset"
      ;;
    watch|w)
      command="watch"
      ;;
  esac

  if [[ "$command" == -* ]]
  then
    error "unknown option: $command"
    usage >&2
    return 2
  fi

  # Resolve human-friendly modem selector to a concrete id, once
  if ! MODEM="$(get_modem_id "$MODEM")"
  then
    # get_modem_id already printed context and list
    return 2
  fi

  # Pin 'any' to the actual modem id to avoid races in subsequent calls
  if [[ "$MODEM" == "any" ]]
  then
    local _j _id
    if _j="$(mmcli_cmd -J || true)"
    then
      _id="$(jq -r '.modem["dbus-path"] | split("/")[-1] // empty' <<<"$_j" 2>/dev/null)"
      if [[ -n "$_id" ]]
      then
        MODEM="$_id"
      fi
    fi
  fi

  # Informative log about resolved modem selection (guarded to avoid nesting)
  if [[ -z $QUIET ]]
  then
    if [[ "$MODEM" == "any" ]]
    then
      # Resolve which modem 'any' targets by querying mmcli -m any -J
      local _j _ln
      if _j="$(mmcli_cmd -J 2>/dev/null || true)"
      then
        _ln="$(jq -r '
          .modem as $m
          | {
              id: ($m["dbus-path"] | split("/")[-1]),
              manufacturer: ($m.generic.manufacturer // "--"),
              model: ($m.generic.model // "--"),
              plugin: ($m.generic.plugin // "--"),
              primary: ($m.generic["primary-port"] // "--"),
              ports: (($m.generic.ports // []) | map(split(" ")[0]) | join(",")),
              phone: (($m.generic["own-numbers"][0] // "")
                      | if . == "" then "--"
                        else (if startswith("+") then . else "+" + . end) end)
            }
          | ("selected modem: id=" + .id
             + " manufacturer=" + .manufacturer
             + " model=" + .model
             + " plugin=" + .plugin
             + " primary=" + .primary
             + " ports=" + .ports
             + " phone=" + .phone)
        ' <<<"$_j" 2>/dev/null || true)"
        echo_info "${_ln:-selected modem: any}"
      else
        echo_info "selected modem: any"
      fi
    else
      local _mjson _mln
      _mjson="$(mmcli -m "$MODEM" -J || true)"
      if [[ -n "$_mjson" ]]
      then
        _mln="$(jq -r '
          .modem as $m
          | {
              id: ($m["dbus-path"] | split("/")[-1]),
              manufacturer: ($m.generic.manufacturer // "--"),
              model: ($m.generic.model // "--"),
              plugin: ($m.generic.plugin // "--"),
              primary: ($m.generic["primary-port"] // "--"),
              ports: (($m.generic.ports // []) | map(split(" ")[0]) | join(",")),
              phone: (($m.generic["own-numbers"][0] // "")
                      | if . == "" then "--"
                        else (if startswith("+") then . else "+" + . end) end)
            }
          | ("selected modem: id=" + .id
             + " manufacturer=" + .manufacturer
             + " model=" + .model
             + " plugin=" + .plugin
             + " primary=" + .primary
             + " ports=" + .ports
             + " phone=" + .phone)
        ' <<<"$_mjson" 2>/dev/null || true)"
      fi
      echo_info "${_mln:-selected modem: $MODEM}"
    fi
  fi

  case "$command" in
    send)
      sms_send "${ARGS[@]}"
      ;;
    list)
      sms_list_pretty
      ;;
    read)
      if (( ${#ARGS[@]} < 1 ))
      then
        error "No SMS ID/path specified"
        # Show the message list in the same pretty/JSON/raw style
        sms_list_pretty || error "failed to list SMS messages"
        return 1
      fi
      if [[ -n "$RAW_OUTPUT" ]]
      then
        mmcli_cmd --sms "${ARGS[0]}" -J | jq
      elif [[ -n "$JSON_OUTPUT" ]]
      then
        sms_read_json "${ARGS[0]}"
      else
        sms_read "${ARGS[@]}"
      fi
      ;;
    prune)
      if [[ -n "$SENT_ONLY" && -n "$ALL_MODEMS" ]]
      then
        sms_prune_sent_modems
      elif [[ -n "$SENT_ONLY" ]]
      then
        sms_prune_sent
      elif [[ -n "$ALL_MODEMS" ]]
      then
        sms_prune_all_modems
      else
        sms_prune_all
      fi
      ;;
    enable)
      if [[ -n "$ALL_MODEMS" ]]
      then
        enable_all_modems
      else
        enable_modem "$MODEM"
      fi
      ;;
    status)
      modem_status
      ;;
    number)
      modem_number
      ;;
    reset)
      if [[ -n "$ALL_MODEMS" ]]
      then
        modem_reset_all
      else
        modem_reset
      fi
      ;;
    watch)
      watch_messages
      ;;
    *)
      error "unknown command: $command"
      usage >&2
      return 2
      ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "$0" ]]
then
  main "$@"
fi
