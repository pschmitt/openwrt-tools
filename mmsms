#!/usr/bin/env bash

SCRIPT_NAME="$(basename "${BASH_SOURCE[0]}")"

cd "$(dirname "$(readlink -f "$0")")" || return 9

# shellcheck source=lib/echo.sh
source lib/echo.sh || exit 2

CONFIG_FILE="${CONFIG_FILE:-/etc/mmsms.conf}"

MODEM="${MODEM:-any}"
ALL_MODEMS="${ALL_MODEMS:-}"
DEFAULT_MODEM="${DEFAULT_MODEM:-}"

OWN_NUMBER="${OWN_NUMBER:-}"
SMSC_NUMBER="${SMSC_NUMBER:-}"

SMS_SEND_TIMEOUT="${SMS_SEND_TIMEOUT:-30}"
SMS_RETRY_COUNT="${SMS_RETRY_COUNT:-${SMS_SEND_RETRY_COUNT:-${MAX_RETRY:-3}}}"
CMD_OUTPUT_MAX_LEN="${CMD_OUTPUT_MAX_LEN:-4000}"

AT_FALLBACK_MAX_READS="${AT_FALLBACK_MAX_READS:-25}"
AT_FALLBACK_READ_TIMEOUT="${AT_FALLBACK_READ_TIMEOUT:-0.2}"

WEBHOOK_URL="${WEBHOOK_URL:-}"

WATCH_DELETE_AFTER="${DELETE_AFTER:-1}"
WATCH_RETRY_SLEEP="${RETRY_SLEEP:-1}"
WATCH_CMD_TIMEOUT="${CMD_TIMEOUT:-8}"
WATCH_CMD_KILL_TIMEOUT="${WATCH_CMD_KILL_TIMEOUT:-${CMD_KILL_TIMEOUT:-20}}"

QUIET="${QUIET:-}"
JSON_OUTPUT="${JSON_OUTPUT:-}"
RAW_OUTPUT="${RAW_OUTPUT:-}"
HARD_RESET="${HARD_RESET:-}"
SENT_ONLY="${SENT_ONLY:-}"
ALLOW_FOREIGN="${ALLOW_FOREIGN:-}"
HOME_CC="${HOME_CC:-}"
FALLBACK="${FALLBACK:-}"
AUTO_RECIPIENT="${AUTO_RECIPIENT:-}"

CONFIG_LOADED=""
MODEM_EXPLICIT=""
LOG_ABBREV_LEN="${LOG_ABBREV_LEN:-80}"

load_config() {
  local origin="${1:-initial}"

  if [[ -n "$CONFIG_LOADED" ]]
  then
    echo_debug "config already loaded ($origin): $CONFIG_FILE"
    return 0
  fi

  if [[ -n "$CONFIG_FILE" && -f "$CONFIG_FILE" ]]
  then
    echo_debug "loading config ($origin): $CONFIG_FILE"
    local source_rc=0

    # shellcheck disable=SC1090
    source "$CONFIG_FILE" || source_rc=$?

    if (( source_rc != 0 ))
    then
      echo_warning "failed to load config ($origin): $CONFIG_FILE (rc=$source_rc)"
      return "$source_rc"
    fi

    CONFIG_LOADED=1
  fi
}

# Ensure SMS_WHITELIST is defined as an array if provided by the config
if ! declare -p SMS_WHITELIST >/dev/null 2>&1
then
  SMS_WHITELIST=()
fi

# Allow overriding the whitelist via SMS_WHITELIST_OVERRIDE (comma or space separated digits)
if [[ -n "${SMS_WHITELIST_OVERRIDE:-}" ]]
then
  # shellcheck disable=SC2206
  SMS_WHITELIST=( ${SMS_WHITELIST_OVERRIDE//,/ } )
elif (( ${#SMS_WHITELIST[@]} == 0 )) && declare -p SMS_WHITELIST_DEFAULT >/dev/null 2>&1
then
  SMS_WHITELIST=("${SMS_WHITELIST_DEFAULT[@]}")
fi

WATCH_FIFO=""
WATCH_DBUS_PID=""
WATCH_CMD_RC=0
WATCH_CMD_REASON="exit"
MODEM_DETAILS_LOGGED=""

usage() {
  cat <<USAGE
Usage: $SCRIPT_NAME [OPTIONS] COMMAND [ARGS]

Options:
  -A, --auto, --auto-recipient  Fallback: if foreign blocked, use modem's default recipient
  -a, --all             List/Prune/Enable/Reset: operate on all modems
  -c, --config PATH    Use alternate config file for watch
  -d, --debug          Enable debug output
  -F, --fallback        Send/Watch: on failure, try other modem(s)
  -f, --allow-foreign  Send: allow sending to foreign country codes
  -H, --hard            Reset: also stop/start modemmanager (hard reset)
  -j, --json            Output JSON (for list/status/read)
  -m, --modem MODEM     Modem selector or id (default: $MODEM)
                       Accepts id (e.g. 2), dbus path, 'any', or
                       a string matching manufacturer/plugin/ttyUSB/phone-number
                       or country (fr/de/us) or country name (france/germany/us)
  -q, --quiet           Suppress info output (warnings/errors only) and status output (exit code only)
      --silent         Same as --quiet
  -r, --raw             List: output array of raw mmcli SMS objects; Read: raw mmcli JSON; Status: raw mmcli JSON
  -R, --retry COUNT     Set SMS send retry attempts (default: ${SMS_RETRY_COUNT})
  -s, --syslog          Mirror logs to syslog (in addition to stderr)
  -S, --sent            Prune: delete only sent outgoing messages
  -x, --trace           Enable shell tracing (set -x)
  -h, --help            Show this help and exit

Commands:
  enable                     Wait for ModemManager and enable the modem
  list                       List SMS messages on the modem
  number|phone               Print modem's own phone number
  prune                      Delete all SMS messages from the modem
  read MESSAGE_ID            Show details for a specific SMS
  restart                    Restart modemmanager, issue quectel reset, re-enable modem
  send RECIPIENT [TEXT|-]    Send SMS; use '-' or stdin for TEXT
  smsc                       Print modem's configured SMSC number
  status                     Show modem status summary
  watch                      Monitor incoming SMS and forward/execute actions
USAGE
}

# Subcommand-specific usage helpers (concise, focused on per-command flags)
usage_send() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] send [RECIPIENT] TEXT|-

Sends an SMS. If RECIPIENT is omitted, uses DEFAULT_RECIPIENT_XX/CC/DEFAULT.

Relevant flags:
  -A, --auto, --auto-recipient  When fallback, use modem defaults if original blocked
  -c, --config PATH    Load config for defaults (only needed outside 'watch')
  -F, --fallback       Try other modems on failure (sorted by id)
  -f, --allow-foreign Allow sending outside the modem's home country code
  -R, --retry COUNT    Override SMS resend attempts
USAGE
}

usage_list() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] list [-a|--all] [-j|--json] [-r|--raw]

Lists SMS messages. Pretty by default; --json prints structured JSON; --raw prints raw mmcli JSON.

Relevant flags:
  -a, --all    Include messages from all modems
  -j, --json   Output custom JSON array
  -r, --raw    Output raw mmcli objects array
USAGE
}

usage_read() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] read MESSAGE_ID [-j|--json] [-r|--raw]

Reads a single SMS. --json outputs compact structured JSON; --raw outputs mmcli JSON.
USAGE
}

usage_prune() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] prune [-a|--all] [-S|--sent]

Deletes messages. By default deletes all on the selected modem.

Relevant flags:
  -a, --all    Operate on all modems
  -S, --sent   Delete only sent (outgoing, state=sent) messages
USAGE
}

usage_enable() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] enable [-a|--all]

Enables the selected modem and waits for readiness.

Relevant flags:
  -a, --all    Enable all detected modems
USAGE
}

usage_status() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] status [-a|--all] [-j|--json] [-r|--raw]

Shows modem status. --json outputs structured JSON. (Default command)

Relevant flags:
  -a, --all    Include all detected modems
  -j, --json   Output structured JSON
  -r, --raw    Output raw mmcli JSON
USAGE
}

usage_reset() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] reset [-a|--all] [-H|--hard]

Resets the selected modem. For Quectel devices, issues quectel reset.

Relevant flags:
  -a, --all    Reset all detected modems
  -H, --hard   Stop/start ModemManager around reset
USAGE
}

usage_watch() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] watch [-A|--auto-recipient] [-a|--all] [-c|--config PATH] [-F|--fallback] [-f|--allow-foreign] [-R|--retry COUNT]

Watches incoming SMS and executes reply/webhook logic.

Relevant flags:
  -A, --auto, --auto-recipient  When fallback, use modem defaults if original blocked
  -a, --all           Process messages from all modems (default: selected modem only)
  -c, --config PATH   Config file with defaults and whitelist
  -F, --fallback      When replying, try other modems on failure (sorted by id)
  -f, --allow-foreign Allow replies to recipients outside the modem's home CC
  -R, --retry COUNT   Override SMS resend attempts
USAGE
}

usage_number() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] number|phone

Prints the modem's own number (MSISDN) if reported.
USAGE
}

usage_smsc() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] smsc

Prints the modem\'s configured SMSC (service center) number when available.
USAGE
}

print_subcommand_usage() {
  case "$1" in
    send)   usage_send ;;
    list)   usage_list ;;
    read)   usage_read ;;
    prune)  usage_prune ;;
    enable) usage_enable ;;
    status) usage_status ;;
    reset)  usage_reset ;;
    watch)  usage_watch ;;
    number) usage_number ;;
    smsc)   usage_smsc ;;
    *) usage ;;
  esac
}

error() {
  echo_error "$SCRIPT_NAME: $*"
}

# Map selector to a country calling code (digits) for a small set
# Supports: fr (France=33), de (Germany=49), us/usa (United States=1)
country_to_cc() {
  local s="${1,,}"

  case "$s" in
    fr|fra|france)
      printf '33'
      ;;
    de|deu|germany|deutschland)
      printf '49'
      ;;
    us|usa|"united states"|"united-states"|america)
      printf '1'
      ;;
    *)
      return 1
      ;;
  esac
}

# Determine the home country code for E.164 numbers
# Priority:
#  - HOME_CC if set (digits only, e.g., 49)
#  - Derive from OWN_NUMBER (heuristic: +1 -> 1, otherwise first two digits)
get_home_cc() {
  local target_mid="${1:-}"
  local cc=""
  if [[ -n "$HOME_CC" ]]
  then
    cc="${HOME_CC//[^0-9]/}"
    printf '%s' "$cc"
    return 0
  fi

  # Prefer using load_own_number to respect current MODEM context
  local own=""
  if [[ -n "$target_mid" ]]
  then
    if MODEM="$target_mid" load_own_number
    then
      own="$OWN_NUMBER"
    fi
  elif load_own_number
  then
    own="$OWN_NUMBER"
  fi

  if [[ -z "$own" ]]
  then
    # Fallback to direct mmcli parsing
    local j

    if [[ -n "$target_mid" ]]
    then
      j="$(mmcli -m "$target_mid" -J)"
    else
      j="$(mmcli_cmd -J)"
    fi

    if [[ -n "$j" ]]
    then
      own="$(jq -r '.modem.generic["own-numbers"][0] // empty' <<<"$j")"
    fi
  fi

  if [[ "$own" == +* ]]
  then
    local digits="${own#+}"
    if [[ "$digits" == 1* ]]
    then
      cc="1"
    else
      cc="${digits:0:2}"
    fi
    printf '%s' "$cc"
    return 0
  fi

  return 1
}

# Return a concise modem info string for logs: id=.. manufacturer=.. model=.. plugin=.. primary=..
modem_info_brief() {
  local j info id manufacturer model plugin primary own ports cc=""

  if j="$(mmcli_cmd -J)"
  then
    id="$(jq -r '.modem["dbus-path"] | split("/")[-1] // empty' <<<"$j")"
    manufacturer="$(jq -r '.modem.generic.manufacturer // "--"' <<<"$j")"
    model="$(jq -r '.modem.generic.model // "--"' <<<"$j")"
    plugin="$(jq -r '.modem.generic.plugin // "--"' <<<"$j")"
    primary="$(jq -r '.modem.generic["primary-port"] // "--"' <<<"$j")"
    ports="$(jq -r '(.modem.generic.ports // []) | map(split(" ")[0]) | join(",")' <<<"$j")"
    own="$(jq -r '.modem.generic["own-numbers"][0] // empty' <<<"$j")"
    own="$(ensure_plus "$own")"
    [[ -n "$ports" ]] || ports="--"
    [[ -n "$own" ]] || own="--"

    if [[ "$own" == +* ]]
    then
      local digits="${own#+}"
      if [[ "$digits" == 1* ]]
      then
        cc="1"
      else
        cc="${digits:0:2}"
      fi
    fi

    if [[ -n "$id" ]]
    then
      info="id='$id' manufacturer='$manufacturer' model='$model' plugin='$plugin' primary='$primary'"
      if [[ -n "$ports" ]]
      then
        info+=" ports='$ports'"
      fi
      info+=" phone='$own'"
      if [[ -n "$cc" ]]
      then
        info+=" cc='$(cc_to_label "$cc")'"
      fi
      printf '%s' "$info"
      return 0
    fi
  fi

  printf "id='%s'" "$MODEM"
}

# Derive a simple country code from a phone number in +E.164 form
phone_cc() {
  local n="$1"
  if [[ "$n" == +* ]]
  then
    local d="${n#+}"

    if [[ "$d" == 1* ]]
    then
      printf '1'
      return 0
    fi

    printf '%s' "${d:0:2}"
    return 0
  fi

  printf '%s' "--"
}

# Map a numeric country calling code to a short human-readable label
cc_to_label() {
  case "$1" in
    1) printf 'US' ;;
    33) printf 'FR' ;;
    49) printf 'DE' ;;
    *) printf '%s' "$1" ;;
  esac
}

# Return a human-readable CC label (US/FR/DE) for a +E.164 phone number
phone_cc_label() {
  local cc
  cc="$(phone_cc "$1")"
  cc_to_label "$cc"
}

# Ensure a phone/MSISDN has leading '+' when it's only digits
ensure_plus() {
  local n="${1:-}"

  if [[ -z "$n" ]]
  then
    printf '%s' ""
    return 0
  fi

  if [[ "$n" != +* && "$n" =~ ^[0-9]+$ ]]
  then
    printf '+%s' "$n"
  else
    printf '%s' "$n"
  fi
}

# Abbreviate text for logs: strip CR, escape newlines/backslashes, and truncate
abbrev_text_for_log() {
  local s="${1:-}"
  local maxlen="${2:-$LOG_ABBREV_LEN}"

  s=${s//$'\r'/}
  s=${s//$'\n'/\\n}
  s=${s//\\/\\\\}

  if [[ -z "$s" ]]
  then
    s="<empty>"
  fi

  if (( ${#s} > maxlen ))
  then
    s="${s:0:maxlen}…"
  fi

  printf '%s' "$s"
}

# Map mmcli SMS pdu-type to a friendly type label
pdu_to_type() {
  local pdu="${1,,}"
  case "$pdu" in
    deliver) printf 'received' ;;
    submit) printf 'sent' ;;
    status-report) printf 'report' ;;
    *) printf '%s' "$1" ;;
  esac
}

# List modem ids sorted numerically (one per line)
list_modem_ids_sorted() {
  local list_json
  if ! list_json="$(mmcli -L -J)"
  then
    return 1
  fi

  jq -r '."modem-list"[]? | split("/")[-1]' <<<"$list_json" | sort -n
}

log_modem_details() {
  local mid="$1" prefix="${2:-}"
  [[ -z "$mid" ]] && return 1

  local mjson fields id manufacturer model plugin primary ports phone info
  if mjson="$(mmcli -m "$mid" -J)"
  then
    fields="$(jq -r '
      .modem as $m
      | [
          ($m["dbus-path"] | split("/")[-1] // ""),
          ($m.generic.manufacturer // "--"),
          ($m.generic.model // "--"),
          ($m.generic.plugin // "--"),
          ($m.generic["primary-port"] // "--"),
          (($m.generic.ports // []) | map(split(" ")[0]) | join(",")),
          ($m.generic["own-numbers"][0] // "")
        ]
      | @tsv
    ' <<<"$mjson")"

    if [[ -z "$fields" ]]
    then
      echo_info "${prefix}modem={id='$mid'}"
      return 0
    fi

    IFS=$'\t' read -r id manufacturer model plugin primary ports phone <<<"$fields"
    phone="$(ensure_plus "$phone")"

    [[ -n "$ports" ]] || ports="--"
    [[ -n "$id" ]] || id="$mid"
    [[ -n "$phone" ]] || phone="--"

    local cc_label
    cc_label="$(phone_cc_label "$phone")"
    [[ -n "$cc_label" ]] || cc_label="--"

    printf -v info "id='%s' manufacturer='%s' model='%s' plugin='%s' primary='%s' ports='%s' phone='%s' cc='%s'" \
      "$id" "$manufacturer" "$model" "$plugin" "$primary" "$ports" "$phone" "$cc_label"
    echo_info "${prefix}modem={${info}}"
  else
    echo_info "${prefix}modem={id='$mid'}"
  fi
}

get_modem_at_port() {
  local json port

  echo_debug "AT fallback resolving modem port"
  if ! json="$(mmcli -m "$MODEM" -J)"
  then
    echo_debug "get_modem_at_port: failed to query modem JSON"
    return 1
  fi

  port="$(jq -r '
    ((.modem.generic.ports // [])
      | map(select(startswith("at")) | (split(" ")[0]))
      | .[0])
    // (.modem.generic["primary-port"] // empty)
  ' <<<"$json")"

  if [[ -z "$port" ]]
  then
    echo_debug "get_modem_at_port: no AT port detected"
    return 1
  fi

  if [[ "$port" != /* ]]
  then
    port="/dev/$port"
  fi

  echo_debug "get_modem_at_port: resolved port to $port"

  if [[ ! -e "$port" ]]
  then
    echo_debug "get_modem_at_port: port $port not present"
    return 1
  fi

  printf '%s' "$port"
}

at_command_direct() {
  local cmd="$1"
  local port

  if ! port="$(get_modem_at_port)"
  then
    return 1
  fi

  if [[ ! -w "$port" ]]
  then
    echo_debug "at_command_direct: port $port not writable"
    return 1
  fi

  local fd
  echo_debug "AT fallback open $port"
  if ! exec {fd}<>"$port"
  then
    echo_debug "at_command_direct: failed to open $port"
    return 1
  fi

  local _drain
  while read -r -t "$AT_FALLBACK_READ_TIMEOUT" -u $fd _drain
  do
    :
  done

  echo_debug "AT fallback TX -> $cmd"
  printf '%s\r' "$cmd" >&$fd

  local resp="" line="" timeout_count=0
  while (( timeout_count < AT_FALLBACK_MAX_READS ))
  do
    if ! read -r -t "$AT_FALLBACK_READ_TIMEOUT" -u $fd line
    then
      timeout_count=$((timeout_count + 1))
      continue
    fi

    timeout_count=0
    line="${line%$'\r'}"

    [[ "$line" == "$cmd" ]] && continue

    if [[ -n "$line" ]]
    then
      echo_debug "AT fallback RX <- $line"
      resp+="$line"$'\n'
      if [[ "$line" == "OK" || "$line" == "ERROR" ]]
      then
        break
      fi
    fi
  done

  exec {fd}>&- {fd}<&-

  resp="${resp%$'\n'}"
  if [[ -n "$resp" ]]
  then
    printf '%s' "$resp"
    return 0
  fi

  return 1
}

configure_huawei_modem() {
  echo_info "huawei: configuring modem for SMS text mode"
  local resp
  resp="$(at_command 'AT')"
  echo_info "huawei: AT (baseline connectivity check) -> $(format_at_response "$resp")"
  resp="$(at_command 'AT+CMEE=2')"
  echo_info "huawei: AT+CMEE=2 (enable verbose error codes) -> $(format_at_response "$resp")"
  resp="$(at_command 'AT+CMGF?')"
  echo_info "huawei: AT+CMGF? (query SMS message format) -> $(format_at_response "$resp")"
}

configure_modem_vendor() {
  local info_json="$1"
  local plugin manufacturer
  plugin="$(jq -r '.modem.generic.plugin // ""' <<<"$info_json")"
  manufacturer="$(jq -r '.modem.generic.manufacturer // ""' <<<"$info_json")"
  local lower_plugin="${plugin,,}"
  local lower_manufacturer="${manufacturer,,}"

  if [[ "$lower_plugin" == huawei || "$lower_manufacturer" == huawei* ]]
  then
    configure_huawei_modem
  fi
}

# Resolve default recipient based on modem/country-specific variables.
# Order:
#  - DEFAULT_RECIPIENT_<LABEL> (US/FR/DE)
#  - DEFAULT_RECIPIENT_<CC> (1/33/49)
#  - DEFAULT_RECIPIENT
resolve_default_recipient() {
  local mid="${1:-}"
  local cc label var val
  cc="$(get_home_cc "$mid")"
  echo_debug "resolve_default_recipient: mid=${mid:-} cc=${cc:-}"

  # Guard: unknown CC → fall back to global default or fail
  if [[ -z "$cc" ]]
  then
    if [[ -n "${DEFAULT_RECIPIENT-}" ]]
    then
      echo_debug "resolve_default_recipient: cc unknown, using DEFAULT_RECIPIENT=${DEFAULT_RECIPIENT}"
      printf '%s' "${DEFAULT_RECIPIENT}"
      return 0
    fi

    echo_debug "resolve_default_recipient: cc unknown and no DEFAULT_RECIPIENT"
    return 1
  fi

  case "$cc" in
    1) label=US ;;
    33) label=FR ;;
    49) label=DE ;;
    *) label="" ;;
  esac

  # Try label-specific var
  if [[ -n "$label" ]]
  then
    var="DEFAULT_RECIPIENT_${label}"
    echo_debug "resolve_default_recipient: try $var"
    if declare -p "$var" >/dev/null 2>&1
    then
      val="${!var}"
      if [[ -n "$val" ]]
      then
        echo_debug "resolve_default_recipient: matched $var=$val"
        printf '%s' "$val"
        return 0
      fi
    fi
  fi

  # Try numeric-CC specific var
  var="DEFAULT_RECIPIENT_${cc}"
  echo_debug "resolve_default_recipient: try $var"
  if declare -p "$var" >/dev/null 2>&1
  then
    val="${!var}"
    if [[ -n "$val" ]]
    then
      echo_debug "resolve_default_recipient: matched $var=$val"
      printf '%s' "$val"
      return 0
    fi
  fi

  # Global default
  if [[ -n "${DEFAULT_RECIPIENT-}" ]]
  then
    echo_debug "resolve_default_recipient: default DEFAULT_RECIPIENT=${DEFAULT_RECIPIENT}"
    printf '%s' "${DEFAULT_RECIPIENT}"
    return 0
  fi

  echo_debug "resolve_default_recipient: no default found"
  return 1
}

# Run an AT command via mmcli and return the response string
# - Strips the leading "response: '...'") wrapper printed by mmcli
# - If no such wrapper is present, returns raw stdout/stderr as-is
at_command() {
  local cmd="$1"
  local out resp

  out="$(mmcli_cmd --command="$cmd" 2>&1)"
  local rc=$?

  if (( rc == 0 ))
  then
    resp="$(printf '%s\n' "$out" | sed -n "s/^response: '\(.*\)'$/\1/p" | head -n1)"
    if [[ -z "$resp" ]]
    then
      resp="$out"
    fi
    printf '%s' "$resp"
    return 0
  fi

  echo_debug "at_command: mmcli --command failed (rc=$rc), attempting direct fallback"
  if resp="$(at_command_direct "$cmd")"
  then
    printf '%s' "$resp"
    return 0
  fi

  printf '%s' "$out"
  return $rc
}

format_at_response() {
  local resp="$1"

  if [[ -z "$resp" ]]
  then
    printf '%s' '<no response>'
    return 0
  fi

  resp="${resp//$'\n'/'; '}"
  printf '%s' "$resp"
}

# Decode a UCS2 hex string like "002B0033..." by taking the low byte of each code unit
at_decode_ucs2() {
  local s="$1"

  if [[ "$s" =~ ^([0-9A-Fa-f]{4})+$ ]]
  then
    local out=""
    local pos=0 len=${#s} hb
    while (( pos < len ))
    do
      hb="${s:pos+2:2}"
      out+="$(printf '%b' "\\x$hb")"
      pos=$((pos + 4))
    done

    printf '%s' "$out"
    return 0
  fi

  printf '%s' "$s"
}

# Extract the first double-quoted field from an AT response and decode UCS2 if applicable
at_first_quoted_decoded() {
  local resp="$1"

  local q
  q="$(printf '%s\n' "$resp" | sed -n 's/^.*"\([^"]*\)".*$/\1/p' | head -n1)"

  if [[ -z "$q" ]]
  then
    return 1
  fi

  if [[ "$q" =~ ^([0-9A-Fa-f]{4})+$ ]]
  then
    q="$(at_decode_ucs2 "$q")"
  fi

  printf '%s' "$q"
}

# Log and run generic mmcli calls (no implicit --modem)
mmcli() {
  echo_debug "\$ mmcli $*"
  command mmcli "$@"
}

# Resolve a human-friendly modem selector to a concrete modem id
# - Accepts: numeric id (e.g., 2), D-Bus path, 'any', or a substring
#   matching manufacturer, plugin, primary-port, or any ttyUSB/wwan port.
# - On multiple matches, prints a modem list to stderr and returns non-zero.
# - On no match, reports an error and shows the list.
get_modem_id() {
  local sel_raw="${1:-}"
  local sel

  # Default / passthrough cases
  if [[ -z "$sel_raw" || "$sel_raw" == any ]]
  then
    printf '%s' "any"
    return 0
  fi

  # If a D-Bus path (/org/.../Modem/N)
  if [[ "$sel_raw" == */Modem/* ]]
  then
    printf '%s' "${sel_raw##*/}"
    return 0
  fi

  # Case-insensitive substring match on fields (unless country filter applies)
  sel="${sel_raw,,}"

  local list_json ids id json
  if ! list_json="$(mmcli -L -J)"
  then
    error "could not query modem list via mmcli"
    return 1
  fi

  # Collect modem ids
  mapfile -t ids < <(jq -r '."modem-list"[]? | split("/")[-1]' <<<"$list_json")
  if (( ${#ids[@]} == 0 ))
  then
    error "no modems detected"
    return 1
  fi

  # If pure numeric input, treat as id only if it matches a detected id; otherwise
  # continue with fuzzy matching (e.g., phone number fragment)
  if [[ "$sel_raw" =~ ^[0-9]+$ ]]
  then
    local _id
    for _id in "${ids[@]}"
    do
      if [[ "$_id" == "$sel_raw" ]]
      then
        printf '%s' "$sel_raw"
        return 0
      fi
    done
  fi

  local matches=()
  local cc_filter=""
  cc_filter="$(country_to_cc "$sel_raw")"

  for id in "${ids[@]}"
  do
    [[ -z "$id" ]] && continue
    if ! json="$(mmcli -m "$id" -J)"
    then
      continue
    fi

    # Extract candidate fields and match
    local fields numbers sel_digits
    fields="$(jq -r '
      .modem.generic as $g
      | [
          ($g.manufacturer // ""),
          ($g.plugin // ""),
          ($g["primary-port"] // ""),
          (($g.ports // [])[]? | (split(" ")[0]))
        ] | .[]
    ' <<<"$json")"
    numbers="$(jq -r '.modem.generic["own-numbers"][]? // empty' <<<"$json")"
    sel_digits="${sel_raw//[^0-9+]/}"

    local matched=0
    if [[ -n "$cc_filter" && -n "$numbers" ]]
    then
      # Country code filter: match if any own-number starts with +<cc>
      local n
      while IFS= read -r n
      do
        [[ -z "$n" ]] && continue
        n="${n#+}"
        if [[ "$n" == "$cc_filter"* ]]
        then
          matched=1; break
        fi
      done <<< "$numbers"
    else
      # Generic substring/regex and number substring matching
      if [[ -n "$fields" ]]
      then
        local f lf
        while IFS= read -r f
        do
          lf="${f,,}"
          if [[ "$lf" == *"$sel"* ]]
          then
            matched=1; break
          fi
        done <<< "$fields"
      fi

      if (( matched == 0 )) && [[ -n "$numbers" ]]
      then
        local n nd
        while IFS= read -r n
        do
          [[ -z "$n" ]] && continue
          nd="${n//[^0-9+]/}"
          if [[ "${n,,}" == *"${sel_raw,,}"* ]] || { [[ -n "$sel_digits" ]] && [[ "$nd" == *"$sel_digits"* ]]; }
          then
            matched=1; break
          fi

          if printf '%s\n' "$n" | grep -Eq -- "$sel_raw"
          then
            matched=1; break
          fi
        done <<< "$numbers"
      fi
    fi

    if (( matched == 1 ))
    then
      matches+=("$id")
    fi
  done

  if (( ${#matches[@]} == 1 ))
  then
    printf '%s' "${matches[0]}"
    return 0
  fi

  # Helper to show available modems for disambiguation
  echo_error "${SCRIPT_NAME}: modem selector '${sel_raw}' matched ${#matches[@]} modem(s)" >&2
  echo_info "Available modems:" >&2

  for id in "${ids[@]}"
  do
    [[ -z "$id" ]] && continue

    if ! json="$(mmcli -m "$id" -J)"
    then
      continue
    fi

    jq -r '
      .modem as $m
      | {
          id: ($m["dbus-path"] | split("/")[-1]),
          manufacturer: ($m.generic.manufacturer // "--"),
          model: ($m.generic.model // "--"),
          plugin: ($m.generic.plugin // "--"),
          primary: ($m.generic["primary-port"] // "--"),
          ports: (($m.generic.ports // []) | map(split(" ")[0]) | join(","))
        }
      | ("  " + .id + ": " + .manufacturer + " " + .model
         + " plugin=" + .plugin
         + " primary=" + .primary
         + " ports=" + .ports)
    ' <<<"$json" >&2
  done

  if (( ${#matches[@]} == 0 ))
  then
    return 1
  fi

  # FIXME Ambiguous
  return 2
}

mmcli_cmd() {
  # shellcheck disable=SC2031
  echo_debug "[mmcli] mmcli --modem $MODEM $*"
  # shellcheck disable=SC2031
  command mmcli --modem "$MODEM" "$@"
}

sms_read() {
  local msg_id="$1"
  mmcli_cmd --sms "$msg_id"
}

sms_read_json() {
  local msg_id="$1"
  local js pdu msg_type own=""

  if ! js="$(mmcli_cmd --sms "$msg_id" -J)"
  then
    return 1
  fi

  pdu="$(jq -r '.sms.properties["pdu-type"] // ""' <<<"$js")"
  msg_type="$(pdu_to_type "$pdu")"

  if load_own_number
  then
    own="$OWN_NUMBER"
  fi

  jq --arg type "$msg_type" --arg own "$own" '
    .sms as $s
    | {
        id: ($s["dbus-path"] | split("/")[-1] | tonumber?),
        sender: ($s.content.number // ""),
        text: ($s.content.text // ""),
        class: ($s.properties.class // ""),
        state: ($s.properties.state // ""),
        pdu: ($s.properties["pdu-type"] // ""),
        storage: ($s.properties.storage // ""),
        smsc: ($s.properties.smsc // ""),
        timestamp: ($s.properties.timestamp // ""),
        discharge_timestamp: ($s.properties["discharge-timestamp"] // ""),
        delivery_state: ($s.properties["delivery-state"] // ""),
        delivery_report: ($s.properties["delivery-report"] // ""),
        type: $type,
        recipient: (if $type == "received" then $own else ($s.content.number // "") end)
      }
  ' <<<"$js"
}

sms_send() {
  local recipient=""
  local text=""
  local recipient_was_default=0

  # Parse args: allow default recipient when not specified
  if (( $# >= 1 ))
  then
    if [[ "$1" == "-" ]]
    then
      shift
    elif [[ "$1" == +* || "$1" =~ ^[0-9]+$ ]]
    then
      recipient="$1"
      shift
    fi
  fi

  if (( $# == 0 ))
  then
    if [[ -t 0 ]]
    then
      error "no SMS text provided"
      return 2
    fi
    text="$(cat)"
  elif [[ "$1" == "-" ]]
  then
    shift
    text="$(cat)"
  else
    text="$*"
  fi

  if [[ -z "$recipient" ]]
  then
    # Try to load defaults from config when sending without explicit recipient
    # shellcheck disable=SC2031
    recipient="$(resolve_default_recipient "$MODEM")"
    if [[ -z "$recipient" ]]
    then
      error "no recipient specified and no DEFAULT_RECIPIENT configured for this modem/country"
      return 2
    fi
    recipient_was_default=1
  fi

  recipient="${recipient//[[:space:]]/}"
  recipient="$(ensure_plus "$recipient")"

  SMS_LAST_RECIPIENT="$recipient"
  SMS_LAST_RECIPIENT_FROM_DEFAULT="$recipient_was_default"

  # Enforce local-only sending unless --allow-foreign is set
  if [[ -z "$ALLOW_FOREIGN" ]]
  then
    local home_cc
    # shellcheck disable=SC2031
    home_cc="$(get_home_cc "$MODEM")"
    if [[ -n "$home_cc" && "$recipient" == +([0-9]) ]]
    then
      if [[ "$recipient" != +"$home_cc"* ]]
      then
        echo_warning "blocking foreign recipient $recipient (home CC=$home_cc); use --allow-foreign to override or set HOME_CC"
        return 1
      fi
    fi
  fi

  if [[ -z "$text" ]]
  then
    error "no SMS text provided"
    return 2
  fi

  # Expand common escapes and strip trailing whitespace to avoid stray spaces
  text="$(printf '%b' "$text" | sed -e 's/[[:space:]]\+$//')"

  # Log outgoing SMS (preview) to stderr and syslog
  local log_text
  log_text="$(abbrev_text_for_log "$text")"
  local log_modem
  log_modem="$(modem_info_brief)"
  echo_info "sending sms with modem={$log_modem} recipient=$recipient text='$log_text'"

  local tmpfile
  if ! tmpfile="$(mktemp "${TMPDIR:-/tmp}/mmsms-text.XXXXXX")"
  then
    error "failed to create temporary file for SMS text"
    return 1
  fi

  if ! printf '%s' "$text" >"$tmpfile"
  then
    rm -f "$tmpfile"
    error "failed to write SMS text to temporary file"
    return 1
  fi

  local sms_id=""
  local smsc_raw
  local smsc
  local smsc_params=""
  smsc_raw="$(get_smsc_number)"
  if [[ -n "$smsc_raw" ]]
  then
    smsc="${smsc_raw//[[:space:]]/}"

    if [[ -n "$smsc" && "$smsc" != +* ]]
    then
      smsc="+$smsc"
    fi

    if [[ -n "$smsc" && "$smsc" =~ ^\+[0-9]+$ ]]
    then
      smsc_params=",smsc=$smsc"
    elif [[ -n "$smsc_raw" ]]
    then
      echo_warning "invalid smsc '$smsc_raw', skipping"
      smsc=""
    fi
  fi

  local create_attempt=1
  local max_attempts=$SMS_RETRY_COUNT
  local rc=1

  # Create the SMS first (retrying creation only if creation itself fails)
  if (( max_attempts < 1 )); then max_attempts=1; fi

  while (( create_attempt <= max_attempts ))
  do
    sms_id=""
    local create_json
    create_json=""
    if ! create_json="$(mmcli_cmd -J --messaging-create-sms="number=${recipient}${smsc_params}" \
      --messaging-create-sms-with-text="$tmpfile")"
    then
      if (( create_attempt == max_attempts ))
      then
        error "failed to create SMS after $max_attempts attempts"
        rm -f "$tmpfile"
        return 1
      fi

      echo_warning "failed to create SMS (attempt $create_attempt/$max_attempts), retrying"
      create_attempt=$((create_attempt + 1))
      continue
    fi

    if ! sms_id="$(jq -r '.modem.messaging["created-sms"] // empty' <<<"$create_json")"
    then
      sms_id=""
    fi

    if [[ -z "$sms_id" ]]
    then
      if (( create_attempt == max_attempts ))
      then
        error "failed to create SMS after $max_attempts attempts"
        rm -f "$tmpfile"
        return 1
      fi

      echo_warning "received empty SMS id (attempt $create_attempt/$max_attempts), retrying"
      create_attempt=$((create_attempt + 1))
      continue
    fi
    break
  done

  # Now retry only the send step for the created SMS id
  local send_attempt=1
  if (( max_attempts < 1 )); then max_attempts=1; fi

  while (( send_attempt <= max_attempts ))
  do
    if mmcli_cmd --sms "$sms_id" --send --timeout="$SMS_SEND_TIMEOUT"
    then
      rc=0
      echo_success "message sent with modem={$log_modem} recipient=$recipient"
      break
    fi

    if (( send_attempt == max_attempts ))
    then
      error "failed to send SMS after $max_attempts attempts"
      break
    fi

    echo_warning "failed to send SMS (attempt $send_attempt/$max_attempts), retrying"
    send_attempt=$((send_attempt + 1))
  done

  # direct send failure logs use echo_warning at call site; SYSLOG_MIRROR handles mirroring

  rm -f "$tmpfile"
  return $rc
}

# Determine if a recipient is allowed for a given modem id based on
# --allow-foreign/HOME_CC. Returns 0 if allowed, 1 if blocked.
recipient_allowed_for_modem() {
  local recipient="$1"
  local mid="$2"

  if [[ -n "$ALLOW_FOREIGN" ]]
  then
    return 0
  fi

  local hcc
  hcc="$(get_home_cc "$mid")"

  if [[ -z "$hcc" ]]
  then
    echo_warning "Failed to determine home CC for modem id '$mid', blocking foreign recipient $recipient"
    return 1
  fi

  if [[ "$recipient" == +"$hcc"* ]]
  then
    return 0
  fi

  return 1
}

sms_send_with_fallback() {
  local orig_args=("$@")
  local args=("$@")
  local recipient=""
  local text=""

  # First attempt with the original arguments
  if sms_send "${orig_args[@]}"
  then
    return 0
  fi

  if [[ -z "$FALLBACK" ]]
  then
    return 1
  fi

  # Parse optional recipient from arguments
  if (( ${#args[@]} > 0 ))
  then
    case "${args[0]}" in
      -)
        args=("${args[@]:1}")
        ;;
      +*|[0-9]*)
        recipient="${args[0]}"
        args=("${args[@]:1}")
        ;;
    esac
  fi

  if (( ${#args[@]} > 0 )) && [[ "${args[0]}" == "-" ]]
  then
    args=("${args[@]:1}")
  fi

  if (( ${#args[@]} > 0 ))
  then
    text="${args[*]}"
  fi

  if [[ -z "$text" ]]
  then
    echo_warning "fallback: message text unavailable for resend"
    return 1
  fi

  local resolved_recipient="${SMS_LAST_RECIPIENT:-$recipient}"
  local orig_recipient_default_flag="${SMS_LAST_RECIPIENT_FROM_DEFAULT:-0}"
  recipient="$resolved_recipient"

  # Gather other modems
  local mids mid cur_id
  cur_id="$MODEM"
  if [[ "$cur_id" == "any" ]]
  then
    local _j
    if _j="$(mmcli_cmd -J)"
    then
      cur_id="$(jq -r '.modem["dbus-path"] | split("/")[-1] // empty' <<<"$_j")"
    fi
  fi

  if ! mapfile -t mids < <(list_modem_ids_sorted)
  then
    return 1
  fi

  for mid in "${mids[@]}"
  do
    [[ -z "$mid" || "$mid" == "$cur_id" ]] && continue
    local prev_mode="$MODEM"
    MODEM="$mid"
    local candidate_recipient="$recipient"
    local used_auto=""
    local auto_tried=0

    if ! recipient_allowed_for_modem "$candidate_recipient" "$mid"
    then
      if [[ -n "$AUTO_RECIPIENT" && "$orig_recipient_default_flag" == "1" ]]
      then
        auto_tried=1
        local auto_recipient
        if auto_recipient="$(resolve_default_recipient "$mid")"
        then
          auto_recipient="${auto_recipient//[[:space:]]/}"
          auto_recipient="$(ensure_plus "$auto_recipient")"
        else
          auto_recipient=""
        fi

        if [[ -n "$auto_recipient" ]] && ! recipient_allowed_for_modem "$auto_recipient" "$mid"
        then
          auto_recipient=""
        fi

        if [[ -n "$auto_recipient" ]]
        then
          candidate_recipient="$auto_recipient"
          used_auto=1
        fi
      fi

      if [[ -z "$used_auto" ]]
      then
        local info
        info="$(modem_info_brief)"
        if [[ "$auto_tried" == 1 ]]
        then
          echo_warning "fallback: modem=$info has no eligible default recipient (auto-recipient unavailable)"
        else
          echo_warning "fallback: cannot use modem=$info for recipient $recipient (foreign not allowed; use --allow-foreign)"
        fi
        MODEM="$prev_mode"
        continue
      fi
    fi

    if [[ -n "$used_auto" ]]
    then
      local info
      info="$(modem_info_brief)"
      echo_info "fallback: using modem=$info default_recipient='$candidate_recipient'"
    fi

    echo_debug "fallback: sending text='$text'"
    echo_debug "fallback: trying modem $mid"

    if sms_send "$candidate_recipient" "$text"
    then
      local info
      info="$(modem_info_brief)"
      MODEM="$prev_mode"

      echo_info "fallback send succeeded using modem=$info"
      return 0
    fi
    MODEM="$prev_mode"
  done

  echo_warning "fallback: no eligible modem could send the message"
  return 1
}

sms_prune_all() {
  local ids
  mapfile -t ids < <(mmcli_cmd --messaging-list-sms -J | \
    jq -r '."modem.messaging.sms"[]? | split("/")[-1]' | sort -n)

  local total=${#ids[@]}
  if (( total == 0 ))
  then
    return 0
  fi

  local i=0 sms_id
  for sms_id in "${ids[@]}"
  do
    [[ -z "$sms_id" ]] && continue
    i=$((i + 1))
    echo_info "deleting SMS $sms_id ($i/$total)"
    if ! mmcli_cmd --messaging-delete-sms="$sms_id"
    then
      error "failed to delete SMS $sms_id"
    fi
  done
}

sms_prune_sent() {
  # Delete only messages that are outgoing and already sent
  local list ids id js state pdu sent_ids=()

  if ! list="$(mmcli_cmd --messaging-list-sms -J)"
  then
    return 0
  fi

  mapfile -t ids < <(jq -r '
    ."modem.messaging.sms"[]? | split("/")[-1] | sort
  ' <<<"$list")

  if (( ${#ids[@]} == 0 ))
  then
    return 0
  fi

  # First collect sent IDs
  for id in "${ids[@]}"
  do
    [[ -z "$id" ]] && continue
    if ! js="$(mmcli_cmd --sms "$id" -J)"
    then
      echo_warning "failed to read SMS $id, skipping"
      continue
    fi
    state="$(jq -r '.sms.properties.state // empty' <<<"$js")"
    pdu="$(jq -r '.sms.properties["pdu-type"] // empty' <<<"$js")"
    if [[ "$state" == "sent" && "$pdu" == "submit" ]]
    then
      sent_ids+=("$id")
    fi
  done

  local total=${#sent_ids[@]}
  if (( total == 0 ))
  then
    return 0
  fi

  local i=0
  for id in "${sent_ids[@]}"
  do
    i=$((i + 1))
    echo_info "deleting sent SMS $id ($i/$total)"
    mmcli_cmd --messaging-delete-sms="$id"
  done
}

sms_prune_sent_modems() {
  local mids mid

  if ! mapfile -t mids < <(list_modem_ids_sorted)
  then
    error "failed to list modems for pruning"
    return 1
  fi

  if (( ${#mids[@]} == 0 ))
  then
    echo_info "no modems detected"
    return 0
  fi

  for mid in "${mids[@]}"
  do
    [[ -z "$mid" ]] && continue
    echo_info "pruning sent messages on modem $mid"
    MODEM=$mid sms_prune_sent || error "failed to prune sent messages on modem $mid"
  done
}

sms_prune_all_modems() {
  local mids mid
  if ! mapfile -t mids < <(list_modem_ids_sorted)
  then
    error "failed to list modems for pruning"
    return 1
  fi

  if (( ${#mids[@]} == 0 ))
  then
    echo_info "no modems detected"
    return 0
  fi

  for mid in "${mids[@]}"
  do
    [[ -z "$mid" ]] && continue
    echo_info "pruning modem $mid"
    MODEM="$mid" sms_prune_all || error "failed to prune on modem $mid"
  done
}

sms_list_print_header() {
  local include_mid="$1"
  local noc="$2"
  local header

  if [[ "$include_mid" == "1" ]]
  then
    header="$(printf '%-4s %-4s %-10s %-18s %s' 'MID' 'ID' 'TYPE' 'RECIPIENT' 'MSG')"
  else
    header="$(printf '%-4s %-10s %-18s %s' 'ID' 'TYPE' 'RECIPIENT' 'MSG')"
  fi

  if [[ -n "$noc" ]]
  then
    printf '%s\n' "$header"
  else
    printf '\e[1m%s\e[0m\n' "$header"
  fi
}

sms_list_print_entry() {
  local mid="$1"
  local id="$2"
  local js="$3"
  local include_mid="$4"
  local maxlen="${5:-80}"
  local sender text msg_type pdu

  sender="$(jq -r '.sms.content.number // "--"' <<<"$js")"
  sender="$(ensure_plus "$sender")"
  pdu="$(jq -r '.sms.properties["pdu-type"] // ""' <<<"$js")"
  msg_type="$(pdu_to_type "$pdu")"
  text="$(jq -r '.sms.content.text // ""' <<<"$js")"
  text=${text//$'\r'/}
  text=${text//$'\n'/\\n}
  if (( ${#text} > maxlen ))
  then
    text="${text:0:maxlen}…"
  fi

  if [[ "$include_mid" == "1" ]]
  then
    printf '%-4s %-4s %-10s %-18s %s\n' "$mid" "$id" "$msg_type" "$sender" "$text"
  else
    printf '%-4s %-10s %-18s %s\n' "$id" "$msg_type" "$sender" "$text"
  fi
}

sms_list_pretty() {
  local list_json ids id js sender text msg_type pdu line maxlen=80

  # When listing for all modems, iterate them explicitly
  if [[ -n "$ALL_MODEMS" ]]
  then
    local mids mid had_any=""
    if ! mapfile -t mids < <(list_modem_ids_sorted)
    then
      error "failed to list modems"
      return 1
    fi

    if (( ${#mids[@]} == 0 ))
    then
      if [[ -n "$JSON_OUTPUT$RAW_OUTPUT" ]]
      then
        printf '[]\n'
      else
        echo_info "no SMS messages"
      fi

      return 0
    fi

    if [[ -z "$MODEM_DETAILS_LOGGED" ]]
    then
      echo_info "modems in scope:"
      for mid in "${mids[@]}"
      do
        [[ -z "$mid" ]] && continue
        log_modem_details "$mid"
      done
      MODEM_DETAILS_LOGGED=1
    fi

    if [[ -n "$RAW_OUTPUT" ]]
    then
      local raw_items
      raw_items="$(
        for mid in "${mids[@]}"
        do
          [[ -z "$mid" ]] && continue

          if ! list_json="$(mmcli --modem "$mid" --messaging-list-sms -J)"
          then
            continue
          fi

          mapfile -t ids < <(jq -r '."modem.messaging.sms"[]? | split("/")[-1]' <<<"$list_json")

          for id in "${ids[@]}"
          do
            [[ -z "$id" ]] && continue
            js="$(mmcli --modem "$mid" --sms "$id" -J)"

            if [[ -n "$js" ]]
            then
              jq -e -c --arg mid "$mid" '{modem_id: ($mid|tonumber), sms: .}' <<<"$js"
            fi
          done
        done
      )"
      if [[ -z "$raw_items" ]]
      then
        printf '[]\n'
      else
        printf '%s\n' "$raw_items" | jq -s '.'
      fi
      return 0
    fi

    if [[ -n "$JSON_OUTPUT" ]]
    then
      if [[ -n "$ALL_MODEMS" && -z "$target_mid" ]]
      then
        local mids mid json_items=()

        if mapfile -t mids < <(list_modem_ids_sorted)
        then
          for mid in "${mids[@]}"
          do
            [[ -z "$mid" ]] && continue
            local item
            item="$(MODEM="$mid" ALL_MODEMS="" JSON_OUTPUT=1 RAW_OUTPUT="" modem_status_single)"
            [[ -n "$item" ]] && json_items+=("$item")
          done
        fi

        if (( ${#json_items[@]} == 0 ))
        then
          printf '[]\n'
        else
          printf '%s\n' "${json_items[@]}" | jq -s '.'
        fi

        return 0
      fi

      local json_output
      json_output="$(JSON_OUTPUT=1 RAW_OUTPUT="" modem_status_single)"
      if [[ -n "$json_output" ]]
      then
        printf '%s
  ' "$json_output"
        return 0
      fi
    fi

    # Pretty output across all modems: add a MID column
    local _nocolor=""
    if [[ -n "$NO_COLOR" || -n "$CRON" ]]
    then
      _nocolor=1
    fi
    sms_list_print_header 1 "$_nocolor"

    for mid in "${mids[@]}"
    do
      [[ -z "$mid" ]] && continue
      if ! list_json="$(mmcli --modem "$mid" --messaging-list-sms -J)"
      then
        continue
      fi
      mapfile -t ids < <(jq -r '."modem.messaging.sms"[]? | split("/")[-1]' <<<"$list_json")
      for id in "${ids[@]}"
      do
        [[ -z "$id" ]] && continue
        if ! js="$(mmcli --modem "$mid" --sms "$id" -J)"
        then
          continue
        fi
        sms_list_print_entry "$mid" "$id" "$js" 1 "$maxlen"
        had_any=1
      done
    done
    [[ -n "$had_any" ]] || echo_info "no SMS messages"
    return 0
  fi

  if ! list_json="$(mmcli_cmd --messaging-list-sms -J)"
  then
    error "failed to list SMS messages"
    return 1
  fi

  mapfile -t ids < <(jq -r '."modem.messaging.sms"[]? | split("/")[-1]' <<<"$list_json")
  if (( ${#ids[@]} == 0 ))
  then
    if [[ -n "$JSON_OUTPUT$RAW_OUTPUT" ]]
    then
      printf '[]\n'
    else
      echo_info "no SMS messages"
    fi
    return 0
  fi

  if [[ -n "$RAW_OUTPUT" ]]
  then
    if [[ -n "$ALL_MODEMS" && -z "$target_mid" ]]
    then
      local mids mid raw_items=()
      if mapfile -t mids < <(list_modem_ids_sorted)
      then
        for mid in "${mids[@]}"
        do
          [[ -z "$mid" ]] && continue
          local raw
          raw="$(MODEM="$mid" ALL_MODEMS="" JSON_OUTPUT="" RAW_OUTPUT=1 modem_status_single)"
          [[ -n "$raw" ]] && raw_items+=("$raw")
        done
      fi

      if (( ${#raw_items[@]} == 0 ))
      then
        printf '[]
'
      else
        printf '%s
' "${raw_items[@]}" | jq -s '.'
      fi
      return 0
    fi

    local raw_output
    raw_output="$(JSON_OUTPUT="" RAW_OUTPUT=1 modem_status_single)"
    if [[ -n "$raw_output" ]]
    then
      printf '%s
' "$raw_output"
      return 0
    fi
  fi

  if [[ -n "$JSON_OUTPUT" ]]
  then
    # Emit one compact JSON object per SMS, then wrap into an array
    # Determine our own number for recipient mapping of received messages
    local own=""
    if load_own_number
    then
      own="$OWN_NUMBER"
    fi
    {
      for id in "${ids[@]}"
      do
        [[ -z "$id" ]] && continue
        if ! js="$(mmcli_cmd --sms "$id" -J)"
        then
          continue
        fi
        pdu="$(jq -r '.sms.properties["pdu-type"] // ""' <<<"$js")"
        msg_type="$(pdu_to_type "$pdu")"
        jq -c --arg id "$id" --arg type "$msg_type" --arg own "$own" '
          {
            id: ($id|tonumber),
            sender: (.sms.content.number // ""),
            text: (.sms.content.text // ""),
            class: (.sms.content.class // ""),
            state: (.sms.properties.state // ""),
            pdu: (.sms.properties["pdu-type"] // ""),
            storage: (.sms.properties.storage // ""),
            type: $type,
            recipient: (if $type == "received" then $own else (.sms.content.number // "") end)
          }
        ' <<<"$js"
      done
    } | jq -s '.'
    return 0
  fi

  # Header for human-readable list (make entire line bold to preserve alignment)
  local _nocolor=""
  if [[ -n "$NO_COLOR" || -n "$CRON" ]]
  then
    _nocolor=1
  fi
  sms_list_print_header 0 "$_nocolor"

  for id in "${ids[@]}"
  do
    [[ -z "$id" ]] && continue
    if ! js="$(mmcli_cmd --sms "$id" -J)"
    then
      continue
    fi
    sms_list_print_entry "" "$id" "$js" 0 "$maxlen"
  done
}

enable_modem() {
  local expect_id="${1:-}"
  local max_wait=600
  local sleep_period=2
  local elapsed=0

  echo_info "waiting for D-Bus system socket"
  until [[ -S /var/run/dbus/system_bus_socket ]]
  do
    if (( elapsed >= max_wait ))
    then
      echo_warning "timeout waiting for D-Bus socket"
      return 1
    fi

    sleep "$sleep_period"
    elapsed=$((elapsed + sleep_period))
  done

  echo_info "waiting for ModemManager"
  elapsed=0
  until mmcli -L
  do
    if (( elapsed >= max_wait ))
    then
      echo_warning "timeout waiting for ModemManager"
      return 1
    fi

    sleep "$sleep_period"
    elapsed=$((elapsed + sleep_period))
  done

  echo_info "waiting for modem detection"
  elapsed=0
  local list_json
  local modem_count=0
  while :
  do
    list_json=""
    modem_count=0
    if list_json="$(mmcli -L -J)"
    then
      if [[ -n "$expect_id" && "$expect_id" =~ ^[0-9]+$ ]]
      then
        local present
        present="$(jq -r --arg id "$expect_id" '
          (."modem-list" // [])
          | map(split("/")[-1])
          | any(. == $id)
        ' <<<"$list_json" || printf 'false')"
        if [[ "$present" == "true" ]]
        then
          # Capture brief modem details for logging once detection succeeds
          local _brief
          _brief="$(modem_info_brief "$expect_id" 2>/dev/null)"
          break
        fi
      else
        modem_count="$(jq -r '((."modem-list" // []) | length) // 0' <<<"$list_json" || printf '0')"
        if [[ "$modem_count" =~ ^[0-9]+$ ]] && (( modem_count > 0 ))
        then
          break
        fi
      fi
    fi

    if (( elapsed >= max_wait ))
    then
      echo_warning "timeout waiting for modem detection"
      return 1
    fi

    sleep "$sleep_period"
    elapsed=$((elapsed + sleep_period))
  done

  if [[ -n "$expect_id" && "$expect_id" =~ ^[0-9]+$ ]]
  then
    if [[ -n "$list_json" ]]
    then
      local _detected_info
      _detected_info="$(jq -r --arg id "$expect_id" '
        (."modem-list" // [])
        | map(select(split("/")[-1] == $id))
        | first
        | select(. != null)
        | {
            id: (split("/")[-1]),
            manufacturer: "--",
            model: "--",
            plugin: "--",
            primary: "--",
            ports: "--"
          }
        | ("detected expected modem: id=" + .id
             + " manufacturer=" + .manufacturer
             + " model=" + .model
             + " plugin=" + .plugin
             + " primary=" + .primary
             + " ports=" + .ports)
      ' <<<"$list_json")"
      if [[ -z "$_detected_info" || "$_detected_info" == "null" ]]
      then
        _detected_info="detected expected modem id=$expect_id"
      fi
      echo_info "$_detected_info"
    else
      echo_info "detected expected modem id=$expect_id"
    fi
  else
    echo_info "detected $modem_count modem(s)"
  fi

  # Use the expected modem id if provided; otherwise rely on MODEM
  # shellcheck disable=SC2031
  local enable_target="$MODEM"

  if [[ -n "$expect_id" ]]
  then
    enable_target="$expect_id"
  fi

  local MODEM="$enable_target"

  if mmcli_cmd --enable
  then
    echo_info "modem enabled"
    # Log enabled modem details similar to selection log
    if [[ -z $QUIET ]]
    then
      local _ej _eln
      _ej="$(mmcli -m "$enable_target" -J)"
      if [[ -n "$_ej" ]]
      then
        _eln="$(jq -r '
          .modem as $m
          | {
              id: ($m["dbus-path"] | split("/")[-1]),
              manufacturer: ($m.generic.manufacturer // "--"),
              model: ($m.generic.model // "--"),
              plugin: ($m.generic.plugin // "--"),
              primary: ($m.generic["primary-port"] // "--"),
              ports: (($m.generic.ports // []) | map(split(" ")[0]) | join(",")),
              phone: (($m.generic["own-numbers"][0] // "")
                      | if . == "" then "--"
                        else (if startswith("+") then . else "+" + . end) end),
              cc: ((($m.generic["own-numbers"][0] // "") ) as $p
                   | if $p|startswith("+1") then "1"
                     elif $p|startswith("+") then ($p[1:3])
                     else "--" end)
            }
          | ("enabled modem: id=" + .id
             + " manufacturer=" + .manufacturer
             + " model=" + .model
             + " plugin=" + .plugin
             + " primary=" + .primary
             + " ports=" + .ports
             + " phone=" + .phone
             + " cc=" + (if .phone|startswith("+1") then "US"
                         elif .phone|startswith("+33") then "FR"
                         elif .phone|startswith("+49") then "DE"
                         else "--" end))
        ' <<<"$_ej")"
        if [[ -n "$_eln" ]]
        then
          echo_info "$_eln"
        fi
        configure_modem_vendor "$_ej"
      fi
    fi
    return 0
  fi

  echo_warning "failed to enable modem"
  return 1
}

enable_all_modems() {
  local mids mid
  if ! mapfile -t mids < <(list_modem_ids_sorted)
  then
    error "failed to list modems to enable"
    return 1
  fi
  if (( ${#mids[@]} == 0 ))
  then
    echo_info "no modems detected"
    return 0
  fi
  local ok_count=0
  local fail_ids=()
  for mid in "${mids[@]}"
  do
    [[ -z "$mid" ]] && continue
    echo_info "enabling modem $mid"
    if ! enable_modem "$mid"
    then
      echo_warning "failed to enable modem $mid"
      fail_ids+=("$mid")
    else
      ok_count=$((ok_count + 1))
    fi
  done
  if (( ${#fail_ids[@]} > 0 ))
  then
    echo_info "enabled $ok_count/${#mids[@]} modems (failed: ${fail_ids[*]})"
  else
    echo_info "enabled $ok_count/${#mids[@]} modems"
  fi
}

modem_reset() {
  local service="/etc/init.d/modemmanager"
  local has_service=""
  local do_service=""

  if [[ -x "$service" ]]
  then
    has_service=1
  else
    reset_warn "modemmanager init script not found or not executable at $service"
  fi

  # Detect modem plugin/manufacturer to decide if Quectel-specific reset applies
  local j plugin manufacturer is_quectel=""
  if j="$(mmcli_cmd -J)"
  then
    plugin="$(jq -r '.modem.generic.plugin // empty' <<<"$j")"
    manufacturer="$(jq -r '.modem.generic.manufacturer // empty' <<<"$j")"
    if [[ "${plugin,,}" == quectel || "${manufacturer,,}" == quectel* ]]
    then
      is_quectel=1
    fi
  else
    reset_warn "could not query modem to determine vendor; proceeding without Quectel reset"
  fi

  if [[ -n "$is_quectel" ]]
  then
    if ! command -v quectel >/dev/null 2>&1
    then
      error "quectel command not found in PATH"
      return 1
    fi

    if [[ -n "$HARD_RESET" ]] && [[ -n "$has_service" ]]
    then
      reset_log "stopping ModemManager"
      if ! "$service" stop
      then
        error "failed to stop ModemManager service"
        return 1
      fi
      do_service=1
    fi

    reset_log "issuing quectel reset"
    if ! quectel reset
    then
      error "quectel reset failed"
      if [[ -n "$do_service" ]]
      then
        reset_warn "attempting to restart ModemManager after reset failure"
        "$service" start || reset_warn "could not restart ModemManager"
      fi
      return 1
    fi

    if [[ -n "$do_service" ]]
    then
      reset_log "starting ModemManager"
      if ! "$service" start
      then
        error "failed to start ModemManager service"
        return 1
      fi
    fi
  else
    # Non-Quectel: avoid vendor reset; optionally restart ModemManager to nudge detection
    if [[ -n "$HARD_RESET" ]] && [[ -n "$has_service" ]]
    then
      reset_log "restarting ModemManager (non-Quectel)"
      if ! "$service" restart
      then
        reset_warn "failed to restart ModemManager service"
      fi
    fi
  fi

  reset_log "enabling modem"
  if ! enable_modem "$MODEM"
  then
    reset_warn "failed to enable modem after reset, retrying in 5s"
    sleep 5
    if ! enable_modem "$MODEM"
    then
      error "failed to enable modem after reset"
      return 1
    fi
  fi

  return 0
}

modem_reset_all() {
  local mids mid
  if ! mapfile -t mids < <(list_modem_ids_sorted)
  then
    error "failed to list modems to reset"
    return 1
  fi
  if (( ${#mids[@]} == 0 ))
  then
    echo_info "no modems detected"
    return 0
  fi
  for mid in "${mids[@]}"
  do
    [[ -z "$mid" ]] && continue
    echo_info "resetting modem $mid"
    (
      # shellcheck disable=SC2030
      local MODEM="$mid"
      modem_reset || error "failed to reset modem $mid"
    )
  done
}

reset_log() {
  if [[ -z $QUIET ]]
  then
    echo_info "$*"
  fi
}

reset_warn() {
  echo_warning "$*"
}

watch_cleanup() {
  if [[ -n "$WATCH_DBUS_PID" ]]
  then
    if ! kill "$WATCH_DBUS_PID"
    then
      echo_warning "could not stop dbus-monitor (pid $WATCH_DBUS_PID)"
    fi
    WATCH_DBUS_PID=""
  fi
  if [[ -n "$WATCH_FIFO" ]]
  then
    if ! rm -f "$WATCH_FIFO"
    then
      echo_warning "could not remove fifo $WATCH_FIFO"
    fi
    WATCH_FIFO=""
  fi
}

watch_canon_number() {
  local n="${1:-}"
  n="${n//[^0-9]/}"
  printf '%s' "$n"
}

watch_in_whitelist() {
  local original="${1:-}"

  local num
  num="$(watch_canon_number "$original")"
  if [[ -z "$num" ]]
  then
    echo_warning "watch: sender '${original}' not whitelisted (empty canonical number); whitelist='${SMS_WHITELIST[*]}'"
    return 1
  fi

  local allowed canon_allowed
  for allowed in "${SMS_WHITELIST[@]}"
  do
    canon_allowed="$(watch_canon_number "$allowed")"
    if [[ -n "$canon_allowed" && "$num" == "$canon_allowed" ]]
    then
echo_info "watch: sender '${original}' matched whitelist entry '${allowed}' (whitelist='${SMS_WHITELIST[*]}')"
      return 0
    fi
  done

  echo_warning "watch: sender '${original}' not in whitelist; whitelist='${SMS_WHITELIST[*]}'"
  return 1
}

watch_send_reply() {
  local to="$1"
  local msg="$2"
  # Log outgoing SMS (abbreviate text and escape newlines)
  local log_text
  log_text="$(abbrev_text_for_log "$msg")"
  local log_modem
  log_modem="$(modem_info_brief)"

  echo_info "sending reply with modem={$log_modem} recipient=$to text='$log_text'"
  if [[ -n "$FALLBACK" ]]
  then
    if ! sms_send_with_fallback "$to" "$msg"
    then
      echo_warning "failed to send reply to $to (including fallback)"
      return 1
    fi
    return 0
  fi

  if ! sms_send "$to" "$msg"
  then
    echo_warning "failed to send reply to $to"
    return 1
  fi
}

watch_run_command() {
  local cmd="$1"
  local output rc reason="exit"
  rc=0

  if command -v timeout >/dev/null 2>&1
  then
    if ! output="$(timeout -k "${WATCH_CMD_KILL_TIMEOUT}s" "${WATCH_CMD_TIMEOUT}s" bash -c "$cmd" 2>&1)"
    then
      rc=$?
    fi
    if (( rc == 124 ))
    then
      reason="timeout"
    elif (( rc >= 128 ))
    then
      reason="killed"
    fi
  else
    if ! output="$(bash -c "$cmd" 2>&1)"
    then
      rc=$?
    fi
  fi

  WATCH_CMD_RC=$rc
  WATCH_CMD_REASON=$reason

  output="${output%$'\n'}"
  if (( ${#output} > CMD_OUTPUT_MAX_LEN ))
  then
    output="${output:0:CMD_OUTPUT_MAX_LEN}\n…(truncated)…"
  fi

  printf '%s' "$output"
}

load_own_number() {
  if [[ -n "$OWN_NUMBER" ]]
  then
    return 0
  fi

  local json number
  if ! json="$(mmcli_cmd -J)"
  then
    return 1
  fi

  number="$(jq -r '(.modem.generic["own-numbers"][0] // empty)' <<<"$json")"

  if [[ -z "$number" ]]
  then
    return 1
  fi

  if [[ "$number" != +* ]]
  then
    number="+$number"
  fi

  OWN_NUMBER="$number"
  return 0
}

get_smsc_number() {
  if [[ -n "$SMSC_NUMBER" ]]
  then
    printf '%s' "$SMSC_NUMBER"
    return 0
  fi

  # Try to retrieve the network-configured SMSC via AT+CSCA?
  # If unavailable or unsupported, return empty (do not force SMSC).
  local resp smsc
  resp="$(at_command 'AT+CSCA?')"
  if [[ -n "$resp" ]]
  then
    smsc="$(at_first_quoted_decoded "$resp")"
    if [[ -n "$smsc" ]]
    then
      smsc="$(ensure_plus "$smsc")"
      SMSC_NUMBER="$smsc"
      printf '%s' "$SMSC_NUMBER"
      return 0
    fi
  fi

  # No SMSC detected; leave empty so callers skip forcing one
  SMSC_NUMBER=""
  printf '%s' "$SMSC_NUMBER"
}

modem_status_single() {
  local json state power reg signal carrier own smsc mid_label

  if ! json="$(mmcli_cmd -J)"
  then
    if [[ -z $QUIET ]]
    then
      error "failed to query modem status"
    fi
    return 1
  fi

  mid_label="$(jq -r '.modem["dbus-path"] | split("/")[-1] // ""' <<<"$json")"

  if [[ -n "$RAW_OUTPUT" ]]
  then
    if [[ -n "$ALL_MODEMS" ]]
    then
      local mids mid raw_items=()
      if mapfile -t mids < <(list_modem_ids_sorted)
      then
        for mid in "${mids[@]}"
        do
          [[ -z "$mid" ]] && continue
          local MODEM="$mid"
          local raw
          if raw="$(mmcli_cmd -J)"
          then
            raw_items+=("$raw")
          fi
        done
      fi
      if (( ${#raw_items[@]} == 0 ))
      then
        printf '[\n]'
      else
        printf '%s
' "${raw_items[@]}" | jq -s '.'
      fi
    else
      printf '%s
' "$json" | jq
    fi
    return 0
  fi

  state="$(jq -r '(.modem.generic.state // empty)' <<<"$json")"
  power="$(jq -r '(.modem.generic["power-state"] // empty)' <<<"$json")"
  reg="$(jq -r '(.modem["3gpp"]["registration-state"] // empty)' <<<"$json")"
  signal="$(jq -r '(.modem.generic["signal-quality"].value // empty)' <<<"$json")"
  carrier="$(jq -r '(.modem["3gpp"]["operator-name"] // .modem["3gpp"]["operator-code"] // .modem.cdma.sid // empty)' <<<"$json")"
  own="$(jq -r '(.modem.generic["own-numbers"][0] // empty)' <<<"$json")"

  if [[ -z "$state" ]]
  then
    state=unknown
  fi
  if [[ -z "$power" ]]
  then
    power=unknown
  fi
  if [[ -z "$reg" ]]
  then
    reg=unknown
  fi
  if [[ -n "$signal" ]]
  then
    signal="${signal}%"
  else
    signal=unknown
  fi
  if [[ -z "$carrier" ]]
  then
    carrier=unknown
  fi
  own="$(ensure_plus "$own")"
  if [[ -z "$own" ]]
  then
    own=unknown
  else
    OWN_NUMBER="$own"
  fi

  # Derive SMSC (may use OWN_NUMBER or config); do not fail hard if empty
  smsc="$(get_smsc_number)"
  if [[ -z "$smsc" ]]
  then
    smsc=unknown
  fi

  # JSON output if requested
  if [[ -n "$JSON_OUTPUT" ]]
  then
    local sig_num_json
    sig_num_json="$(jq -r '(.modem.generic["signal-quality"].value // empty)' <<<"$json")"
    jq -n \
      --arg mid "$mid_label" \
      --arg state "$state" \
      --arg power "$power" \
      --arg registered "$reg" \
      --arg carrier "$carrier" \
      --arg phone "$own" \
      --arg smsc "$smsc" \
      --arg sig "$sig_num_json" \
      '{modem_id: ($mid|tonumber?), state:$state, power:$power, registered:$registered, carrier:$carrier, phone:$phone, smsc:$smsc, signal: ($sig|tonumber?)}'
    return 0
  fi

  if [[ -z $QUIET ]]
  then
    # Color helpers (respect NO_COLOR and CRON)
    local _nocolor=""
    if [[ -n "$NO_COLOR" || -n "$CRON" ]]
    then
      _nocolor=1
    fi

    colorize() { # $1=colorcode, $2=text
      if [[ -n "$_nocolor" ]]
      then
        printf '%s' "$2"
      else
        printf '\e[%sm%s\e[0m' "$1" "$2"
      fi
    }

    # Choose colors
    local state_color power_color reg_color sig_color carrier_color phone_color smsc_color
    case "${state,,}" in
      connected|registered|enabled|online|on) state_color='1;32';;   # bold green
      searching|initializing|connecting|locked|unknown) state_color='1;33';; # bold yellow
      failed|disabled|off) state_color='1;31';;                      # bold red
      *) state_color='36';;                                          # cyan
    esac

    case "${power,,}" in
      on|full) power_color='1;32';;
      low) power_color='1;33';;
      off|unknown) power_color='1;31';;
      *) power_color='36';;
    esac

    case "${reg,,}" in
      home|roaming|registered|attached) reg_color='1;32';;
      searching|idle|unknown) reg_color='1;33';;
      denied|unregistered) reg_color='1;31';;
      *) reg_color='36';;
    esac

    # Determine signal color based on numeric value when available
    local sig_num
    sig_num="$(jq -r '(.modem.generic["signal-quality"].value // empty)' <<<"$json")"
    if [[ "$sig_num" =~ ^[0-9]+$ ]]
    then
      if (( sig_num >= 70 ))
      then
        sig_color='1;32'
      elif (( sig_num >= 40 ))
      then
        sig_color='1;33'
      else
        sig_color='1;31'
      fi
    else
      sig_color='36'
    fi

    carrier_color='1;34' # bold blue
    phone_color='1;34'
    smsc_color='1;34'

    printf 'modem state: %s\n' "$(colorize "$state_color" "$state")"
    printf 'power: %s\n' "$(colorize "$power_color" "$power")"
    printf 'registered: %s\n' "$(colorize "$reg_color" "$reg")"
    printf 'signal: %s\n' "$(colorize "$sig_color" "$signal")"
    printf 'carrier: %s\n' "$(colorize "$carrier_color" "$carrier")"
    printf 'phone: %s\n' "$(colorize "$phone_color" "$own")"
    printf 'smsc: %s\n' "$(colorize "$smsc_color" "$smsc")"
  fi

  return 0
}

modem_status() {
  local target_mid="${1:-}"

  if [[ -z "$target_mid" && -n "$ALL_MODEMS" ]]
  then
    local mids mid
    if ! mapfile -t mids < <(list_modem_ids_sorted)
    then
      error "failed to list modems"
      return 1
    fi
    if (( ${#mids[@]} == 0 ))
    then
      if [[ -n "$JSON_OUTPUT$RAW_OUTPUT" ]]
      then
        printf '[]\n'
      else
        echo_info "no modems detected"
      fi
      return 0
    fi

    if [[ -n "$JSON_OUTPUT$RAW_OUTPUT" ]]
    then
      local json_items=() item
      for mid in "${mids[@]}"
      do
        [[ -z "$mid" ]] && continue
        item="$(MODEM="$mid" ALL_MODEMS="" modem_status_single)"
        [[ -n "$item" ]] && json_items+=("$item")
      done
      if (( ${#json_items[@]} == 0 ))
      then
        printf '[]\n'
      else
        printf '%s\n' "${json_items[@]}" | jq -s '.'
      fi
      return 0
    fi

    local first=1
    for mid in "${mids[@]}"
    do
      [[ -z "$mid" ]] && continue
      (( first )) || printf '\n'
      first=0
      echo_info "modem $mid:"
      MODEM="$mid" ALL_MODEMS="" modem_status_single
    done
    return 0
  fi

  modem_status_single
}

modem_number() {
  if ! load_own_number
  then
    local load_rc=$?
    if (( load_rc == 1 ))
    then
      error "could not query modem for own number"
    else
      error "modem did not report own number"
    fi
    return 1
  fi

  if [[ -z "$OWN_NUMBER" ]]
  then
    error "modem did not report own number"
    return 2
  fi

  printf '%s\n' "$OWN_NUMBER"
  return 0
}

watch_handle_sms() {
  local id="$1"
  local prefer_modem_id="${2:-}"
  # Ensure replies and operations use the modem that received the message
  # by shadowing MODEM locally for mmcli_cmd invocations.
  # shellcheck disable=SC2031
  local MODEM="$MODEM"
  if [[ -n "$prefer_modem_id" ]]
  then
    MODEM="$prefer_modem_id"
  else
    echo_warning "no modem hint for SMS $id; defaulting to any"
    MODEM="any"
  fi
  local tries=0
  local js state pdu sender text payload

  while :
  do
    if ! js="$(mmcli_cmd --sms "$id" -J)"
    then
      return
    fi

    state="$(jq -r '.sms.properties.state // empty' <<<"$js")"
    pdu="$(jq -r '.sms.properties."pdu-type" // empty' <<<"$js")"
    sender="$(jq -r '.sms.content.number // empty' <<<"$js")"
    text="$(jq -r '.sms.content.text // empty' <<<"$js")"

    if [[ "$state" != "received" && "$pdu" != "deliver" ]]
    then
      echo_info "ignore id=$id (state=$state pdu=$pdu)"
      return
    fi

    if [[ -n "$OWN_NUMBER" && "$sender" == "$OWN_NUMBER" ]]
    then
      echo_info "skip self-sent id=$id"
      return
    fi

    if [[ -z "$text" && $tries -lt $SMS_RETRY_COUNT ]]
    then
      tries=$((tries + 1))
      sleep "$WATCH_RETRY_SLEEP"
      continue
    fi

    # Determine recipient (SIM MSISDN) for the modem that received the SMS
    # Prefer querying the current modem directly to avoid cross-modem mixups.
    local recipient=""
    local om_json
    if om_json="$(mmcli_cmd -J)"
    then
      recipient="$(jq -r '.modem.generic["own-numbers"][0] // empty' <<<"$om_json")"
      recipient="$(ensure_plus "$recipient")"
    fi

    local log_text
    log_text="$(abbrev_text_for_log "$text")"
    local log_recipient="$recipient"
    if [[ -z "$log_recipient" ]]
    then
      log_recipient="--"
    fi
    local sender_cc
    sender_cc="$(phone_cc_label "$sender")"
    echo_info "received message={id='$id' sender='$sender' (cc='$sender_cc') recipient='$log_recipient' text='$log_text'}"

    local sender_whitelisted=0
    if watch_in_whitelist "$sender"
    then
      sender_whitelisted=1
    fi

    local handled=0
    if [[ "$text" == "!"* ]]
    then
      if (( sender_whitelisted ))
      then
        local cmd="${text#!}"
        while [[ "$cmd" == " "* ]]
        do
          cmd="${cmd# }"
        done
        if [[ -z "$cmd" ]]
        then
          watch_send_reply "$sender" "ERR: empty command"
        else
          echo_info "executing command from $sender: $cmd"
          local output
          output="$(watch_run_command "$cmd")"
          echo_info "command from $sender finished rc=$WATCH_CMD_RC reason=${WATCH_CMD_REASON:-exit}"
          # Before sending our reply, prune already-sent messages on this modem
          sms_prune_sent || echo_warning "failed to prune sent SMS before reply"
          watch_send_reply "$sender" "rc=$WATCH_CMD_RC (${WATCH_CMD_REASON:-exit})\n$output"
        fi
        handled=1
      else
        echo_info "command from $sender ignored (not whitelisted)"
      fi
    fi

    if (( handled == 0 ))
    then
      payload="$(jq -n \
        --arg recipient "$recipient" \
        --arg sender "$sender" \
        --arg text "$text" \
        --arg date "$(date -Iseconds)" \
        '{recipient:$recipient, sender:$sender, text:$text, date: $date}')"
      echo_info "forwarding id=$id from $sender to webhook"
      local resp rc code body log_body
      resp="$(curl -sS -m 10 -H 'Content-Type: application/json' -w $'\n%{http_code}' \
        -X POST -d "$payload" "$WEBHOOK_URL" 2>&1)"
      rc=$?
      if (( rc != 0 ))
      then
        log_body="$(abbrev_text_for_log "$resp")"
        echo_warning "webhook delivery error rc=$rc output='$log_body'"
      else
        code="${resp##*$'\n'}"
        body="${resp%$'\n'*}"
        if [[ "$code" =~ ^[0-9]{3}$ ]]
        then
          log_body="$(abbrev_text_for_log "$body")"
        else
          code="n/a"
          log_body="$(abbrev_text_for_log "$resp")"
        fi
        if [[ "$code" =~ ^2 ]]
        then
          echo_info "webhook response code=$code body='$log_body'"
        else
          echo_warning "webhook response code=$code body='$log_body'"
        fi
      fi
    fi

    if (( WATCH_DELETE_AFTER == 1 ))
    then
      if ! mmcli_cmd --messaging-delete-sms="$id" >/dev/null 2>&1
      then
        echo_warning "failed to delete processed SMS $id"
      fi
    fi
    return
  done
}

watch_messages() {
  export PATH="/usr/local/bin:/srv/bin:$PATH"
  trap watch_cleanup EXIT INT TERM

  WATCH_FIFO="${TMPDIR:-/tmp}/smsbus.$$"
  mkfifo "$WATCH_FIFO"

  local filter="type='signal',interface='org.freedesktop.ModemManager1.Modem.Messaging',member='Added'"
  dbus-monitor --system "$filter" >"$WATCH_FIFO" &
  WATCH_DBUS_PID=$!

  if load_own_number
  then
    if [[ -n "$OWN_NUMBER" ]]
    then
      echo_info "own number = $OWN_NUMBER"
    fi
  else
    local load_rc=$?
    if (( load_rc == 1 ))
    then
      echo_warning "could not query modem for own number"
    else
      echo_warning "modem did not report own number"
    fi
  fi

  if ! sms_prune_all_modems
  then
    echo_warning "failed to prune existing SMS messages on all modems"
  fi

  if [[ -n "$ALL_MODEMS" ]]
  then
    enable_all_modems || echo_warning "failed to enable all modems"
  else
    enable_modem "$MODEM" || echo_warning "failed to enable modem"
  fi

  local current_modem_id=""
  while IFS= read -r line
  do
    # Track the modem id from the signal's path
    if [[ "$line" =~ /org/freedesktop/ModemManager1/Modem/([0-9]+) ]]
    then
      current_modem_id="${BASH_REMATCH[1]}"
    elif [[ "$line" =~ "/org/freedesktop/ModemManager1/Modem/"([0-9]+) ]]
    then
      current_modem_id="${BASH_REMATCH[1]}"
    fi
    if [[ "$line" == *"/org/freedesktop/ModemManager1/SMS/"* ]]
    then
      local local_path="${line#*\"}"
      local_path="${local_path%%\"*}"
      local id="${local_path##*/}"
      if [[ "$id" =~ ^[0-9]+$ ]]
      then
        # If not listening on all, ignore messages from other modems
        if [[ -z "$ALL_MODEMS" && -n "$current_modem_id" && "$current_modem_id" != "$MODEM" ]]
        then
          echo_warning "ignoring SMS $id from modem $current_modem_id (listening on $MODEM)"
          continue
        fi
        watch_handle_sms "$id" "$current_modem_id"
      fi
    fi
  done <"$WATCH_FIFO"
}

main() {
  local command
  local -a ARGS=()
  local -a DEBUG_FLAGS=()

  # Global options can appear anywhere; collect non-option args into ARGS
  while (( $# > 0 ))
  do
    local opt="$1"
    case "$1" in
      -m|--modem)
        if (( $# < 2 ))
        then
          error "missing value for $1"
          return 2
        fi
        DEBUG_FLAGS+=("${opt}=$2")
        MODEM="$2"
        MODEM_EXPLICIT=1
        shift 2
        ;;
      -d|--debug)
        DEBUG_FLAGS+=("${opt}")
        # shellcheck disable=SC2034
        DEBUG=1
        shift
        ;;
      -j|--json)
        DEBUG_FLAGS+=("${opt}")
        JSON_OUTPUT=1
        shift
        ;;
      -r|--raw)
        DEBUG_FLAGS+=("${opt}")
        RAW_OUTPUT=1
        shift
        ;;
      -H|--hard)
        DEBUG_FLAGS+=("${opt}")
        HARD_RESET=1
        shift
        ;;
      -a|--all)
        DEBUG_FLAGS+=("${opt}")
        ALL_MODEMS=1
        shift
        ;;
      -A|--auto|--auto-recipient)
        DEBUG_FLAGS+=("${opt}")
        AUTO_RECIPIENT=1
        shift
        ;;
      -R|--retry)
        if (( $# < 2 ))
        then
          error "missing value for $1"
          return 2
        fi
        if [[ ! "$2" =~ ^[0-9]+$ ]]
        then
          error "--retry requires a non-negative integer"
          return 2
        fi
        DEBUG_FLAGS+=("${opt}=$2")
        SMS_RETRY_COUNT="$2"
        shift 2
        ;;
      -S|--sent)
        DEBUG_FLAGS+=("${opt}")
        SENT_ONLY=1
        shift
        ;;
      -f|--allow-foreign)
        DEBUG_FLAGS+=("${opt}")
        ALLOW_FOREIGN=1
        shift
        ;;
      -q|--quiet|--silent)
        DEBUG_FLAGS+=("${opt}")
        QUIET=1
        shift
        ;;
      -x|--trace)
        DEBUG_FLAGS+=("${opt}")
        PS4='+ [${BASH_SOURCE##*/}:${LINENO}] ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
        set -x
        shift
        ;;
      -c|--config)
        if (( $# < 2 ))
        then
          error "missing value for $1"
          return 2
        fi
        DEBUG_FLAGS+=("${opt}=$2")
        CONFIG_FILE="$2"
        CONFIG_LOADED=""
        shift 2
        ;;
      -F|--fallback)
        DEBUG_FLAGS+=("${opt}")
        FALLBACK=1
        shift
        ;;
      -s|--syslog)
        DEBUG_FLAGS+=("${opt}")
        # shellcheck disable=SC2034
        ECHO_SYSLOG=1
        shift
        ;;
      -h|--help)
        DEBUG_FLAGS+=("${opt}")
        # If a subcommand is already captured in ARGS, defer help to subcommand usage
        if (( ${#ARGS[@]} > 0 )) && [[ "${ARGS[0]}" != -* ]]
        then
          ARGS+=("$1")
          shift
        else
          usage
          return 0
        fi
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          ARGS+=("$1")
          shift
        done
        break
        ;;
      *)
        ARGS+=("$1")
        shift
        ;;
    esac
  done

  if (( ${#ARGS[@]} == 0 ))
  then
    command="status"
  else
    command="${ARGS[0]}"
    ARGS=("${ARGS[@]:1}")
  fi

  if ! load_config post-args
  then
    return $?  # load_config already logged details
  fi
  if [[ -n "$DEFAULT_MODEM" ]]
  then
    echo_debug "default modem configured: $DEFAULT_MODEM"
  fi

  if [[ -z "$ALL_MODEMS" && -z "$MODEM_EXPLICIT" && -n "$DEFAULT_MODEM" ]]
  then
    MODEM="$DEFAULT_MODEM"
    echo_debug "using default modem $MODEM"
  fi

  # Support a 'help' command and per-subcommand --help/-h after command
  if [[ "$command" == "help" ]]
  then
    local topic="${ARGS[0]:-}"
    if [[ -z "$topic" ]]
    then
      usage
    else
      case "$topic" in
        s|send) topic="send" ;;
        l|ls|list) topic="list" ;;
        r|get|read) topic="read" ;;
        en|enable|start) topic="enable" ;;
        st|stat|status) topic="status" ;;
        rst|reset|restart) topic="reset" ;;
        w|watch) topic="watch" ;;
        number|phone) topic="number" ;;
        smsc) topic="smsc" ;;
      esac
      print_subcommand_usage "$topic"
    fi
    return 0
  fi

  case "$command" in
    send|s)
      command="send"
      ;;
    list|ls|l|-l)
      command="list"
      ;;
    read|get|r)
      command="read"
      ;;
    prune|clear|delete)
      command="prune"
      ;;
    -e|*enable*|en|start)
      command="enable"
      ;;
    status|stat|st)
      command="status"
      ;;
    number|phone)
      command="number"
      ;;
    reset|rst|restart)
      command="reset"
      ;;
    watch|w)
      command="watch"
      ;;
    smsc)
      command="smsc"
      ;;
  esac

  # Per-subcommand --help/-h anywhere in ARGS
  for _arg in "${ARGS[@]}"
  do
    if [[ "$_arg" == "--help" || "$_arg" == "-h" ]]
    then
      print_subcommand_usage "$command"
      return 0
    fi
  done
  # Per-subcommand --help/-h before any modem resolution/logging
  if [[ "$command" != "help" ]]
  then
    for _arg in "${ARGS[@]}"
    do
      if [[ "$_arg" == "--help" || "$_arg" == "-h" ]]
      then
        print_subcommand_usage "$command"
        return 0
      fi
    done
  fi

  # Normalize and pull global flags that appear after the subcommand,
  # while preserving positional args for the subcommand.
  if (( ${#ARGS[@]} > 0 ))
  then
    local -a CMD_ARGS=()
    local i=0
    while (( i < ${#ARGS[@]} ))
    do
      case "${ARGS[i]}" in
        -f|--allow-foreign)
          DEBUG_FLAGS+=("${ARGS[i]}")
          ALLOW_FOREIGN=1
          i=$((i+1))
          continue
          ;;
        -F|--fallback)
          DEBUG_FLAGS+=("${ARGS[i]}")
          FALLBACK=1
          i=$((i+1))
          continue
          ;;
        -A|--auto|--auto-recipient)
          DEBUG_FLAGS+=("${ARGS[i]}")
          AUTO_RECIPIENT=1
          i=$((i+1))
          continue
          ;;
        -R|--retry)
          if (( i + 1 >= ${#ARGS[@]} ))
          then
            error "missing value for ${ARGS[i]}"
            return 2
          fi
          local _retry=${ARGS[i+1]}
          if [[ ! "$_retry" =~ ^[0-9]+$ ]]
          then
            error "--retry requires a non-negative integer"
            return 2
          fi
          DEBUG_FLAGS+=("${ARGS[i]}=${_retry}")
          SMS_RETRY_COUNT="$_retry"
          i=$((i+2))
          continue
          ;;
        -a|--all)
          DEBUG_FLAGS+=("${ARGS[i]}")
          ALL_MODEMS=1
          i=$((i+1))
          continue
          ;;
        -S|--sent)
          DEBUG_FLAGS+=("${ARGS[i]}")
          SENT_ONLY=1
          i=$((i+1))
          continue
          ;;
        -c|--config)
          if (( i + 1 < ${#ARGS[@]} ))
          then
            DEBUG_FLAGS+=("${ARGS[i]}=${ARGS[i+1]}")
            CONFIG_FILE="${ARGS[i+1]}"
            i=$((i+2))
            continue
          fi
          ;;
        -s|--syslog)
          DEBUG_FLAGS+=("${ARGS[i]}")
          # shellcheck disable=SC2034
          ECHO_SYSLOG=1
          i=$((i+1))
          continue
          ;;
        --)
          DEBUG_FLAGS+=("${ARGS[i]}")
          # Copy the rest verbatim
          while (( i < ${#ARGS[@]} ))
          do
            CMD_ARGS+=("${ARGS[i]}")
            i=$((i+1))
          done
          break
          ;;
      esac
      CMD_ARGS+=("${ARGS[i]}")
      i=$((i+1))
    done
    ARGS=("${CMD_ARGS[@]}")
  fi

  if [[ "$command" == -* ]]
  then
    error "unknown option: $command"
    usage >&2
    return 2
  fi

  # Resolve human-friendly modem selector to a concrete id, once
  if ! MODEM="$(get_modem_id "$MODEM")"
  then
    # get_modem_id already printed context and list
    return 2
  fi

  # Pin 'any' to the actual modem id to avoid races in subsequent calls
  if [[ "$MODEM" == "any" ]]
  then
    local _j _id
    if _j="$(mmcli_cmd -J)"
    then
      _id="$(jq -r '.modem["dbus-path"] | split("/")[-1] // empty' <<<"$_j")"
      if [[ -n "$_id" ]]
      then
        MODEM="$_id"
      fi
    fi
  fi

  # Informative log about modem selection
  if [[ -z $QUIET ]]
  then
    if [[ "$command" == "watch" && -n "$ALL_MODEMS" ]]
    then
      # For watch with --all, list all modems explicitly
      local _ids _id
      if mapfile -t _ids < <(list_modem_ids_sorted)
      then
        echo_info "listening on all modems: ${#_ids[@]} detected"
        for _id in "${_ids[@]}"
        do
          [[ -z "$_id" ]] && continue
          log_modem_details "$_id"
        done
        MODEM_DETAILS_LOGGED=1
      else
        echo_info "listening on all modems"
      fi
    else
      if [[ -n "$ALL_MODEMS" ]]
      then
        local _ids=()
        if mapfile -t _ids < <(list_modem_ids_sorted)
        then
          if (( ${#_ids[@]} > 0 ))
          then
            echo_info "operating on all modems: ${#_ids[@]} detected"
            for _id in "${_ids[@]}"
            do
              [[ -z "$_id" ]] && continue
              log_modem_details "$_id"
            done
            MODEM_DETAILS_LOGGED=1
          else
            echo_info "operating on all modems: none detected"
          fi
        else
          echo_info "operating on all modems"
        fi
      elif [[ -n "$MODEM" && "$MODEM" != "any" ]]
      then
        log_modem_details "$MODEM" "selected "
      else
        local _info
        _info="$(modem_info_brief)"
        if [[ -n "$_info" && "$_info" != "$MODEM" ]]
        then
          echo_info "selected modem={$_info}"
        elif [[ "$MODEM" != "any" && -n "$MODEM" ]]
        then
          echo_info "selected modem={id='$MODEM'}"
        else
          echo_info "selected modem: any"
        fi
      fi
    fi
  fi

  local dbg_args="" dbg_flags=""
  if (( ${#DEBUG_FLAGS[@]} > 0 ))
  then
    local dbg_flags_str
    printf -v dbg_flags_str '%q ' "${DEBUG_FLAGS[@]}"
    dbg_flags=" flags=${dbg_flags_str%% }"
  fi
  if (( ${#ARGS[@]} > 0 ))
  then
    local dbg_args_str
    printf -v dbg_args_str '%q ' "${ARGS[@]}"
    dbg_args=" args=${dbg_args_str%% }"
  fi
  echo_debug "command=$command${dbg_flags}${dbg_args}"

  case "$command" in
    send)
      if [[ -n "$FALLBACK" ]]
      then
        if ! sms_send_with_fallback "${ARGS[@]}"
        then
          return 1
        fi
      else
        if ! sms_send "${ARGS[@]}"
        then
          echo_warning "send failed; fallback disabled, not trying other modems"
          return 1
        fi
      fi
      ;;
    list)
      sms_list_pretty
      ;;
    read)
      if (( ${#ARGS[@]} < 1 ))
      then
        error "No SMS ID/path specified"
        # Show the message list in the same pretty/JSON/raw style
        sms_list_pretty || error "failed to list SMS messages"
        return 1
      fi
      if [[ -n "$RAW_OUTPUT" ]]
      then
        mmcli_cmd --sms "${ARGS[0]}" -J | jq
      elif [[ -n "$JSON_OUTPUT" ]]
      then
        sms_read_json "${ARGS[0]}"
      else
        sms_read "${ARGS[@]}"
      fi
      ;;
    prune)
      if [[ -n "$SENT_ONLY" && -n "$ALL_MODEMS" ]]
      then
        sms_prune_sent_modems
      elif [[ -n "$SENT_ONLY" ]]
      then
        sms_prune_sent
      elif [[ -n "$ALL_MODEMS" ]]
      then
        sms_prune_all_modems
      else
        sms_prune_all
      fi
      ;;
    enable)
      if [[ -n "$ALL_MODEMS" ]]
      then
        enable_all_modems
      else
        enable_modem "$MODEM"
      fi
      ;;
    status)
      modem_status "$@"
      ;;
    number)
      modem_number
      ;;
    smsc)
      local smsc
      smsc="$(get_smsc_number)"
      printf "%s\n" "$smsc"
      ;;
    reset)
      if [[ -n "$ALL_MODEMS" ]]
      then
        modem_reset_all
      else
        modem_reset
      fi
      ;;
    watch)
      # Config already sourced earlier; ensure whitelist is populated
      if (( ${#SMS_WHITELIST[@]} == 0 ))
      then
        error "watch requires at least one whitelisted number (SMS_WHITELIST)"
        return 2
      fi
      watch_messages
      ;;
    *)
      error "unknown command: $command"
      usage >&2
      return 2
      ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "$0" ]]
then
  main "$@"
fi
