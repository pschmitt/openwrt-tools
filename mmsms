#!/usr/bin/env bash

SCRIPT_NAME="$(basename "${BASH_SOURCE[0]}")"

cd "$(dirname "$(readlink -f "$0")")" || return 9

# shellcheck source=lib/echo.sh
source lib/echo.sh || exit 2

CONFIG_FILE="${CONFIG_FILE:-/etc/mmsms.conf}"

MODEM="${MODEM:-any}"
ALL_MODEMS="${ALL_MODEMS:-}"
DEFAULT_MODEM="${DEFAULT_MODEM:-}"

OWN_NUMBER="${OWN_NUMBER:-}"
SMSC_NUMBER="${SMSC_NUMBER:-}"

SMS_SEND_TIMEOUT="${SMS_SEND_TIMEOUT:-30}"
SMS_RETRY_COUNT="${SMS_RETRY_COUNT:-${SMS_SEND_RETRY_COUNT:-${MAX_RETRY:-3}}}"
SMS_CHUNK_SIZE="${SMS_CHUNK_SIZE:-}"
CMD_OUTPUT_MAX_LEN="${CMD_OUTPUT_MAX_LEN:-4000}"

AT_FALLBACK_MAX_READS="${AT_FALLBACK_MAX_READS:-25}"
AT_FALLBACK_READ_TIMEOUT="${AT_FALLBACK_READ_TIMEOUT:-0.2}"

AT_WAIT_TIMEOUT_DEFAULT="${AT_WAIT_TIMEOUT_DEFAULT:-60}"
AT_WAIT_SLEEP_INTERVAL="${AT_WAIT_SLEEP_INTERVAL:-2}"
AT_WAIT_MODEM="${AT_WAIT_MODEM:-}"
AT_WAIT_TIMEOUT="${AT_WAIT_TIMEOUT:-0}"

ENABLE_WAIT_TIMEOUT_DEFAULT="${ENABLE_WAIT_TIMEOUT_DEFAULT:-600}"
ENABLE_WAIT_SLEEP_INTERVAL="${ENABLE_WAIT_SLEEP_INTERVAL:-2}"
ENABLE_WAIT_MODEM="${ENABLE_WAIT_MODEM:-}"
ENABLE_WAIT_TIMEOUT="${ENABLE_WAIT_TIMEOUT:-0}"

WEBHOOK_URL="${WEBHOOK_URL:-}"

WATCH_DELETE_AFTER="${WATCH_DELETE_AFTER:-${DELETE_AFTER:-0}}"
WATCH_DELETE_AFTER_CLI_OVERRIDE=""
WATCH_RETRY_SLEEP="${RETRY_SLEEP:-1}"
WATCH_CMD_TIMEOUT="${CMD_TIMEOUT:-8}"
WATCH_CMD_KILL_TIMEOUT="${WATCH_CMD_KILL_TIMEOUT:-${CMD_KILL_TIMEOUT:-20}}"
WATCH_ENABLE="${WATCH_ENABLE:-}"
WATCH_ENABLE_POLL_INTERVAL="${WATCH_ENABLE_POLL_INTERVAL:-5}"
WATCH_PRUNE="${WATCH_PRUNE:-}"

WATCH_MAX_PENDING_PER_MODEM="${WATCH_MAX_PENDING_PER_MODEM:-10}"
WATCH_WORKER_LOCK_SLEEP="${WATCH_WORKER_LOCK_SLEEP:-1}"
declare -A WATCH_WORKER_PIDS=()
WATCH_ASYNC_DIR=""

QUIET="${QUIET:-}"
JSON_OUTPUT="${JSON_OUTPUT:-}"
RAW_OUTPUT="${RAW_OUTPUT:-}"
JSON_OUTPUT_FORCED="${JSON_OUTPUT_FORCED:-}"
RAW_OUTPUT_FORCED="${RAW_OUTPUT_FORCED:-}"
HARD_RESET="${HARD_RESET:-}"
USB_REPLUG="${USB_REPLUG:-}"
SENT_ONLY="${SENT_ONLY:-}"
ALLOW_FOREIGN="${ALLOW_FOREIGN:-}"
HOME_CC="${HOME_CC:-}"
FALLBACK="${FALLBACK:-}"
AUTO_RECIPIENT="${AUTO_RECIPIENT:-}"
PULL_NO_RESTART="${PULL_NO_RESTART:-}"
PULL_HARD_RESET="${PULL_HARD_RESET:-}"
SKIP_MODEM_INIT_PATTERNS=()

# Shared ANSI color codes for consistent styling across outputs
COLOR_RESET='0'
COLOR_CYAN='36'
COLOR_BOLD_RED='1;31'
COLOR_BOLD_GREEN='1;32'
COLOR_BOLD_YELLOW='1;33'
COLOR_BOLD_BLUE='1;34'
COLOR_BOLD_MAGENTA='1;35'
COLOR_BOLD_CYAN='1;36'
COLOR_BOLD_WHITE='1;37'

# Build an ANSI escape sequence for a color code while honoring NO_COLOR/CRON.
ansi_escape() { # $1=colorcode -> ANSI escape sequence honoring NO_COLOR/CRON
  local code="$1"

  if [[ -z "$code" || -n "$NO_COLOR" || -n "$CRON" ]]
  then
    printf ''
    return 0
  fi

  printf '\e[%sm' "$code"
}

# Shared ANSI color codes for consistent styling across outputs
COLOR_RESET='0'
COLOR_CYAN='36'
COLOR_BOLD_RED='1;31'
COLOR_BOLD_GREEN='1;32'
COLOR_BOLD_YELLOW='1;33'
COLOR_BOLD_BLUE='1;34'
COLOR_BOLD_MAGENTA='1;35'
COLOR_BOLD_CYAN='1;36'
COLOR_BOLD_WHITE='1;37'

# Strip leading and trailing whitespace from a string.
trim() {
  local s="$1"
  s="${s#"${s%%[![:space:]]*}"}"
  s="${s%"${s##*[![:space:]]}"}"
  printf '%s' "$s"
}

# Add a unique skip-modem-init pattern after normalizing input.
add_skip_modem_init_pattern() {
  local pattern
  pattern="$(trim "$1")"
  [[ -z "$pattern" ]] && return 0

  local existing
  for existing in "${SKIP_MODEM_INIT_PATTERNS[@]}"
  do
    if [[ "${existing,,}" == "${pattern,,}" ]]
    then
      return 0
    fi
  done

  SKIP_MODEM_INIT_PATTERNS+=("$pattern")
}

# Populate skip-modem-init patterns from config variables and formats.
apply_skip_modem_init_from_config() {
  local decl

  if decl="$(declare -p SKIP_MODEM_INIT 2>/dev/null)"
  then
    if [[ "$decl" == "declare -a"* ]]
    then
      local pattern
      for pattern in "${SKIP_MODEM_INIT[@]}"
      do
        add_skip_modem_init_pattern "$pattern"
      done
      return 0
    fi
  elif [[ -z "${SKIP_MODEM_INIT:-}" ]]
  then
    return 0
  fi

  local raw="${SKIP_MODEM_INIT:-}"
  if [[ -z "$raw" ]]
  then
    return 0
  fi

  if [[ "$raw" == *$'\n'* ]]
  then
    while IFS= read -r line
    do
      add_skip_modem_init_pattern "$line"
    done <<< "$raw"
  elif [[ "$raw" == *,* ]]
  then
    local -a patterns=()
    local IFS=','
    read -ra patterns <<< "$raw"
    local pattern
    for pattern in "${patterns[@]}"
    do
      add_skip_modem_init_pattern "$pattern"
    done
  else
    add_skip_modem_init_pattern "$raw"
  fi
}

PARSED_ARGS=()
PARSE_SHIFT=0

MODEM_EXPLICIT=""
LOG_ABBREV_LEN="${LOG_ABBREV_LEN:-80}"

# Source the configuration file and apply derived runtime settings.
load_config() {
  echo_debug "loading config: $CONFIG_FILE"

  # shellcheck disable=SC1090
  if ! source "$CONFIG_FILE"
  then
    echo_warning "failed to load config: $CONFIG_FILE"
    return 1
  fi

  apply_skip_modem_init_from_config
}

# Ensure SMS_WHITELIST is defined as an array if provided by the config
if ! declare -p SMS_WHITELIST &>/dev/null
then
  SMS_WHITELIST=()
fi

# Allow overriding the whitelist via SMS_WHITELIST_OVERRIDE (comma or space separated digits)
if [[ -n "${SMS_WHITELIST_OVERRIDE:-}" ]]
then
  # shellcheck disable=SC2206
  SMS_WHITELIST=( ${SMS_WHITELIST_OVERRIDE//,/ } )
elif (( ${#SMS_WHITELIST[@]} == 0 )) && \
     declare -p SMS_WHITELIST_DEFAULT &>/dev/null
then
  SMS_WHITELIST=("${SMS_WHITELIST_DEFAULT[@]}")
fi

WATCH_FIFO=""
WATCH_DBUS_PID=""
WATCH_MODEM_MONITOR_PID=""
MODEM_DETAILS_LOGGED=""

# Return success when plain raw mmcli output without JSON was requested.
raw_plain_requested() {
  [[ -n "$RAW_OUTPUT" && -z "$JSON_OUTPUT" ]]
}

# Return success when raw mmcli JSON output was requested.
raw_json_requested() {
  [[ -n "$RAW_OUTPUT" && -n "$JSON_OUTPUT" ]]
}

# Return success when custom formatted JSON output was requested.
custom_json_requested() {
  [[ -n "$JSON_OUTPUT" && -z "$RAW_OUTPUT" ]]
}

# Return success when any JSON-like output mode should be used.
json_like_requested() {
  raw_json_requested || custom_json_requested
}

# DIRTYFIX OpenWrt's jq is not compiled with ONIGURUMA
jq() {
  if [[ -x /srv/bin/jq ]]
  then
    /srv/bin/jq "$@"
    return $?
  fi

  command jq "$@"
}

# Log and run generic mmcli calls (no implicit --modem)
mmcli() {
  echo_debug "\$ mmcli $*"
  command mmcli "$@"
}

mmcli_cmd() {
  command mmcli --modem "$MODEM" "$@"
}

# Print the top-level usage summary for the script.
usage() {
  cat <<USAGE
Usage: $SCRIPT_NAME [OPTIONS] COMMAND [ARGS]

Options:
  -A, --auto            Fallback: if foreign blocked, use modem's default recipient
  -a, --all             List/Prune/Enable/Reset: operate on all modems
  -c, --config PATH     Use alternate config file for watch
  -d, --debug           Enable debug output
  -F, --fallback        Send/Watch: on failure, try other modem(s)
      --chunk[=SIZE]   Send: split SMS text into SIZE-character chunks (default: 160)
  -f, --allow-foreign   Send: allow sending to foreign country codes
  -H, --hard            Reset: also stop/start modemmanager (hard reset)
      --replug         Reset: temporarily deauthorize the modem's USB device via sysfs
  -j, --json            Output JSON (for list/status/read)
  -m, --modem MODEM     Modem selector or id (default: $MODEM)
                        Accepts id (e.g. 2), dbus path, 'any', or
                        a string matching manufacturer/plugin/ttyUSB/phone-number
                        or country (fr/de/us) or country name (france/germany/us)
  -q, --quiet           Suppress info output (warnings/errors only) and status output (exit code only)
      --silent          Same as --quiet
  -r, --raw             Use mmcli output format; combine with --json for raw mmcli JSON
  -R, --retry COUNT     Set SMS send retry attempts (default: ${SMS_RETRY_COUNT})
  -s, --syslog          Mirror logs to syslog (in addition to stderr)
  -S, --sent            Prune: delete only sent outgoing messages
      --skip-modem-init PATTERN
                        Enable: skip vendor-specific modem initialization when
                        modem details match PATTERN (repeatable)
  -x, --trace           Enable shell tracing (set -x)
  -h, --help            Show this help and exit

Commands:
  at [AT_COMMAND]            Issue AT command to modem (interactive if no COMMAND)
  enable                     Wait for ModemManager and enable the modem
  list                       List SMS messages on the modem
  logs [LOGREAD_ARGS]        Show log entries from logread
  number|phone               Print modem's own phone number
  prune                      Delete all SMS messages from the modem
  read MESSAGE_ID            Show details for a specific SMS
  restart                    Restart modemmanager, issue vendor reset, re-enable modem
  send RECIPIENT [TEXT|-]    Send SMS; use '-' or stdin for TEXT
  pull [--hard] [--no-restart]
                             Update repository and restart service
  service [ACTION]           Control the ${SCRIPT_NAME} service (start|stop|restart|status)
  smsc                       Print modem's configured SMSC number
  status                     Show modem status summary
  watch                      Monitor incoming SMS and forward/execute actions
USAGE
}

# Subcommand-specific usage helpers (concise, focused on per-command flags)
# Print usage details for the at subcommand.
usage_at() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] at [OPTIONS] [COMMAND]

Issue and AT command to the modem's AT port. If COMMAND is omitted, enters interactive mode.

Relevant flags:
  -w, --wait[=SECONDS]  Wait for the modem AT port before running the command.
                        Defaults to ${AT_WAIT_TIMEOUT_DEFAULT}s when no value is provided.
                        Use 0 to wait indefinitely.
USAGE
}

# Subcommand-specific usage helpers (concise, focused on per-command flags)
# Print usage details for the send subcommand.
usage_send() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] send [RECIPIENT] TEXT|-

Sends an SMS. If RECIPIENT is omitted, uses DEFAULT_RECIPIENT_XX/CC/DEFAULT.

Relevant flags:
  -A, --auto, --auto-recipient  When fallback, use modem defaults if original blocked
  -c, --config PATH    Load config for defaults (only needed outside 'watch')
  -F, --fallback       Try other modems on failure (sorted by id)
      --chunk[=SIZE]   Split message into SIZE-character chunks (default: 160 when omitted)
  -f, --allow-foreign Allow sending outside the modem's home country code
  -R, --retry COUNT    Override SMS resend attempts
USAGE
}

# Print usage details for the list subcommand.
usage_list() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] list [-a|--all] [-j|--json] [-r|--raw]

Lists SMS messages. Pretty by default; --json prints structured JSON; --raw prints mmcli output
(combine with --json for mmcli JSON).

Relevant flags:
  -a, --all    Include messages from all modems
  -j, --json   Output custom JSON array
  -r, --raw    Output mmcli-format details (combine with --json for mmcli JSON)
USAGE
}

# Print usage details for the logs subcommand.
usage_logs() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] logs [LOGREAD_ARGS]

Prints $SCRIPT_NAME-related log entries from logread (if available). Extra args passed to logread.
USAGE
}

# Print usage details for the read subcommand.
usage_read() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] read MESSAGE_ID [-j|--json] [-r|--raw]

Reads a single SMS. --json outputs compact structured JSON; --raw outputs mmcli output
(combine with --json for mmcli JSON).
USAGE
}

# Print usage details for the prune subcommand.
usage_prune() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] prune [-a|--all] [-S|--sent]

Deletes messages. By default deletes all on the selected modem.

Relevant flags:
  -a, --all    Operate on all modems
  -S, --sent   Delete only sent (outgoing, state=sent) messages
USAGE
}

# Print usage details for the enable subcommand.
usage_enable() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] enable [-a|--all] [-w|--wait[=SECONDS]]

Enables the selected modem. With --wait, waits for a matching modem to appear
before enabling it (optionally limited by SECONDS).

Relevant flags:
  -a, --all    Enable all detected modems
  -w, --wait[=SECONDS]
                Wait for modem detection before enabling (default timeout: 600s)
      --skip-modem-init PATTERN
                 Skip vendor-specific modem initialization when modem details
                 match PATTERN (repeatable)
USAGE
}

# Print usage details for the service subcommand.
usage_service() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] service start|stop|restart|status"

Control the $SCRIPT_NAME service.
USAGE
}

# Print usage details for the pull subcommand.
usage_pull() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] pull [--hard] [--no-restart]

Updates the $SCRIPT_NAME repository via git pull. With --hard, runs
git reset --hard before pulling. Use --no-restart to skip restarting the
service after pulling.
USAGE
}

# Print usage details for the status subcommand.
usage_status() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] status [-a|--all] [-j|--json] [-r|--raw]

Shows modem status. --json outputs structured JSON; --raw dumps mmcli output
(combine with --json for mmcli JSON). (Default command)

Relevant flags:
  -a, --all    Include all detected modems
  -j, --json   Output structured JSON
  -r, --raw    Output mmcli status (combine with --json for mmcli JSON)
USAGE
}

# Print usage details for the reset subcommand.
usage_reset() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] reset [-a|--all] [-H|--hard] [--replug]

Resets the selected modem. Issues vendor-specific resets when supported.

Relevant flags:
  -a, --all    Reset all detected modems
  -H, --hard   Stop/start ModemManager around reset
      --replug Temporarily deauthorize/reauthorize the modem's USB device
USAGE
}

# Print usage details for the watch subcommand.
usage_watch() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] watch [-A|--auto-recipient] [-a|--all] [-c|--config PATH] [-E|--enable] [-F|--fallback] [-f|--allow-foreign] [-P|--prune] [-R|--retry COUNT] [--delete-sent]

Watches incoming SMS and executes reply/webhook logic.

Relevant flags:
  -A, --auto, --auto-recipient  When fallback, use modem defaults if original blocked
  -a, --all           Process messages from all modems (default: selected modem only)
  -c, --config PATH   Config file with defaults and whitelist
  -E, --enable        Enable selected modem(s) when starting watch; keep enabling new modems with --all
  -F, --fallback      When replying, try other modems on failure (sorted by id)
  -f, --allow-foreign Allow replies to recipients outside the modem's home CC
  -P, --prune         Delete existing SMS on startup before watching
  -R, --retry COUNT   Override SMS resend attempts
      --delete-sent   Delete SMS from the modem after handling (default: keep)
USAGE
}

# Print usage details for the number subcommand.
usage_number() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] number|phone

Prints the modem's own number (MSISDN) if reported.
USAGE
}

# Print usage details for the smsc subcommand.
usage_smsc() {
  cat <<USAGE
Usage: $SCRIPT_NAME [GLOBAL OPTIONS] smsc

Prints the modem\'s configured SMSC (service center) number when available.
USAGE
}

# Dispatch to the usage helper for the requested subcommand.
print_subcommand_usage() {
  case "$1" in
    at)      usage_at      ;;
    send)    usage_send    ;;
    list)    usage_list    ;;
    logs)    usage_logs    ;;
    read)    usage_read    ;;
    prune)   usage_prune   ;;
    enable)  usage_enable  ;;
    status)  usage_status  ;;
    reset)   usage_reset   ;;
    pull)    usage_pull    ;;
    service) usage_service ;;
    watch)   usage_watch   ;;
    number)  usage_number  ;;
    smsc)    usage_smsc    ;;
    *)       usage         ;;
  esac
}

# Check whether a token matches one of the supported commands.
is_command_token() {
  local token="$1"

  case "$token" in
    at|ati|send|s|list|ls|l|-l|logs|log*|read|get|r|prune|clear|delete|-e|*enable*|en|start|status|stat|st|number|phone|reset|rst|restart|pull|service|svc|watch|w|smsc|help)
      return 0
      ;;
  esac

  return 1
}

# Parse command-line options common to all subcommands.
parse_common_option() {
  PARSE_SHIFT=0
  local opt="$1"
  local value="${2:-}"

  case "$opt" in
    -m|--modem)
      if [[ -z "$value" ]]
      then
        echo_error "missing value for $opt"
        return 2
      fi
      DEBUG_FLAGS+=("${opt}=$value")
      MODEM="$value"
      MODEM_EXPLICIT=1
      PARSE_SHIFT=2
      return 0
      ;;
    -d|--debug)
      DEBUG_FLAGS+=("$opt")
      # shellcheck disable=SC2034
      DEBUG=1
      PARSE_SHIFT=1
      return 0
      ;;
    -q|--quiet|--silent)
      DEBUG_FLAGS+=("$opt")
      QUIET=1
      PARSE_SHIFT=1
      return 0
      ;;
    -x|--trace)
      DEBUG_FLAGS+=("$opt")
      PS4='+ [${BASH_SOURCE##*/}:${LINENO}] ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
      set -x
      PARSE_SHIFT=1
      return 0
      ;;
    -s|--syslog)
      DEBUG_FLAGS+=("$opt")
      # shellcheck disable=SC2034
      ECHO_SYSLOG=1
      PARSE_SHIFT=1
      return 0
      ;;
    -c|--config)
      if [[ -z "$value" ]]
      then
        echo_error "missing value for $opt"
        return 2
      fi
      DEBUG_FLAGS+=("${opt}=$value")
      CONFIG_FILE="$value"
      PARSE_SHIFT=2
      return 0
      ;;
    --skip-modem-init)
      if [[ -z "$value" ]]
      then
        echo_error "missing value for $opt"
        return 2
      fi
      DEBUG_FLAGS+=("${opt}=$value")
      add_skip_modem_init_pattern "$value"
      PARSE_SHIFT=2
      return 0
      ;;
    --skip-modem-init=*)
      local pattern
      pattern="${opt#*=}"
      if [[ -z "$pattern" ]]
      then
        echo_error "missing value for --skip-modem-init"
        return 2
      fi
      DEBUG_FLAGS+=("--skip-modem-init=$pattern")
      add_skip_modem_init_pattern "$pattern"
      PARSE_SHIFT=1
      return 0
      ;;
  esac

  PARSE_SHIFT=0
  return 1
}

# Parse arguments for the at command and record leftovers in PARSED_ARGS.
parse_at_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage at
        PARSED_ARGS=()
        return 64
        ;;
      -w|--wait)
        AT_WAIT_MODEM=1
        if [[ ! "$AT_WAIT_TIMEOUT" =~ ^[0-9]+$ ]] || (( AT_WAIT_TIMEOUT <= 0 ))
        then
          AT_WAIT_TIMEOUT="$AT_WAIT_TIMEOUT_DEFAULT"
        fi
        shift
        if [[ -n "${1:-}" && "${1:-}" =~ ^[0-9]+$ ]]
        then
          AT_WAIT_TIMEOUT="$1"
          shift
        fi
        continue
        ;;
      -w=*|--wait=*)
        local wait_value
        wait_value="${1#*=}"
        if [[ -z "$wait_value" ]]
        then
          echo_error "missing value for --wait"
          return 2
        fi
        if [[ ! "$wait_value" =~ ^[0-9]+$ ]]
        then
          echo_error "invalid value for --wait: '$wait_value' (expected integer seconds)"
          return 2
        fi
        AT_WAIT_MODEM=1
        AT_WAIT_TIMEOUT="$wait_value"
        shift
        continue
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

# Parse arguments for the send command and record leftovers in PARSED_ARGS.
parse_send_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage send
        PARSED_ARGS=()
        return 64
        ;;
      -A|--auto|--auto-recipient)
        DEBUG_FLAGS+=("$1")
        AUTO_RECIPIENT=1
        shift
        continue
        ;;
      -F|--fallback)
        DEBUG_FLAGS+=("$1")
        FALLBACK=1
        shift
        continue
        ;;
      --chunk)
        local chunk_value="160"
        if (( $# > 1 )) && [[ "${2}" =~ ^[0-9]+$ ]]
        then
          chunk_value="$2"
          shift 2
        else
          shift
        fi
        if [[ ! "$chunk_value" =~ ^[0-9]+$ ]] || (( chunk_value <= 0 ))
        then
          echo_error "--chunk requires a positive integer size"
          return 2
        fi
        DEBUG_FLAGS+=("--chunk=$chunk_value")
        SMS_CHUNK_SIZE="$chunk_value"
        continue
        ;;
      --chunk=*)
        local chunk_value
        chunk_value="${1#*=}"
        if [[ -z "$chunk_value" ]]
        then
          chunk_value="160"
        fi
        if [[ ! "$chunk_value" =~ ^[0-9]+$ ]] || (( chunk_value <= 0 ))
        then
          echo_error "--chunk requires a positive integer size"
          return 2
        fi
        DEBUG_FLAGS+=("--chunk=$chunk_value")
        SMS_CHUNK_SIZE="$chunk_value"
        shift
        continue
        ;;
      -f|--allow-foreign)
        DEBUG_FLAGS+=("$1")
        ALLOW_FOREIGN=1
        shift
        continue
        ;;
      -R|--retry)
        if (( $# < 2 ))
        then
          echo_error "missing value for $1"
          return 2
        fi
        if [[ ! "$2" =~ ^[0-9]+$ ]]
        then
          echo_error "--retry requires a non-negative integer"
          return 2
        fi
        DEBUG_FLAGS+=("$1=$2")
        SMS_RETRY_COUNT="$2"
        shift 2
        continue
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

# Parse arguments for the list command and record leftovers in PARSED_ARGS.
parse_list_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage list
        PARSED_ARGS=()
        return 64
        ;;
      -a|--all)
        DEBUG_FLAGS+=("$1")
        ALL_MODEMS=1
        shift
        continue
        ;;
      -j|--json)
        DEBUG_FLAGS+=("$1")
        JSON_OUTPUT=1
        JSON_OUTPUT_FORCED=1
        shift
        continue
        ;;
      -r|--raw)
        DEBUG_FLAGS+=("$1")
        RAW_OUTPUT=1
        RAW_OUTPUT_FORCED=1
        shift
        continue
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

# Parse arguments for the logs command and record leftovers in PARSED_ARGS.
parse_logs_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage logs
        PARSED_ARGS=()
        return 64
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

# Parse arguments for the read command and record leftovers in PARSED_ARGS.
parse_read_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage read
        PARSED_ARGS=()
        return 64
        ;;
      -j|--json)
        DEBUG_FLAGS+=("$1")
        JSON_OUTPUT=1
        JSON_OUTPUT_FORCED=1
        shift
        continue
        ;;
      -r|--raw)
        DEBUG_FLAGS+=("$1")
        RAW_OUTPUT=1
        RAW_OUTPUT_FORCED=1
        shift
        continue
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

# Parse arguments for the prune command and record leftovers in PARSED_ARGS.
parse_prune_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage prune
        PARSED_ARGS=()
        return 64
        ;;
      -a|--all)
        DEBUG_FLAGS+=("$1")
        ALL_MODEMS=1
        shift
        continue
        ;;
      -S|--sent)
        DEBUG_FLAGS+=("$1")
        SENT_ONLY=1
        shift
        continue
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

# Parse arguments for the enable command and record leftovers in PARSED_ARGS.
parse_enable_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage enable
        PARSED_ARGS=()
        return 64
        ;;
      -a|--all)
        DEBUG_FLAGS+=("$1")
        ALL_MODEMS=1
        shift
        continue
        ;;
      -w|--wait)
        DEBUG_FLAGS+=("$1")
        ENABLE_WAIT_MODEM=1
        if [[ ! "$ENABLE_WAIT_TIMEOUT" =~ ^[0-9]+$ ]] || (( ENABLE_WAIT_TIMEOUT <= 0 ))
        then
          ENABLE_WAIT_TIMEOUT="$ENABLE_WAIT_TIMEOUT_DEFAULT"
        fi
        shift
        if [[ -n "${1:-}" && "${1:-}" =~ ^[0-9]+$ ]]
        then
          ENABLE_WAIT_TIMEOUT="$1"
          shift
        fi
        continue
        ;;
      -w=*|--wait=*)
        local wait_value
        wait_value="${1#*=}"
        if [[ -z "$wait_value" ]]
        then
          echo_error "missing value for --wait"
          return 2
        fi
        if [[ ! "$wait_value" =~ ^[0-9]+$ ]]
        then
          echo_error "invalid value for --wait: '$wait_value' (expected integer seconds)"
          return 2
        fi
        DEBUG_FLAGS+=("$1")
        ENABLE_WAIT_MODEM=1
        ENABLE_WAIT_TIMEOUT="$wait_value"
        shift
        continue
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

# Parse arguments for the service command and record leftovers in PARSED_ARGS.
parse_service_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage service
        PARSED_ARGS=()
        return 64
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

# Parse arguments for the pull command and record leftovers in PARSED_ARGS.
parse_pull_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage pull
        PARSED_ARGS=()
        return 64
        ;;
      --hard)
        DEBUG_FLAGS+=("$1")
        PULL_HARD_RESET=1
        shift
        continue
        ;;
      --no-restart)
        DEBUG_FLAGS+=("$1")
        PULL_NO_RESTART=1
        shift
        continue
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

# Parse arguments for the status command and record leftovers in PARSED_ARGS.
parse_status_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage status
        PARSED_ARGS=()
        return 64
        ;;
      -a|--all)
        DEBUG_FLAGS+=("$1")
        ALL_MODEMS=1
        shift
        continue
        ;;
      -j|--json)
        DEBUG_FLAGS+=("$1")
        JSON_OUTPUT=1
        JSON_OUTPUT_FORCED=1
        shift
        continue
        ;;
      -r|--raw)
        DEBUG_FLAGS+=("$1")
        RAW_OUTPUT=1
        RAW_OUTPUT_FORCED=1
        shift
        continue
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

# Parse arguments for the reset command and record leftovers in PARSED_ARGS.
parse_reset_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage reset
        PARSED_ARGS=()
        return 64
        ;;
      -a|--all)
        DEBUG_FLAGS+=("$1")
        ALL_MODEMS=1
        shift
        continue
        ;;
      -H|--hard)
        DEBUG_FLAGS+=("$1")
        HARD_RESET=1
        shift
        continue
        ;;
      --replug)
        DEBUG_FLAGS+=("$1")
        USB_REPLUG=1
        shift
        continue
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

# Parse arguments for the watch command and record leftovers in PARSED_ARGS.
parse_watch_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage watch
        PARSED_ARGS=()
        return 64
        ;;
      -A|--auto|--auto-recipient)
        DEBUG_FLAGS+=("$1")
        AUTO_RECIPIENT=1
        shift
        continue
        ;;
      -a|--all)
        DEBUG_FLAGS+=("$1")
        ALL_MODEMS=1
        shift
        continue
        ;;
      -E|--enable)
        DEBUG_FLAGS+=("$1")
        WATCH_ENABLE=1
        shift
        continue
        ;;
      -F|--fallback)
        DEBUG_FLAGS+=("$1")
        FALLBACK=1
        shift
        continue
        ;;
      -f|--allow-foreign)
        DEBUG_FLAGS+=("$1")
        ALLOW_FOREIGN=1
        shift
        continue
        ;;
      -P|--prune)
        DEBUG_FLAGS+=("$1")
        WATCH_PRUNE=1
        shift
        continue
        ;;
      -R|--retry)
        if (( $# < 2 ))
        then
          echo_error "missing value for $1"
          return 2
        fi
        if [[ ! "$2" =~ ^[0-9]+$ ]]
        then
          echo_error "--retry requires a non-negative integer"
          return 2
        fi
        DEBUG_FLAGS+=("$1=$2")
        SMS_RETRY_COUNT="$2"
        shift 2
        continue
        ;;
      --delete-sent)
        DEBUG_FLAGS+=("$1")
        WATCH_DELETE_AFTER=1
        WATCH_DELETE_AFTER_CLI_OVERRIDE=1
        shift
        continue
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

# Parse arguments for the number command and record leftovers in PARSED_ARGS.
parse_number_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage number
        PARSED_ARGS=()
        return 64
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

# Parse arguments for the smsc command and record leftovers in PARSED_ARGS.
parse_smsc_args() {
  PARSED_ARGS=()
  local -a out=()

  while (( $# > 0 ))
  do
    case "$1" in
      -h|--help)
        print_subcommand_usage smsc
        PARSED_ARGS=()
        return 64
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          out+=("$1")
          shift
        done
        break
        ;;
      *)
        parse_common_option "$1" "${2:-}"
        local status=$?
        if (( status == 0 ))
        then
          (( PARSE_SHIFT > 0 )) && shift "$PARSE_SHIFT"
          continue
        elif (( status == 2 ))
        then
          return 2
        fi
        out+=("$1")
        shift
        ;;
    esac
  done

  PARSED_ARGS=("${out[@]}")
  return 0
}

# Route to the parser for the active subcommand and store remaining args.
parse_command_args() {
  local command="$1"
  shift || true

  case "$command" in
    at)
      parse_at_args "$@"
      return $?
      ;;
    send)
      parse_send_args "$@"
      return $?
      ;;
    list)
      parse_list_args "$@"
      return $?
      ;;
    logs)
      parse_logs_args "$@"
      return $?
      ;;
    read)
      parse_read_args "$@"
      return $?
      ;;
    prune)
      parse_prune_args "$@"
      return $?
      ;;
    enable)
      parse_enable_args "$@"
      return $?
      ;;
    pull)
      parse_pull_args "$@"
      return $?
      ;;
    service)
      parse_service_args "$@"
      return $?
      ;;
    status)
      parse_status_args "$@"
      return $?
      ;;
    reset)
      parse_reset_args "$@"
      return $?
      ;;
    watch)
      parse_watch_args "$@"
      return $?
      ;;
    number)
      parse_number_args "$@"
      return $?
      ;;
    smsc)
      parse_smsc_args "$@"
      return $?
      ;;
    *)
      PARSED_ARGS=("$@")
      return 0
      ;;
  esac
}

# Map selector to a country calling code (digits) for a small set
# Supports: fr (France=33), de (Germany=49), us/usa (United States=1)
country_to_cc() {
  local s="${1,,}"

  case "$s" in
    fr|fra|france)
      printf '33'
      ;;
    de|deu|germany|deutschland)
      printf '49'
      ;;
    us|usa|"united states"|"united-states"|america)
      printf '1'
      ;;
    *)
      return 1
      ;;
  esac
}

# Determine the home country code for E.164 numbers
# Priority:
#  - HOME_CC if set (digits only, e.g., 49)
#  - Derive from OWN_NUMBER (heuristic: +1 -> 1, otherwise first two digits)
get_home_cc() {
  local target_mid="${1:-}"
  local cc=""
  if [[ -n "$HOME_CC" ]]
  then
    cc="${HOME_CC//[^0-9]/}"
    printf '%s' "$cc"
    return 0
  fi

  # Prefer using load_own_number to respect current MODEM context
  local own=""
  if [[ -n "$target_mid" ]]
  then
    if MODEM="$target_mid" load_own_number
    then
      own="$OWN_NUMBER"
    fi
  elif load_own_number
  then
    own="$OWN_NUMBER"
  fi

  if [[ -z "$own" ]]
  then
    # Fallback to direct mmcli parsing
    local j

    if [[ -n "$target_mid" ]]
    then
      j="$(mmcli -m "$target_mid" -J)"
    else
      j="$(mmcli_cmd -J)"
    fi

    if [[ -n "$j" ]]
    then
      own="$(jq -r '.modem.generic["own-numbers"][0] // empty' <<<"$j")"
    fi
  fi

  if [[ "$own" == +* ]]
  then
    local digits="${own#+}"
    if [[ "$digits" == 1* ]]
    then
      cc="1"
    else
      cc="${digits:0:2}"
    fi
    printf '%s' "$cc"
    return 0
  fi

  return 1
}

# Derive a simple country code from a phone number in +E.164 form
phone_cc() {
  local n="$1"
  if [[ "$n" == +* ]]
  then
    local d="${n#+}"

    if [[ "$d" == 1* ]]
    then
      printf '1'
      return 0
    fi

    printf '%s' "${d:0:2}"
    return 0
  fi

  printf '%s' "--"
}

# Map a numeric country calling code to a short human-readable label
cc_to_label() {
  case "$1" in
    1) printf 'US' ;;
    33) printf 'FR' ;;
    49) printf 'DE' ;;
    *) printf '%s' "$1" ;;
  esac
}

# Return a human-readable CC label (US/FR/DE) for a +E.164 phone number
phone_cc_label() {
  local cc
  cc="$(phone_cc "$1")"
  cc_to_label "$cc"
}

# Ensure a phone/MSISDN has leading '+' when it's only digits
ensure_plus() {
  local n="${1:-}"

  if [[ -z "$n" ]]
  then
    printf '%s' ""
    return 0
  fi

  if [[ "$n" != +* && "$n" =~ ^[0-9]+$ ]]
  then
    printf '+%s' "$n"
  else
    printf '%s' "$n"
  fi
}

# Abbreviate text for logs: strip CR, escape newlines/backslashes, and truncate
abbrev_text_for_log() {
  local s="${1:-}"
  local maxlen="${2:-$LOG_ABBREV_LEN}"

  s=${s//$'\r'/}
  s=${s//$'\n'/\\n}
  s=${s//\\/\\\\}

  if [[ -z "$s" ]]
  then
    s="<empty>"
  fi

  if (( ${#s} > maxlen ))
  then
    s="${s:0:maxlen}â€¦"
  fi

  printf '%s' "$s"
}

# Map mmcli SMS pdu-type to a friendly type label
pdu_to_type() {
  local pdu="${1,,}"
  case "$pdu" in
    deliver) printf 'received' ;;
    submit) printf 'sent' ;;
    status-report) printf 'report' ;;
    *) printf '%s' "$1" ;;
  esac
}

# List modem ids sorted numerically (one per line)
list_modem_ids_sorted() {
  local list_json
  if ! list_json="$(mmcli -L -J)"
  then
    return 1
  fi

  jq -r '."modem-list"[]? | split("/")[-1]' <<<"$list_json" | sort -n
}

# Check whether modem info JSON matches a human-friendly selector.
modem_info_matches_selector() {
  local selector_raw="$1"
  local info_json="$2"
  shift 2

  local selector
  selector="$(trim "$selector_raw")"
  if [[ -z "$selector" ]]
  then
    return 1
  fi

  local selector_lc="${selector,,}"
  local selector_digits="${selector//[^0-9+]/}"

  local cc_filter=""
  if ! cc_filter="$(country_to_cc "$selector")"
  then
    cc_filter=""
  fi

  local -a text_fields=()
  if ! mapfile -t text_fields < <(jq -r '
    .modem.generic as $g
    | [
        ($g.manufacturer // ""),
        ($g.model // ""),
        ($g.plugin // ""),
        ($g["primary-port"] // ""),
        (($g.ports // [])[]? | (split(" ")[0]))
      ]
    | .[]
    | select(. != "")
  ' <<<"$info_json")
  then
    text_fields=()
  fi

  if (( $# > 0 ))
  then
    local extra
    for extra in "$@"
    do
      if [[ -n "$extra" ]]
      then
        text_fields+=("$extra")
      fi
    done
  fi

  local -a number_fields=()
  if ! mapfile -t number_fields < <(jq -r '
    .modem.generic["own-numbers"][]?
    | select(. != "")
  ' <<<"$info_json")
  then
    number_fields=()
  fi

  local field
  if [[ -n "$cc_filter" ]]
  then
    for field in "${number_fields[@]}"
    do
      [[ -z "$field" ]] && continue
      local digits_only="${field//[^0-9]/}"
      if [[ -n "$digits_only" && "$digits_only" == "$cc_filter"* ]]
      then
        printf '%s' "$field"
        return 0
      fi
    done
  fi

  for field in "${text_fields[@]}"
  do
    [[ -z "$field" ]] && continue
    if [[ "${field,,}" == *"$selector_lc"* ]]
    then
      printf '%s' "$field"
      return 0
    fi
  done

  for field in "${number_fields[@]}"
  do
    [[ -z "$field" ]] && continue
    if [[ "${field,,}" == *"$selector_lc"* ]]
    then
      printf '%s' "$field"
      return 0
    fi

    if [[ -n "$selector_digits" ]]
    then
      local digits_with_plus="${field//[^0-9+]/}"
      if [[ "$digits_with_plus" == *"$selector_digits"* ]]
      then
        printf '%s' "$field"
        return 0
      fi
    fi

    if printf '%s\n' "$field" | grep -Eq -- "$selector"
    then
      printf '%s' "$field"
      return 0
    fi
  done

  return 1
}

# Resolve a human-friendly modem selector to a concrete modem id
# - Accepts: numeric id (e.g., 2), D-Bus path, 'any', or a substring
#   matching manufacturer, model, plugin, primary-port, or any ttyUSB/wwan port.
# - On multiple matches, prints a modem list to stderr and returns non-zero.
# - On no match, reports an error and shows the list.
get_modem_id() {
  local sel_raw="${1:-}"
  # Default / passthrough cases
  if [[ -z "$sel_raw" || "$sel_raw" == any ]]
  then
    printf '%s' "any"
    return 0
  fi

  # If a D-Bus path (/org/.../Modem/N)
  if [[ "$sel_raw" == */Modem/* ]]
  then
    printf '%s' "${sel_raw##*/}"
    return 0
  fi

  local list_json ids id json
  if ! list_json="$(mmcli -L -J)"
  then
    echo_error "could not query modem list via mmcli"
    return 1
  fi

  # Collect modem ids
  mapfile -t ids < <(jq -r '."modem-list"[]? | split("/")[-1]' <<<"$list_json")
  if (( ${#ids[@]} == 0 ))
  then
    echo_error "no modems detected"
    return 1
  fi

  # If pure numeric input, treat as id only if it matches a detected id; otherwise
  # continue with fuzzy matching (e.g., phone number fragment)
  if [[ "$sel_raw" =~ ^[0-9]+$ ]]
  then
    local _id
    for _id in "${ids[@]}"
    do
      if [[ "$_id" == "$sel_raw" ]]
      then
        printf '%s' "$sel_raw"
        return 0
      fi
    done
  fi

  local matches=()

  for id in "${ids[@]}"
  do
    [[ -z "$id" ]] && continue
    if ! json="$(mmcli -m "$id" -J)"
    then
      continue
    fi

    if modem_info_matches_selector "$sel_raw" "$json" >/dev/null
    then
      matches+=("$id")
    fi
  done

  if (( ${#matches[@]} == 1 ))
  then
    printf '%s' "${matches[0]}"
    return 0
  fi

  # Helper to show available modems for disambiguation
  echo_error "${SCRIPT_NAME}: modem selector '${sel_raw}' matched ${#matches[@]} modem(s)"
  echo_info "Available modems:"

  for id in "${ids[@]}"
  do
    [[ -z "$id" ]] && continue

    if ! json="$(mmcli -m "$id" -J)"
    then
      continue
    fi

    jq -r '
      .modem as $m
      | {
          id: ($m["dbus-path"] | split("/")[-1]),
          manufacturer: ($m.generic.manufacturer // "--"),
          model: ($m.generic.model // "--"),
          plugin: ($m.generic.plugin // "--"),
          primary: ($m.generic["primary-port"] // "--"),
          ports: (($m.generic.ports // []) | map(split(" ")[0]) | join(","))
        }
      | ("  " + .id + ": " + .manufacturer + " " + .model
         + " plugin=" + .plugin
         + " primary=" + .primary
         + " ports=" + .ports)
    ' <<<"$json" >&2
  done

  if (( ${#matches[@]} == 0 ))
  then
    return 1
  fi

  # Ambiguous modem selector, the user is at fault!
  return 2
}


# Resolve a modem selector and return its mmcli JSON description.
get_modem() {
  local selector="${1:-}"

  if [[ -z "$selector" ]]
  then
    if [[ -n "$MODEM" ]]
    then
      selector="$MODEM"
    else
      selector="any"
    fi
  fi

  selector="$(trim "$selector")"
  if [[ -z "$selector" ]]
  then
    selector="any"
  fi

  local mmcli_target="$selector"
  if [[ "$mmcli_target" != "any" && "$mmcli_target" != */Modem/* && ! "$mmcli_target" =~ ^[0-9]+$ ]]
  then
    if ! mmcli_target="$(get_modem_id "$mmcli_target")"
    then
      return "$?"
    fi
  fi

  mmcli -m "$mmcli_target" -J
}

# Convert modem JSON into a concise key=value summary string.
modem_info_string_from_json() {
  local info_json="$1"
  local fallback_id="${2:-}"

  if [[ -z "$info_json" ]]
  then
    return 1
  fi

  if [[ -n "$fallback_id" ]]
  then
    fallback_id="$(trim "$fallback_id")"
  fi

  local fields
  if ! fields="$(jq -r '
      .modem as $m
      | [
          ($m["dbus-path"] | split("/")[-1] // ""),
          ($m.generic.manufacturer // "--"),
          ($m.generic.model // "--"),
          ($m.generic.plugin // "--"),
          ($m.generic["primary-port"] // "--"),
          (($m.generic.ports // []) | map(split(" ")[0]) | join(",")),
          ($m.generic["own-numbers"][0] // "")
        ]
      | @tsv
    ' <<<"$info_json")"
  then
    return 1
  fi

  if [[ -z "$fields" ]]
  then
    return 1
  fi

  local id manufacturer model plugin primary ports phone cc_label
  IFS=$'\t' read -r id manufacturer model plugin primary ports phone <<<"$fields" || return 1

  phone="$(ensure_plus "$phone")"

  [[ -n "$ports" ]] || ports="--"
  if [[ -z "$id" ]]
  then
    id="$fallback_id"
  fi
  [[ -n "$id" ]] || id="$MODEM"
  [[ -n "$phone" ]] || phone="--"

  cc_label="$(phone_cc_label "$phone")"
  [[ -n "$cc_label" ]] || cc_label="--"

  printf "id='%s' manufacturer='%s' model='%s' plugin='%s' primary='%s' ports='%s' phone='%s' cc='%s'" \
    "$id" "$manufacturer" "$model" "$plugin" "$primary" "$ports" "$phone" "$cc_label"
}

# Get modem JSON and emit a formatted info string with optional prefix.
get_modem_info() {
  local selector="${1:-}"
  local prefix="${2:-}"
  local fallback_id="${selector:-$MODEM}"

  if [[ -n "$fallback_id" ]]
  then
    fallback_id="$(trim "$fallback_id")"
  fi

  local info_json
  if ! info_json="$(get_modem "$selector")"
  then
    return 1
  fi

  local info_string
  if ! info_string="$(modem_info_string_from_json "$info_json" "$fallback_id")"
  then
    return 1
  fi

  printf '%smodem={%s}' "$prefix" "$info_string"
}

# Return a concise modem info string for logs: id=.. manufacturer=.. model=.. plugin=.. primary=..
modem_info_brief() {
  local fallback="$MODEM"
  local info_json info_string

  if info_json="$(mmcli_cmd -J)"
  then
    if info_string="$(modem_info_string_from_json "$info_json" "$fallback")"
    then
      printf '%s' "$info_string"
      return 0
    fi
  fi

  printf "id='%s'" "$fallback"
}

# Log modem identification details with an optional prefix.
log_modem_details() {
  local mid="$1" prefix="${2:-}"
  local info

  if info="$(get_modem_info "$mid" "$prefix")"
  then
    echo_info "$info"
    return 0
  fi

  if [[ -n "$mid" ]]
  then
    echo_info "${prefix}modem={id='$mid'}"
  else
    echo_info "${prefix}modem={}"
  fi
}

# Determine the modem's AT device path, optionally waiting for availability.
get_modem_at_port() {
  local wait_enabled="$AT_WAIT_MODEM"
  local wait_timeout="$AT_WAIT_TIMEOUT"
  local sleep_interval="$AT_WAIT_SLEEP_INTERVAL"

  if [[ ! "$wait_timeout" =~ ^[0-9]+$ ]]
  then
    wait_timeout=0
  fi

  if [[ ! "$sleep_interval" =~ ^[0-9]+(\.[0-9]+)?$ ]]
  then
    sleep_interval=2
  fi

  echo_debug "Resolving modem AT port for '$MODEM'"

  local wait_started=$SECONDS
  local wait_logged=0
  local err="no AT port detected for modem '$MODEM'"

  while :
  do
    local mmcli_out="" json="" port=""

    if ! mmcli_out="$(mmcli -m "$MODEM" -J 2>&1)"
    then
      echo_debug "get_modem_at_port: mmcli failed: ${mmcli_out//$'\n'/ }"
      err="failed to query modem JSON"
    else
      json="$mmcli_out"
      port="$(jq -r '
        def normalize_port:
          if . == null or . == "" then ""
          elif startswith("/") then .
          else "/dev/" + .
          end;
        ((.modem.generic.ports // [])
          | map(select(test("\\(at\\)"; "i")) | split(" ")[0] | normalize_port)
          | map(select(. != ""))
          | .[0])
        // ((.modem.generic["primary-port"] // "") | normalize_port)
      ' <<<"$json")"

      if [[ "$port" == "null" ]]
      then
        port=""
      fi

      if [[ -n "$port" ]]
      then
        echo_debug "resolved modem '$MODEM' AT port candidate '${port}'"
        if [[ -e "$port" ]]
        then
          echo_debug "resolved modem '$MODEM' AT port to '${port}'"
          printf '%s' "$port"
          return 0
        fi
        err="modem '$MODEM' AT port '$port' does not exist"
      else
        err="no AT port detected for modem '$MODEM'"
      fi
    fi

    if [[ -z "$wait_enabled" ]]
    then
      echo_error "$err"
      return 1
    fi

    if (( wait_logged == 0 ))
    then
      if (( wait_timeout > 0 ))
      then
        echo_info "waiting for modem '$MODEM' AT port (timeout ${wait_timeout}s)"
      else
        echo_info "waiting for modem '$MODEM' AT port"
      fi
      wait_logged=1
      wait_started=$SECONDS
    fi

    if (( wait_timeout > 0 ))
    then
      local elapsed=$(( SECONDS - wait_started ))
      if (( elapsed >= wait_timeout ))
      then
        echo_error "$err"
        return 1
      fi
    fi

    sleep "$sleep_interval"
  done
}

# Send an AT command directly to the resolved modem port.
at_command_direct() {
  local cmd="$1"
  local port

  if ! port="$(get_modem_at_port)"
  then
    return 1
  fi

  if [[ ! -w "$port" ]]
  then
    echo_error "AT port '$port' is not writable"
    return 1
  fi

  local fd
  echo_debug "Opening connection to AT port '$port'"
  if ! exec {fd}<>"$port"
  then
    echo_error "Failed to open '$port'"
    return 1
  fi

  local _drain
  while read -r -t "$AT_FALLBACK_READ_TIMEOUT" -u $fd _drain
  do
    :
  done

  echo_debug "AT TX -> $cmd"
  printf '%s\r' "$cmd" >&$fd

  local resp="" line="" timeout_count=0
  while (( timeout_count < AT_FALLBACK_MAX_READS ))
  do
    if ! read -r -t "$AT_FALLBACK_READ_TIMEOUT" -u $fd line
    then
      timeout_count=$((timeout_count + 1))
      continue
    fi

    timeout_count=0
    line="${line%$'\r'}"

    [[ "$line" == "$cmd" ]] && continue

    if [[ -n "$line" ]]
    then
      echo_debug "AT RX <- $line"
      resp+="$line"$'\n'
      if [[ "$line" == "OK" || "$line" == "ERROR" ]]
      then
        break
      fi
    fi
  done

  exec {fd}>&- {fd}<&-

  resp="${resp%$'\n'}"
  if [[ -n "$resp" ]]
  then
    printf '%s' "$resp"
    return 0
  fi

  return 1
}

# Apply vendor-specific AT configuration for Huawei modems.
configure_huawei_modem() {
  echo_info "huawei: configuring modem for SMS text mode"

  local -A at_codes=(
    [AT]="baseline connectivity check"
    [AT&F]="restore factory defaults"
    [AT+CMEE=2]="enable verbose error codes"
    [AT+CMGF=1]="set SMS message format to text"
    [AT+CSMP=17,167,0,0]="set SMS params: submit PDU, validity ~24h, normal PID, 7-bit alphabet"
    [AT+CGSMS=3]="set SMS service to PS preferred (fallback CS)"
    [AT+CMGD=1,4]="delete all messages"
  )

  local cmd resp
  for cmd in "${!at_codes[@]}"
  do
    resp="$(at_command "$cmd")"
    echo_info "huawei: $cmd (${at_codes[$cmd]}) -> $(format_at_response "$resp")"
  done
}

# Apply vendor-specific configuration for Quectel modems (currently no-op).
configure_quectel_modem() {
  echo_debug "quectel: no vendor-specific configuration required"
  return 0
}

# Infer the modem vendor from mmcli-provided JSON information.
modem_vendor_from_info_json() {
  local info_json="$1"

  local plugin manufacturer vendor=""
  plugin="$(jq -r '.modem.generic.plugin // ""' <<<"$info_json")"
  manufacturer="$(jq -r '.modem.generic.manufacturer // ""' <<<"$info_json")"

  if [[ "${plugin,,}" == huawei || "${manufacturer,,}" == huawei* ]]
  then
    vendor="huawei"
  elif [[ "${plugin,,}" == quectel || "${manufacturer,,}" == quectel* ]]
  then
    vendor="quectel"
  fi

  if [[ -n "$vendor" ]]
  then
    printf '%s' "$vendor"
    return 0
  fi

  return 1
}

# Run vendor-specific configuration unless excluded by skip patterns.
configure_modem_vendor() {
  local info_json="$1"

  local vendor
  if ! vendor="$(modem_vendor_from_info_json "$info_json")"
  then
    return 0
  fi

  if (( ${#SKIP_MODEM_INIT_PATTERNS[@]} > 0 ))
  then
    local -a extra_fields=()
    if [[ -n "$vendor" ]]
    then
      extra_fields+=("$vendor")
    fi

    local pattern matched_field
    for pattern in "${SKIP_MODEM_INIT_PATTERNS[@]}"
    do
      pattern="$(trim "$pattern")"
      [[ -z "$pattern" ]] && continue

      matched_field=""
      if matched_field="$(modem_info_matches_selector "$pattern" "$info_json" "${extra_fields[@]}")"
      then
        if [[ -n "$matched_field" ]]
        then
          echo_info "$vendor: skipping vendor-specific initialization (--skip-modem-init \"$pattern\" matched \"$matched_field\")"
        else
          echo_info "$vendor: skipping vendor-specific initialization (--skip-modem-init \"$pattern\")"
        fi
        return 0
      fi
    done
  fi

  case "$vendor" in
    huawei)
      configure_huawei_modem
      ;;
    quectel)
      configure_quectel_modem
      ;;
  esac
}

# Issue the Quectel power-down command as part of reset handling.
reset_quectel_modem() {
  reset_log "quectel: sending AT+QPOWD=0"

  local resp=""
  if ! resp="$(at_command 'AT+QPOWD=0')"
  then
    echo_error "quectel reset failed"
  fi

  local formatted_resp
  formatted_resp="$(format_at_response "$resp")"
  reset_log "quectel: AT+QPOWD=0 -> $formatted_resp"

  return 0
}

# Perform vendor-specific reset logic for the current modem.
reset_modem_vendor() {
  local info_json="${1:-}"
  local vendor="${2:-}"

  if [[ -z "$vendor" ]]
  then
    if [[ -z "$info_json" ]]
    then
      return 0
    fi
    if ! vendor="$(modem_vendor_from_info_json "$info_json")"
    then
      return 0
    fi
  fi

  case "$vendor" in
    quectel)
      reset_quectel_modem
      ;;
  esac

  return 0
}

# Find the sysfs path backing a modem port name.
usb_sysfs_path_for_port() {
  local port="$1"
  local path=""
  local -a bases=(
    "/sys/class/tty/$port"
    "/sys/class/usbmisc/$port"
    "/sys/class/net/$port"
  )

  for path in "${bases[@]}"
  do
    if [[ -e "$path" ]]
    then
      readlink -f "$path"
      return 0
    fi
  done

  return 1
}

# Ascend sysfs to locate the USB device directory for a port.
usb_device_dir_for_path() {
  local path="$1"
  local dir="$path"

  while [[ -n "$dir" && "$dir" != "/" ]]
  do
    if [[ -f "$dir/idVendor" && -f "$dir/idProduct" ]]
    then
      printf '%s\n' "$dir"
      return 0
    fi
    dir="$(dirname "$dir")"
  done

  return 1
}

# Temporarily deauthorize and reauthorize the modem's USB device.
modem_usb_replug() {
  local info_json="$1"

  if [[ -z "$info_json" ]]
  then
    echo_error "cannot replug USB device: missing modem info"
    return 1
  fi

  local -a ports=()
  local jq_status=0
  mapfile -t ports < <(jq -r '
    (.modem.generic.ports // [])
    | map(split(" ")[0])
    | map(select(length > 0)) | .[]
  ' <<<"$info_json") || jq_status=$?

  if (( jq_status != 0 )) && (( ${#ports[@]} == 0 ))
  then
    echo_warning "failed to parse modem ports for USB replug"
    return 1
  fi

  if (( ${#ports[@]} == 0 ))
  then
    echo_warning "no modem ports reported, cannot replug USB device"
    return 1
  fi

  declare -A seen_dirs=()
  declare -A dir_ports=()
  local -a device_dirs=()

  local port
  for port in "${ports[@]}"
  do
    [[ -n "$port" ]] || continue

    local sys_path
    if ! sys_path="$(usb_sysfs_path_for_port "$port")"
    then
      echo_debug "usb replug: unable to resolve sysfs path for port $port"
      continue
    fi

    local device_dir
    if ! device_dir="$(usb_device_dir_for_path "$sys_path")"
    then
      echo_debug "usb replug: no USB device directory found for port $port ($sys_path)"
      continue
    fi

    if [[ -z "${seen_dirs[$device_dir]:-}" ]]
    then
      device_dirs+=("$device_dir")
      seen_dirs["$device_dir"]=1
    fi

    if [[ -n "${dir_ports[$device_dir]:-}" ]]
    then
      dir_ports["$device_dir"]+=" $port"
    else
      dir_ports["$device_dir"]="$port"
    fi
  done

  if (( ${#device_dirs[@]} == 0 ))
  then
    echo_warning "could not resolve USB device backing modem ports (${ports[*]})"
    return 1
  fi

  local bind_path="/sys/bus/usb/drivers/usb/bind"
  local unbind_path="/sys/bus/usb/drivers/usb/unbind"
  local success

  local device_dir
  for device_dir in "${device_dirs[@]}"
  do
    local port_list="${dir_ports[$device_dir]# }"

    local dev_name
    dev_name="$(basename "$device_dir")"

    local vendor
    local product

    if [[ -f "$device_dir/idVendor" ]]
    then
      vendor="$(<"$device_dir/idVendor")"
    fi

    if [[ -f "$device_dir/idProduct" ]]
    then
      product="$(<"$device_dir/idProduct")"
    fi

    local authorized_path="$device_dir/authorized"
    if [[ -w "$authorized_path" ]]
    then
      reset_log "USB replugging device $dev_name (ports: ${port_list:-unknown}, vid:pid ${vendor:-??}:${product:-??})"
      if ! printf '0\n' >"$authorized_path"
      then
        echo_warning "failed to deauthorize USB device $dev_name"
        continue
      fi

      sleep 2

      if ! printf '1\n' >"$authorized_path"
      then
        echo_warning "failed to reauthorize USB device $dev_name"
        continue
      fi

      sleep 2
      success=1
      continue
    fi

    if [[ -w "$unbind_path" && -w "$bind_path" ]]
    then
      reset_log "USB replugging device $dev_name (ports: ${port_list:-unknown}, vid:pid ${vendor:-??}:${product:-??}) via unbind/bind"
      if ! printf '%s\n' "$dev_name" >"$unbind_path"
      then
        echo_warning "failed to unbind USB device $dev_name"
        continue
      fi

      sleep 2

      if ! printf '%s\n' "$dev_name" >"$bind_path"
      then
        echo_warning "failed to bind USB device $dev_name"
        continue
      fi

      sleep 2
      success=1
      continue
    fi

    echo_warning "no supported USB replug control for device $dev_name (ports: ${port_list:-unknown})"
  done

  if [[ -n $success ]]
  then
    return 1
  fi

  return 0
}

# Resolve default recipient based on modem/country-specific variables.
# Order:
#  - DEFAULT_RECIPIENT_<LABEL> (US/FR/DE)
#  - DEFAULT_RECIPIENT_<CC> (1/33/49)
#  - DEFAULT_RECIPIENT
resolve_default_recipient() {
  local mid="${1:-}"

  local cc
  cc="$(get_home_cc "$mid")"

  echo_debug "resolve_default_recipient: mid=${mid:-} cc=${cc:-}"

  # Guard: unknown CC â†’ fall back to global default or fail
  if [[ -z "$cc" ]]
  then
    if [[ -n "${DEFAULT_RECIPIENT-}" ]]
    then
      echo_debug "resolve_default_recipient: cc unknown, using DEFAULT_RECIPIENT=${DEFAULT_RECIPIENT}"
      printf '%s' "${DEFAULT_RECIPIENT}"
      return 0
    fi

    echo_debug "resolve_default_recipient: cc unknown and no DEFAULT_RECIPIENT"
    return 1
  fi

  local label
  case "$cc" in
    1)
      label=US
      ;;
    33)
      label=FR
      ;;
    49)
      label=DE
      ;;
  esac

  # Try label-specific var
  local var val
  if [[ -n "$label" ]]
  then
    var="DEFAULT_RECIPIENT_${label}"
    echo_debug "resolve_default_recipient: try $var"
    if declare -p "$var" &>/dev/null
    then
      val="${!var}"
      if [[ -n "$val" ]]
      then
        echo_debug "resolve_default_recipient: matched $var=$val"
        printf '%s' "$val"
        return 0
      fi
    fi
  fi

  # Try numeric-CC specific var
  var="DEFAULT_RECIPIENT_${cc}"
  echo_debug "resolve_default_recipient: try $var"
  if declare -p "$var" &>/dev/null
  then
    val="${!var}"
    if [[ -n "$val" ]]
    then
      echo_debug "resolve_default_recipient: matched $var=$val"
      printf '%s' "$val"
      return 0
    fi
  fi

  # Global default
  if [[ -n "${DEFAULT_RECIPIENT-}" ]]
  then
    echo_debug "resolve_default_recipient: default DEFAULT_RECIPIENT=${DEFAULT_RECIPIENT}"
    printf '%s' "${DEFAULT_RECIPIENT}"
    return 0
  fi

  echo_debug "resolve_default_recipient: no default found"
  return 1
}

# Detect whether ModemManager is running via the debug wrapper.
modemmanager_running_with_debug() {
  pgrep -a -f 'ModemManager-wrapper.*--debug' &>/dev/null
}

# Run an AT command via mmcli and return the response string
# - Strips the leading "response: '...'") wrapper printed by mmcli
# - If no such wrapper is present, returns raw stdout/stderr as-is
at_command() {
  local cmd="$1"
  local resp

  if modemmanager_running_with_debug
  then
    echo_debug "MM is in debug mode, running AT command '${cmd}' using mmcli"

    local out
    if out="$(mmcli_cmd --command="$cmd" 2>&1)"
    then
      # TODO is this really working for multiple-line responses?
      resp="$(printf '%s\n' "$out" | \
        sed -n "s/^response: '\(.*\)'$/\1/p" | head -n1)"

      if [[ -z "$resp" ]]
      then
        echo_warning "'${cmd}': empty AT command response"
        return 1
      fi

      printf '%s' "$resp"
      return 0
    fi

    echo_debug "mmcli --command='${cmd}' failed, attempting to issue AT command directly"
  fi

  if ! resp="$(at_command_direct "$cmd")"
  then
    echo_debug "direct AT command failed: '$cmd'"
    return 1
  fi

  printf '%s' "$resp"
  return 0
}

# Start an interactive AT command session over the modem port.
at_command_interactive() {
  local port
  if ! port="$(get_modem_at_port)"
  then
    echo_error "Failed to determine AT port for modem $MODEM"
    return 1
  fi

  echo_info "Starting interactive AT command session with $port (exit with Ctrl-D)"
  socat - "${port},crnl"
}

# Invoke logread filtered for this script's messages.
mmsms_logread() {
  echo_debug "logread args: $*"
  logread -e "$SCRIPT_NAME" "$@"
}

# Call the init script for the mmsms service with given arguments.
mmsms_service_action() {
  "/etc/init.d/${SCRIPT_NAME}" "$@"
}

# Update the repository and optionally restart the service after pulling.
mmsms_repo_pull() {
  if [[ -n "$PULL_HARD_RESET" ]]
  then
    echo_info "Resetting repository (git reset --hard)"
    if ! git reset --hard
    then
      echo_error "git reset --hard failed"
      return 1
    fi
  fi

  echo_info "Pulling latest changes"
  if ! git pull
  then
    echo_error "git pull failed"
    return 1
  fi

  if [[ -n "$PULL_NO_RESTART" ]]
  then
    echo_debug "Skipping service restart (--no-restart)"
    return 0
  fi

  echo_info "Restarting $SCRIPT_NAME service"
  if ! mmsms_service_action restart
  then
    echo_error "failed to restart $SCRIPT_NAME service"
    return 1
  fi

  return 0
}

# Flatten multiline AT command responses into a log-friendly string.
format_at_response() {
  local resp="$1"

  if [[ -z "$resp" ]]
  then
    printf '%s' '<no response>'
    return 0
  fi

  resp="${resp//$'\n'/'; '}"
  printf '%s' "$resp"
}

# Decode a UCS2 hex string like "002B0033..." by taking the low byte of each code unit
at_decode_ucs2() {
  local s="$1"

  if [[ "$s" =~ ^([0-9A-Fa-f]{4})+$ ]]
  then
    local out=""
    local pos=0 len=${#s} hb
    while (( pos < len ))
    do
      hb="${s:pos+2:2}"
      out+="$(printf '%b' "\\x$hb")"
      pos=$((pos + 4))
    done

    printf '%s' "$out"
    return 0
  fi

  printf '%s' "$s"
}

# Extract the first double-quoted field from an AT response and decode UCS2 if applicable
at_first_quoted_decoded() {
  local resp="$1"

  local q
  q="$(printf '%s\n' "$resp" | sed -n 's/^.*"\([^"]*\)".*$/\1/p' | head -n1)"

  if [[ -z "$q" ]]
  then
    return 1
  fi

  if [[ "$q" =~ ^([0-9A-Fa-f]{4})+$ ]]
  then
    q="$(at_decode_ucs2 "$q")"
  fi

  printf '%s' "$q"
}

# Choose an ANSI color for a given SMS state.
sms_state_color() { # $1=state
  local state="${1,,}"
  case "$state" in
    received|read|sent|delivered|delivery-success|complete|completed|stored|stored-received|stored-sent)
      printf '%s' "$COLOR_BOLD_GREEN"
      ;;
    queued|pending|sending|temporary|unknown|new|waiting|draft)
      printf '%s' "$COLOR_BOLD_YELLOW"
      ;;
    failed|error|rejected|aborted|cancelled|timeout|unsent|not-sent|undelivered)
      printf '%s' "$COLOR_BOLD_RED"
      ;;
    *)
      printf '%s' "$COLOR_CYAN"
      ;;
  esac
}

# Choose an ANSI color for a given SMS type.
sms_type_color() { # $1=type
  local type="${1,,}"
  case "$type" in
    received)
      printf '%s' "$COLOR_BOLD_GREEN"
      ;;
    sent)
      printf '%s' "$COLOR_BOLD_BLUE"
      ;;
    report|status-report)
      printf '%s' "$COLOR_BOLD_MAGENTA"
      ;;
    *)
      printf '%s' "$COLOR_CYAN"
      ;;
  esac
}

# Summarize SMS direction and party labels for display.
sms_read_party_info() { # $1=type, $2=remote, $3=own
  local type="${1,,}"
  local remote="$2"
  local own="$3"

  local direction="unknown"
  local remote_label="Number"
  local local_label="Own"
  local remote_value="$remote"
  local local_value="$own"

  case "$type" in
    received)
      direction="incoming"
      remote_label="From"
      local_label="To"
      ;;
    sent)
      direction="outgoing"
      remote_label="To"
      local_label="From"
      ;;
    report|status-report)
      direction="network"
      remote_label="Report For"
      local_label="From"
      ;;
  esac

  printf '%s\t%s\t%s\t%s\t%s' "$direction" "$remote_label" "$local_label" "$remote_value" "$local_value"
}

# Fetch an SMS using mmcli and print the raw output.
sms_read_raw() {
  local msg_id="$1"
  mmcli_cmd --sms "$msg_id"
}

# Collect rich JSON details for an SMS message using mmcli.
sms_read_details_json() {
  local msg_id="$1"
  local js pdu msg_type own="" number smsc party_info direction remote_label local_label remote_value local_value payload


  if ! js="$(mmcli_cmd --sms "$msg_id" -J)"
  then
    return 1
  fi

  pdu="$(jq -r '.sms.properties["pdu-type"] // ""' <<<"$js")"
  msg_type="$(pdu_to_type "$pdu")"

  number="$(jq -r '.sms.content.number // ""' <<<"$js")"
  number="$(ensure_plus "$number")"

  if load_own_number
  then
    own="$OWN_NUMBER"
  fi
  own="$(ensure_plus "$own")"

  party_info="$(sms_read_party_info "$msg_type" "$number" "$own")"
  IFS=$'\t' read -r direction remote_label local_label remote_value local_value <<<"$party_info"

  smsc="$(jq -r '.sms.properties.smsc // ""' <<<"$js")"
  smsc="$(ensure_plus "$smsc")"

  if ! payload="$(
    jq --arg type "$msg_type" \
       --arg direction "$direction" \
       --arg remote_label "$remote_label" \
       --arg local_label "$local_label" \
       --arg remote "$remote_value" \
       --arg local "$local_value" \
       --arg own "$own" \
       --arg smsc "$smsc" \
       --arg pdu "$pdu" \
       --arg fallback_modem "$MODEM" \
       --arg msg_id "$msg_id" '
      def blank_to_null:
        if . == null or . == "" then null else . end;

      (.sms.modem // "") as $modem_path
      | (.sms["dbus-path"] // "") as $sms_path
      | ($modem_path | split("/")[-1]) as $modem_id_str
      | ($sms_path | split("/")[-1]) as $sms_id_str
      | $fallback_modem as $fallback
      | {
          id: ($sms_id_str | tonumber?),
          modem_id: ($modem_id_str | tonumber?),
          modem_label: (
            if ($modem_id_str // "") != "" then $modem_id_str
            elif ($fallback | test("^[0-9]+$")) then $fallback
            elif ($fallback | blank_to_null) then $fallback
            else "unknown" end
          ),
          type: ($type | blank_to_null),
          direction: ($direction | blank_to_null),
          state: (.sms.properties.state // null),
          storage: ((.sms.properties.storage // "") | blank_to_null),
          class: ((.sms.properties.class // "") | if . == "" then null else (. | tonumber? // .) end),
          pdu: ($pdu | blank_to_null),
          timestamp: (.sms.properties.timestamp // null),
          discharge_timestamp: (.sms.properties["discharge-timestamp"] // null),
          remote_number: ($remote | blank_to_null),
          remote_label: ($remote_label | blank_to_null),
          local_number: ($local | blank_to_null),
          local_label: ($local_label | blank_to_null),
          own_number: ($own | blank_to_null),
          smsc: ($smsc | blank_to_null),
          text: ((.sms.content.text // null) | if . == null then null else gsub("\r"; "") end),
          encoding: ((.sms.content.encoding // "") | blank_to_null),
          data: ((.sms.content.data // "") | blank_to_null),
          delivery: (
            {state: (.sms.properties["delivery-state"] // ""), report: (.sms.properties["delivery-report"] // "")} as $d
            | if ($d.state == "" and $d.report == "") then null
              else {
                state: ($d.state | blank_to_null),
                report: ($d.report | blank_to_null)
              }
              end
          )
        }
      | .raw_id = (if ($sms_id_str // "") != "" then $sms_id_str else $msg_id end)
      | .raw_modem_id = (if ($modem_id_str // "") != "" then $modem_id_str else $fallback end)
    ' <<<"$js"
  )"
  then
    return 1
  fi

  printf '%s\n' "$payload"
}

# Render SMS details in a colorized human-readable format.
sms_read_pretty() {
  local msg_id="$1"
  local payload

  if ! payload="$(sms_read_details_json "$msg_id")"
  then
    return 1
  fi

  local color_reset color_white color_cyan color_blue color_green color_yellow color_red color_magenta
  local color_type_green color_type_blue color_type_magenta
  color_reset="$(ansi_escape "$COLOR_RESET")"
  color_white="$(ansi_escape "$COLOR_BOLD_WHITE")"
  color_cyan="$(ansi_escape "$COLOR_CYAN")"
  color_blue="$(ansi_escape "$COLOR_BOLD_BLUE")"
  color_green="$(ansi_escape "$COLOR_BOLD_GREEN")"
  color_yellow="$(ansi_escape "$COLOR_BOLD_YELLOW")"
  color_red="$(ansi_escape "$COLOR_BOLD_RED")"
  color_magenta="$(ansi_escape "$COLOR_BOLD_MAGENTA")"
  color_type_green="$color_green"
  color_type_blue="$color_blue"
  color_type_magenta="$color_magenta"

  jq -r \
    --arg reset "$color_reset" \
    --arg white "$color_white" \
    --arg cyan "$color_cyan" \
    --arg blue "$color_blue" \
    --arg green "$color_green" \
    --arg yellow "$color_yellow" \
    --arg red "$color_red" \
    --arg magenta "$color_magenta" \
    --arg type_green "$color_type_green" \
    --arg type_blue "$color_type_blue" \
    --arg type_magenta "$color_type_magenta" \
    --arg msg_id "$msg_id" \
    'def color($code; $text):
       if $code == "" then $text else $code + $text + $reset end;

     def ucfirst:
       if . == null or . == "" then ""
       else (.[:1] | ascii_upcase) + (.[1:] // "") end;

     def choose_type_color($type):
       if $type == null then $cyan
       else
         ($type | ascii_downcase) as $t
         | if $t == "received" then $type_green
           elif $t == "sent" then $type_blue
           elif ($t == "report" or $t == "status-report") then $type_magenta
           else $cyan end
       end;

     def choose_state_color($state):
       if $state == null then $cyan
       else
         ($state | ascii_downcase) as $s
         | if ["received","read","sent","delivered","delivery-success","complete","completed","stored","stored-received","stored-sent"] | index($s) then $green
           elif ["queued","pending","sending","temporary","unknown","new","waiting","draft"] | index($s) then $yellow
           elif ["failed","error","rejected","aborted","cancelled","timeout","unsent","not-sent","undelivered"] | index($s) then $red
           else $cyan end
       end;

     def format_value($v):
       if $v == null or $v == "" then "--" else $v end;

     def highlight_own($number; $own):
       if $number == null then "--"
       elif $own != null and $number == $own then $number + "*"
       else $number end;

     def summarize_data($data):
       if $data == null then null
       else
         ($data | tostring) as $d
         | (if ($d | length) > 64 then $d[0:61] + "â€¦" else $d end) as $trim
         | if ($d | test("^[0-9A-Fa-f]+$")) then
             ( ($d | length) / 2 | floor | tostring) + " bytes (" + $trim + ")"
           else $trim end
       end;

      def split_lines($value):
        ($value // "--") | tostring | split("\n");

      def spaces($n):
        if $n <= 0 then ""
        else [range(0; $n) | " "] | add
        end;

      def format_label($label; $width):
        ($label // "") as $l
        | ($width - ($l | length)) as $pad
        | if $pad <= 0 then $l else $l + spaces($pad) end;

      def format_lines($label; $color; $lines; $width):
        if ($lines | length) == 0 then [""]
        else
          [format_label($label; $width) + "  " + color($color; $lines[0])]
          + ($lines[1:] | map(format_label(""; $width) + "  " + color($color; .)))
        end;

      def add_row($rows; $label; $color; $value):
        $rows + [{label:$label, color:$color, value:$value}];

      def add_optional_row($rows; $label; $color; $value):
        if $value == null or $value == "" then $rows else add_row($rows; $label; $color; $value) end;

     . as $sms
     | ($sms.id // ($sms.raw_id // $msg_id)) as $id_label
     | ($sms.modem_label // ($sms.raw_modem_id // "unknown")) as $modem_label
     | ($sms.type // "unknown") as $type_label
     | ($type_label | tostring | ascii_downcase | ucfirst) as $type_title
     | ($sms.direction // "") as $direction
     | ($sms.state // "unknown") as $state_label
     | ($sms.storage // null) as $storage_raw
     | (if $storage_raw == null or $storage_raw == "" then "unknown" else $storage_raw end) as $storage_label
     | ($sms.timestamp // "--") as $timestamp_label
     | ($sms.discharge_timestamp // null) as $discharge
     | ($sms.delivery // null) as $delivery
     | ($delivery | if . == null then null else (.state // null) end) as $delivery_state
     | ($delivery | if . == null then null else (.report // null) end) as $delivery_report
     | (if $delivery == null then null
        else
          if $delivery_state != null and $delivery_report != null then $delivery_state + " (" + $delivery_report + ")"
          elif $delivery_state != null then $delivery_state
          elif $delivery_report != null then $delivery_report
          else null end
        end) as $delivery_label
     | ($sms.own_number // null) as $own
     | ($sms.remote_number // null) as $remote
     | ($sms.local_number // null) as $local
     | ($sms.remote_label // "Number") as $remote_label
     | ($sms.local_label // "Own") as $local_label
     | summarize_data($sms.data) as $data_summary
     | ($sms.text // "*no text*") as $message
     | (if $direction == null or $direction == "" or $direction == "unknown" then $type_title else $type_title + " (" + $direction + ")" end) as $type_display
     | ( []
         | add_row(.; "SMS ID"; $white; ($id_label | tostring))
         | add_row(.; "Modem"; $blue; ($modem_label | tostring))
         | add_row(.; "Type"; choose_type_color($sms.type); $type_display)
         | add_row(.; "State"; choose_state_color($sms.state); $state_label)
         | add_row(.; "Storage"; $cyan; $storage_label)
         | add_row(.; "Timestamp"; $cyan; $timestamp_label)
         | add_optional_row(.; "Discharged"; $cyan; $discharge)
         | add_optional_row(.; "Delivery"; choose_state_color($delivery_state); $delivery_label)
         | . + [null]
         | add_row(.; $remote_label; $blue; highlight_own($remote; $own))
         | add_row(.; $local_label; $blue; highlight_own($local; $own))
         | add_row(.; "SMSC"; $blue; format_value($sms.smsc))
         | add_optional_row(.; "Class"; $cyan; ($sms.class | tostring))
         | add_optional_row(.; "Encoding"; $cyan; $sms.encoding)
         | add_optional_row(.; "PDU"; $cyan; $sms.pdu)
         | add_optional_row(.; "Data"; $cyan; $data_summary)
         | . + [null]
         | add_row(.; "Message"; ""; $message)
         | . + [null]
       ) as $rows
     | ($rows | map(select(. != null) | .label | length) | max // 0) as $width
     | $rows
     | map(
           if . == null then [""]
           else
             (.label // "") as $label
             | (.color // "") as $color
             | split_lines(.value) as $lines
             | format_lines($label; $color; $lines; $width)
           end
         )
     | (add // [])
       | .[]
    ' <<<"$payload"
}

# Output the JSON payload produced by sms_read_details_json.
sms_read_json() {
  local msg_id="$1"
  local payload

  if ! payload="$(sms_read_details_json "$msg_id")"
  then
    return 1
  fi

  printf '%s\n' "$payload"
}


# Send an SMS, handling defaults, validation, and optional chunking.
sms_send() {
  local recipient=""
  local text=""
  local recipient_was_default=0

  # Parse args: allow default recipient when not specified
  if (( $# >= 1 ))
  then
    if [[ "$1" == "-" ]]
    then
      shift
    elif [[ "$1" == +* || "$1" =~ ^[0-9]+$ ]]
    then
      recipient="$1"
      shift
    fi
  fi

  if (( $# == 0 ))
  then
    if [[ -t 0 ]]
    then
      echo_error "no SMS text provided"
      return 2
    fi
    text="$(cat)"
  elif [[ "$1" == "-" ]]
  then
    shift
    text="$(cat)"
  else
    text="$*"
  fi

  if [[ -z "$recipient" ]]
  then
    # Try to load defaults from config when sending without explicit recipient
    # shellcheck disable=SC2031
    recipient="$(resolve_default_recipient "$MODEM")"
    if [[ -z "$recipient" ]]
    then
      echo_error "no recipient specified and no DEFAULT_RECIPIENT configured for this modem/country"
      return 2
    fi
    recipient_was_default=1
  fi

  recipient="${recipient//[[:space:]]/}"
  recipient="$(ensure_plus "$recipient")"

  SMS_LAST_RECIPIENT="$recipient"
  SMS_LAST_RECIPIENT_FROM_DEFAULT="$recipient_was_default"

  # Enforce local-only sending unless --allow-foreign is set
  if [[ -z "$ALLOW_FOREIGN" ]]
  then
    local home_cc
    # shellcheck disable=SC2031
    home_cc="$(get_home_cc "$MODEM")"
    if [[ -n "$home_cc" && "$recipient" == +([0-9]) ]]
    then
      if [[ "$recipient" != +"$home_cc"* ]]
      then
        echo_warning "blocking foreign recipient $recipient (home CC=$home_cc); use --allow-foreign to override or set HOME_CC"
        return 1
      fi
    fi
  fi

  if [[ -z "$text" ]]
  then
    echo_error "no SMS text provided"
    return 2
  fi

  # Expand common escapes and strip trailing whitespace to avoid stray spaces
  text="$(printf '%b' "$text" | sed -e 's/[[:space:]]\+$//')"

  local chunk_size
  if [[ -n "$SMS_CHUNK_SIZE" ]]
  then
    if [[ "$SMS_CHUNK_SIZE" =~ ^[0-9]+$ ]] && (( SMS_CHUNK_SIZE > 0 ))
    then
      chunk_size="$SMS_CHUNK_SIZE"
    else
      echo_error "invalid chunk size '$SMS_CHUNK_SIZE', expected positive integer"
      return 2
    fi
  fi

  local -a send_chunks=("$text")
  if [[ -n "$chunk_size" ]]
  then
    send_chunks=()
    local text_remaining="$text"
    while [[ -n "$text_remaining" ]]
    do
      local remaining_len=${#text_remaining}
      if (( remaining_len <= chunk_size ))
      then
        send_chunks+=("$text_remaining")
        break
      fi

      local chunk="${text_remaining:0:chunk_size}"
      local cut_length="$chunk_size"
      local break_pos=-1
      local i

      for (( i=cut_length-1; i>=0; i-- ))
      do
        local char="${chunk:i:1}"
        if [[ "$char" =~ [[:space:]] ]]
        then
          break_pos=$i
          break
        fi
      done

      if (( break_pos >= 0 ))
      then
        cut_length=$((break_pos + 1))
      elif [[ "${text_remaining:chunk_size:1}" =~ [[:space:]] ]]
      then
        cut_length=$((chunk_size + 1))
      fi

      while (( cut_length < remaining_len )) && [[ "${text_remaining:cut_length:1}" =~ [[:space:]] ]]
      do
        cut_length=$((cut_length + 1))
      done

      send_chunks+=( "${text_remaining:0:cut_length}" )
      text_remaining="${text_remaining:cut_length}"
    done
  fi

  local total_chunks=${#send_chunks[@]}
  local chunk_index=1
  local chunk_rc=0

  for chunk_text in "${send_chunks[@]}"
  do
    sms_send_chunk_text "$recipient" "$chunk_text" "$chunk_index" "$total_chunks" "$chunk_size"
    chunk_rc=$?
    if (( chunk_rc != 0 ))
    then
      return $chunk_rc
    fi
    chunk_index=$((chunk_index + 1))
  done

  return 0
}

# Send a single SMS chunk with retries and logging.
sms_send_chunk_text() {
  local recipient="$1"
  local text="$2"
  local chunk_index="${3:-1}"
  local chunk_total="${4:-1}"
  local chunk_size="${5:-}"

  local chunk_label=""
  if (( chunk_total > 1 ))
  then
    chunk_label=" chunk ${chunk_index}/${chunk_total}"
  fi

  local chunk_size_note=""
  if (( chunk_total > 1 )) && [[ -n "$chunk_size" ]]
  then
    chunk_size_note=" (chunk-size=$chunk_size)"
  fi

  # Log outgoing SMS (preview) to stderr and syslog
  local log_text
  log_text="$(abbrev_text_for_log "$text")"
  local log_modem
  log_modem="$(modem_info_brief)"
  echo_info "sending sms${chunk_label}${chunk_size_note} with modem={$log_modem} recipient='$recipient' text='$log_text'"

  local tmpfile
  if ! tmpfile="$(mktemp "${TMPDIR:-/tmp}/mmsms-text.XXXXXX")"
  then
    echo_error "failed to create temporary file for SMS text${chunk_label}"
    return 1
  fi

  if ! printf '%s' "$text" >"$tmpfile"
  then
    rm -f "$tmpfile"
    echo_error "failed to write SMS text to temporary file${chunk_label}"
    return 1
  fi

  local sms_id
  local smsc_params

  local smsc_raw
  smsc_raw="$(get_smsc_number)"

  local smsc
  if [[ -n "$smsc_raw" ]]
  then
    smsc="${smsc_raw//[[:space:]]/}"

    if [[ -n "$smsc" && "$smsc" != +* ]]
    then
      smsc="+$smsc"
    fi

    if [[ -n "$smsc" && "$smsc" =~ ^\+[0-9]+$ ]]
    then
      smsc_params=",smsc=$smsc"
    elif [[ -n "$smsc_raw" ]]
    then
      echo_warning "invalid smsc '$smsc_raw', skipping"
      smsc=""
    fi
  fi

  local create_attempt=1
  local max_attempts=$SMS_RETRY_COUNT
  local rc=1

  # Create the SMS first (retrying creation only if creation itself fails)
  if (( max_attempts < 1 ))
  then
    max_attempts=1
  fi

  local create_json
  while (( create_attempt <= max_attempts ))
  do
    sms_id=""
    if ! create_json="$(mmcli_cmd -J --messaging-create-sms="number=${recipient}${smsc_params}" \
      --messaging-create-sms-with-text="$tmpfile")"
    then
      if (( create_attempt >= max_attempts ))
      then
        echo_error "failed to create SMS${chunk_label} after $max_attempts attempts"
        rm -f "$tmpfile"
        return 1
      fi

      echo_warning "failed to create SMS${chunk_label} (attempt $create_attempt/$max_attempts), retrying"
      create_attempt=$((create_attempt + 1))
      continue
    fi

    if ! sms_id="$(jq -er '.modem.messaging["created-sms"] // empty' <<<"$create_json")"
    then
      if (( create_attempt == max_attempts ))
      then
        echo_error "failed to create SMS${chunk_label} after $max_attempts attempts"
        rm -f "$tmpfile"
        return 1
      fi

      echo_warning "received empty SMS id${chunk_label} (attempt $create_attempt/$max_attempts), retrying"
      create_attempt=$((create_attempt + 1))
      continue
    fi
    break
  done

  # Now retry only the send step for the created SMS id
  local send_attempt=1
  if (( max_attempts < 1 ))
  then
    max_attempts=1
  fi

  while (( send_attempt <= max_attempts ))
  do
    if mmcli_cmd --sms "$sms_id" --send --timeout="$SMS_SEND_TIMEOUT"
    then
      rc=0
      echo_success "message '${sms_id}' sent with modem={${log_modem}} recipient='$recipient'${chunk_label}"
      break
    fi

    if (( send_attempt >= max_attempts ))
    then
      echo_error "failed to send SMS '${sms_id}'${chunk_label} after $max_attempts attempts"
      break
    fi

    echo_warning "failed to send SMS '${sms_id}'${chunk_label} (attempt $send_attempt/$max_attempts), retrying"
    send_attempt=$((send_attempt + 1))
  done

  # direct send failure logs use echo_warning at call site; SYSLOG_MIRROR handles mirroring

  rm -f "$tmpfile"
  return $rc
}

# Determine if a recipient is allowed for a given modem id based on
# --allow-foreign/HOME_CC. Returns 0 if allowed, 1 if blocked.
recipient_allowed_for_modem() {
  local recipient="$1"
  local mid="$2"

  if [[ -n "$ALLOW_FOREIGN" ]]
  then
    return 0
  fi

  local hcc
  hcc="$(get_home_cc "$mid")"

  if [[ -z "$hcc" ]]
  then
    echo_warning "Failed to determine home CC for modem id '$mid', blocking foreign recipient '$recipient'"
    return 1
  fi

  recipient=$(ensure_plus "$recipient")
  if [[ "$recipient" == +"$hcc"* ]]
  then
    return 0
  fi

  return 1
}

# Retry sending an SMS on alternate modems when fallback is enabled.
sms_send_with_fallback() {
  local orig_args=("$@")
  local args=("$@")
  local recipient
  local text

  # First attempt with the original arguments
  if sms_send "${orig_args[@]}"
  then
    return 0
  fi

  if [[ -z "$FALLBACK" ]]
  then
    return 1
  fi

  # Parse optional recipient from arguments
  if (( ${#args[@]} > 0 ))
  then
    case "${args[0]}" in
      -)
        args=("${args[@]:1}")
        ;;
      +*|[0-9]*)
        recipient="${args[0]}"
        args=("${args[@]:1}")
        ;;
    esac
  fi

  if (( ${#args[@]} > 0 )) && [[ "${args[0]}" == "-" ]]
  then
    args=("${args[@]:1}")
  fi

  if (( ${#args[@]} > 0 ))
  then
    text="${args[*]}"
  fi

  if [[ -z "$text" ]]
  then
    echo_warning "fallback: message text unavailable for resend"
    return 1
  fi

  local resolved_recipient="${SMS_LAST_RECIPIENT:-$recipient}"
  local orig_recipient_default_flag="${SMS_LAST_RECIPIENT_FROM_DEFAULT:-0}"
  recipient="$resolved_recipient"

  # Gather other modems
  local cur_id="$MODEM"

  if [[ "$cur_id" == "any" ]]
  then
    local _j
    if _j="$(mmcli_cmd -J)"
    then
      cur_id="$(jq -r '.modem["dbus-path"] | split("/")[-1] // empty' <<<"$_j")"
    fi
  fi

  local mids
  if ! mapfile -t mids < <(list_modem_ids_sorted)
  then
    return 1
  fi

  local mid
  for mid in "${mids[@]}"
  do
    [[ -z "$mid" || "$mid" == "$cur_id" ]] && continue
    local prev_mode="$MODEM"
    MODEM="$mid"
    local candidate_recipient="$recipient"
    local used_auto
    local auto_tried=0

    if ! recipient_allowed_for_modem "$candidate_recipient" "$mid"
    then
      if [[ -n "$AUTO_RECIPIENT" && "$orig_recipient_default_flag" == "1" ]]
      then
        auto_tried=1
        local auto_recipient
        if auto_recipient="$(resolve_default_recipient "$mid")"
        then
          auto_recipient="${auto_recipient//[[:space:]]/}"
          auto_recipient="$(ensure_plus "$auto_recipient")"
        else
          auto_recipient=""
        fi

        if [[ -n "$auto_recipient" ]] && ! recipient_allowed_for_modem "$auto_recipient" "$mid"
        then
          auto_recipient=""
        fi

        if [[ -n "$auto_recipient" ]]
        then
          candidate_recipient="$auto_recipient"
          used_auto=1
        fi
      fi

      if [[ -z "$used_auto" ]]
      then
        local info
        info="$(modem_info_brief)"
        if [[ "$auto_tried" == 1 ]]
        then
          echo_warning "fallback: modem=$info has no eligible default recipient (auto-recipient unavailable)"
        else
          echo_warning "fallback: cannot use modem=$info for recipient $recipient (foreign not allowed; use --allow-foreign)"
        fi
        MODEM="$prev_mode"
        continue
      fi
    fi

    if [[ -n "$used_auto" ]]
    then
      local info
      info="$(modem_info_brief)"
      echo_info "fallback: using modem=$info default_recipient='$candidate_recipient'"
    fi

    echo_debug "fallback: sending text='$text'"
    echo_debug "fallback: trying modem $mid"

    if sms_send "$candidate_recipient" "$text"
    then
      local info
      info="$(modem_info_brief)"
      MODEM="$prev_mode"

      echo_info "fallback send succeeded using modem=$info"
      return 0
    fi
    MODEM="$prev_mode"
  done

  echo_warning "fallback: no eligible modem could send the message"
  return 1
}

# Delete all SMS messages on the currently selected modem.
sms_prune_all() {
  local ids
  mapfile -t ids < <(mmcli_cmd --messaging-list-sms -J | \
    jq -r '."modem.messaging.sms"[]? | split("/")[-1]' | sort -n)

  local total=${#ids[@]}
  if (( total == 0 ))
  then
    return 0
  fi

  local i=0 sms_id
  for sms_id in "${ids[@]}"
  do
    [[ -z "$sms_id" ]] && continue
    i=$((i + 1))
    echo_info "deleting SMS $sms_id ($i/$total)"
    if ! mmcli_cmd --messaging-delete-sms="$sms_id"
    then
      echo_error "failed to delete SMS $sms_id"
    fi
  done
}

# Delete sent outgoing SMS messages on the current modem.
sms_prune_sent() {
  # Delete only messages that are outgoing and already sent
  local list ids id js state pdu sent_ids=()

  if ! list="$(mmcli_cmd --messaging-list-sms -J)"
  then
    return 0
  fi

  mapfile -t ids < <(jq -r '
    ."modem.messaging.sms"[]? | split("/")[-1]
  ' <<<"$list" | sort -n)

  if (( ${#ids[@]} == 0 ))
  then
    return 0
  fi

  # First collect sent IDs
  for id in "${ids[@]}"
  do
    [[ -z "$id" ]] && continue
    if ! js="$(mmcli_cmd --sms "$id" -J)"
    then
      echo_warning "failed to read SMS $id, skipping"
      continue
    fi
    state="$(jq -r '.sms.properties.state // empty' <<<"$js")"
    pdu="$(jq -r '.sms.properties["pdu-type"] // empty' <<<"$js")"
    if [[ "$state" == "sent" && "$pdu" == "submit" ]]
    then
      sent_ids+=("$id")
    fi
  done

  local total=${#sent_ids[@]}
  if (( total == 0 ))
  then
    return 0
  fi

  local i=0
  for id in "${sent_ids[@]}"
  do
    i=$((i + 1))
    echo_info "deleting sent SMS $id ($i/$total)"
    mmcli_cmd --messaging-delete-sms="$id"
  done
}

# Delete sent SMS messages across all detected modems.
sms_prune_sent_modems() {
  local mids mid

  if ! mapfile -t mids < <(list_modem_ids_sorted)
  then
    echo_error "failed to list modems for pruning"
    return 1
  fi

  if (( ${#mids[@]} == 0 ))
  then
    echo_info "no modems detected"
    return 0
  fi

  for mid in "${mids[@]}"
  do
    [[ -z "$mid" ]] && continue
    echo_info "pruning sent messages on modem $mid"
    MODEM=$mid sms_prune_sent || echo_error "failed to prune sent messages on modem $mid"
  done
}

# Delete all SMS messages across all detected modems.
sms_prune_all_modems() {
  local mids mid
  if ! mapfile -t mids < <(list_modem_ids_sorted)
  then
    echo_error "failed to list modems for pruning"
    return 1
  fi

  if (( ${#mids[@]} == 0 ))
  then
    echo_info "no modems detected"
    return 0
  fi

  for mid in "${mids[@]}"
  do
    [[ -z "$mid" ]] && continue
    echo_info "pruning modem $mid"
    MODEM="$mid" sms_prune_all || echo_error "failed to prune on modem $mid"
  done
}

# Print the header row for SMS listing output.
sms_list_print_header() {
  local include_mid=""
  local header

  while (( $# > 0 ))
  do
    case "$1" in
      --include-modem-id)
        include_mid=1
        shift
        ;;
      *)
        echo_error "sms_list_print_header: unknown option '$1'"
        return 2
        ;;
    esac
  done

  if [[ -n "$include_mid" ]]
  then
    header="$(printf '%-4s %-4s %-10s %-18s %s' 'MID' 'ID' 'TYPE' 'RECIPIENT' 'MSG')"
  else
    header="$(printf '%-4s %-10s %-18s %s' 'ID' 'TYPE' 'RECIPIENT' 'MSG')"
  fi

  if [[ -n "$NO_COLOR" || -n "$CRON" ]]
  then
    printf '%s\n' "$header"
  else
    printf '\e[1m%s\e[0m\n' "$header"
  fi
}

# Print a formatted table row for a single SMS entry.
sms_list_print_entry() {
  local mid="$1"
  local id="$2"
  local js="$3"
  shift 3

  local include_mid=""
  local maxlen=80
  local sender text msg_type pdu

  while (( $# > 0 ))
  do
    case "$1" in
      --include-modem-id)
        include_mid=1
        shift
        ;;
      --max-length)
        if (( $# < 2 ))
        then
          echo_error "sms_list_print_entry: missing value for --max-length"
          return 2
        fi
        if [[ ! "$2" =~ ^[0-9]+$ ]]
        then
          echo_error "sms_list_print_entry: --max-length requires a non-negative integer"
          return 2
        fi
        maxlen="$2"
        shift 2
        ;;
      --max-length=*)
        local value
        value="${1#*=}"
        if [[ -z "$value" ]]
        then
          echo_error "sms_list_print_entry: missing value for --max-length"
          return 2
        fi
        if [[ ! "$value" =~ ^[0-9]+$ ]]
        then
          echo_error "sms_list_print_entry: --max-length requires a non-negative integer"
          return 2
        fi
        maxlen="$value"
        shift
        ;;
      *)
        echo_error "sms_list_print_entry: unknown option '$1'"
        return 2
        ;;
    esac
  done

  sender="$(jq -r '.sms.content.number // "--"' <<<"$js")"
  sender="$(ensure_plus "$sender")"
  pdu="$(jq -r '.sms.properties["pdu-type"] // ""' <<<"$js")"
  msg_type="$(pdu_to_type "$pdu")"
  text="$(jq -r '.sms.content.text // ""' <<<"$js")"
  text=${text//$'\r'/}
  text=${text//$'\n'/\\n}
  if (( ${#text} > maxlen ))
  then
    text="${text:0:maxlen}â€¦"
  fi

  if [[ -n "$include_mid" ]]
  then
    printf '%-4s %-4s %-10s %-18s %s\n' "$mid" "$id" "$msg_type" "$sender" "$text"
  else
    printf '%-4s %-10s %-18s %s\n' "$id" "$msg_type" "$sender" "$text"
  fi
}

# List SMS messages respecting the selected output mode and scope.
sms_list_pretty() {
  local list_json ids id js sender text msg_type pdu line maxlen=80

  # When listing for all modems, iterate them explicitly
  if [[ -n "$ALL_MODEMS" ]]
  then
    local mids mid had_any=""
    if ! mapfile -t mids < <(list_modem_ids_sorted)
    then
      echo_error "failed to list modems"
      return 1
    fi

    if (( ${#mids[@]} == 0 ))
    then
      if json_like_requested
      then
        printf '[]\n'
      else
        echo "no messages"
      fi

      return 0
    fi

    if [[ -z "$MODEM_DETAILS_LOGGED" ]]
    then
      echo_info "modems in scope:"
      for mid in "${mids[@]}"
      do
        [[ -z "$mid" ]] && continue
        log_modem_details "$mid"
      done
      MODEM_DETAILS_LOGGED=1
    fi

    if raw_json_requested
    then
        local raw_items
        raw_items="$(
          for mid in "${mids[@]}"
          do
            [[ -z "$mid" ]] && continue

            if ! list_json="$(mmcli --modem "$mid" --messaging-list-sms -J)"
            then
              continue
            fi

            mapfile -t ids < <(jq -r '."modem.messaging.sms"[]? | split("/")[-1]' <<<"$list_json")

            for id in "${ids[@]}"
            do
              [[ -z "$id" ]] && continue
              js="$(mmcli --modem "$mid" --sms "$id" -J)"

              if [[ -n "$js" ]]
              then
                jq -e -c --arg mid "$mid" '{modem_id: ($mid|tonumber), sms: .}' <<<"$js"
              fi
            done
          done
        )"
        if [[ -z "$raw_items" ]]
        then
          printf '[]\n'
        else
          printf '%s\n' "$raw_items" | jq -s '.'
        fi
        return 0
    elif raw_plain_requested
    then
        local first=1 out
        for mid in "${mids[@]}"
        do
          [[ -z "$mid" ]] && continue
          out="$(mmcli --modem "$mid" --messaging-list-sms 2>&1)"
          if [[ -z "$out" ]]
          then
            continue
          fi
          if (( ! first ))
          then
            printf '\n'
          fi
          first=0
          printf '%s' "$out"
          [[ "$out" == *$'\n' ]] || printf '\n'
        done
        return 0
    fi

    if custom_json_requested
    then
      local -a json_items=()
      local mid own info_json

      for mid in "${mids[@]}"
      do
        [[ -z "$mid" ]] && continue

        if ! list_json="$(mmcli --modem "$mid" --messaging-list-sms -J)"
        then
          continue
        fi

        mapfile -t ids < <(jq -r '."modem.messaging.sms"[]? | split("/")[-1]' <<<"$list_json")
        (( ${#ids[@]} == 0 )) && continue

        own=""
        if info_json="$(mmcli --modem "$mid" -J)"
        then
          own="$(jq -r '(.modem.generic["own-numbers"][0] // empty)' <<<"$info_json")"
          own=$(ensure_plus "$own")
        fi

        for id in "${ids[@]}"
        do
          [[ -z "$id" ]] && continue
          if ! js="$(mmcli --modem "$mid" --sms "$id" -J)"
          then
            continue
          fi
          pdu="$(jq -r '.sms.properties["pdu-type"] // ""' <<<"$js")"
          msg_type="$(pdu_to_type "$pdu")"
          local json_item=""
          json_item="$(jq -c \
            --arg mid "$mid" \
            --arg id "$id" \
            --arg type "$msg_type" \
            --arg own "$own" '
              {
                modem_id: ($mid|tonumber),
                id: ($id|tonumber),
                sender: (.sms.content.number // ""),
                text: (.sms.content.text // ""),
                class: (.sms.content.class // ""),
                state: (.sms.properties.state // ""),
                pdu: (.sms.properties["pdu-type"] // ""),
                storage: (.sms.properties.storage // ""),
                type: $type,
                recipient: (if $type == "received" then $own else (.sms.content.number // "") end)
              }
            ' <<<"$js")"
          if [[ -n "$json_item" && "$json_item" != "null" ]]
          then
            json_items+=("$json_item")
          fi
        done
      done

      if (( ${#json_items[@]} == 0 ))
      then
        printf '[]\n'
      else
        printf '%s\n' "${json_items[@]}" | jq -s '.'
      fi

      return 0
    fi

    # Pretty output across all modems: add a MID column
    sms_list_print_header --include-modem-id

    for mid in "${mids[@]}"
    do
      [[ -z "$mid" ]] && continue

      if ! list_json="$(mmcli --modem "$mid" --messaging-list-sms -J)"
      then
        continue
      fi

      mapfile -t ids < <(jq -r '."modem.messaging.sms"[]? | split("/")[-1]' <<<"$list_json")
      for id in "${ids[@]}"
      do
        [[ -z "$id" ]] && continue
        if ! js="$(mmcli --modem "$mid" --sms "$id" -J)"
        then
          continue
        fi
        sms_list_print_entry "$mid" "$id" "$js" --include-modem-id --max-length "$maxlen"
        had_any=1
      done
    done
    [[ -n "$had_any" ]] || echo "*no messages*"
    return 0
  fi

  if raw_plain_requested
  then
    mmcli_cmd --messaging-list-sms
    return $?
  fi

  if ! list_json="$(mmcli_cmd --messaging-list-sms -J)"
  then
    echo_error "failed to list SMS messages"
    return 1
  fi

  mapfile -t ids < <(jq -r '."modem.messaging.sms"[]? | split("/")[-1]' <<<"$list_json")
  if (( ${#ids[@]} == 0 ))
  then
    if json_like_requested
    then
      printf '[]\n'
    else
      echo "*no messages*"
    fi
    return 0
  fi

  if raw_json_requested
  then
    if ! jq <<<"$list_json"
    then
      return 1
    fi
    return 0
  fi

  if custom_json_requested
  then
    # Emit one compact JSON object per SMS, then wrap into an array
    # Determine our own number for recipient mapping of received messages
    local own=""
    if load_own_number
    then
      own="$OWN_NUMBER"
    fi
    {
      for id in "${ids[@]}"
      do
        [[ -z "$id" ]] && continue
        if ! js="$(mmcli_cmd --sms "$id" -J)"
        then
          continue
        fi
        pdu="$(jq -r '.sms.properties["pdu-type"] // ""' <<<"$js")"
        msg_type="$(pdu_to_type "$pdu")"
        jq -c --arg id "$id" --arg type "$msg_type" --arg own "$own" '
          {
            id: ($id|tonumber),
            sender: (.sms.content.number // ""),
            text: (.sms.content.text // ""),
            class: (.sms.content.class // ""),
            state: (.sms.properties.state // ""),
            pdu: (.sms.properties["pdu-type"] // ""),
            storage: (.sms.properties.storage // ""),
            type: $type,
            recipient: (if $type == "received" then $own else (.sms.content.number // "") end)
          }
        ' <<<"$js"
      done
    } | jq -s '.'
    return 0
  fi

  # Header for human-readable list (make entire line bold to preserve alignment)
  sms_list_print_header

  for id in "${ids[@]}"
  do
    [[ -z "$id" ]] && continue
    if ! js="$(mmcli_cmd --sms "$id" -J)"
    then
      continue
    fi
    sms_list_print_entry "" "$id" "$js" --max-length "$maxlen"
  done
}

# Resolve and enable a modem, optionally waiting for it to appear.
enable_modem() {
  local selector_input="${1:-}"
  local selector="$selector_input"
  local wait_enabled="${ENABLE_WAIT_MODEM:-}"
  local wait_timeout="${ENABLE_WAIT_TIMEOUT:-0}"
  local wait_timeout_default="$ENABLE_WAIT_TIMEOUT_DEFAULT"
  local sleep_period="$ENABLE_WAIT_SLEEP_INTERVAL"
  local service_wait_timeout=600
  local elapsed=0

  if [[ -z "$selector" ]]
  then
    selector="$MODEM"
  fi
  if [[ -z "$selector" ]]
  then
    selector="any"
  fi

  echo_info "waiting for D-Bus system socket"
  until [[ -S /var/run/dbus/system_bus_socket ]]
  do
    if (( elapsed >= service_wait_timeout ))
    then
      echo_warning "timeout waiting for D-Bus socket"
      return 1
    fi

    sleep "$sleep_period"
    elapsed=$((elapsed + sleep_period))
  done

  echo_info "waiting for ModemManager"
  elapsed=0
  until mmcli -L >/dev/null 2>&1
  do
    if (( elapsed >= service_wait_timeout ))
    then
      echo_warning "timeout waiting for ModemManager"
      return 1
    fi

    sleep "$sleep_period"
    elapsed=$((elapsed + sleep_period))
  done

  local detection_timeout=0
  if [[ -n "$wait_enabled" ]]
  then
    if [[ ! "$wait_timeout" =~ ^[0-9]+$ ]] || (( wait_timeout <= 0 ))
    then
      wait_timeout="$wait_timeout_default"
    fi
    detection_timeout="$wait_timeout"
  fi

  if [[ -n "$wait_enabled" ]]
  then
    echo_info "waiting for modem detection"
  else
    echo_info "checking for modem detection"
  fi

  local detection_elapsed=0
  local resolved_id
  local resolve_output
  local resolve_status=0
  local last_error
  local last_error_is_custom
  local selector_is_any

  if [[ "$selector" == "any" ]]
  then
    selector_is_any=1
  fi

  local -a any_ids=()
  while :
  do
    if [[ -n "$selector_is_any" ]]
    then
      if mapfile -t any_ids < <(list_modem_ids_sorted)
      then
        if (( ${#any_ids[@]} > 0 ))
        then
          resolved_id="any"
          resolve_status=0
          break
        fi
        last_error="no modems detected"
        last_error_is_custom=1
        resolve_status=1
      else
        last_error="could not query modem list via mmcli"
        last_error_is_custom=1
        resolve_status=1
      fi
    else
      resolve_output="$(get_modem_id "$selector" 2>&1)"
      resolve_status=$?
      if (( resolve_status == 0 ))
      then
        resolved_id="$(trim "$resolve_output")"
        break
      fi
      last_error="$resolve_output"
      last_error_is_custom=""
    fi

    if (( resolve_status == 2 )) || [[ -z "$wait_enabled" ]]
    then
      if [[ -n "$last_error_is_custom" ]]
      then
        echo_error "$last_error"
      else
        [[ -n "$last_error" ]] && printf '%s\n' "$last_error" >&2
      fi
      return "$resolve_status"
    fi

    if (( detection_timeout > 0 )) && (( detection_elapsed >= detection_timeout ))
    then
      if [[ -n "$last_error_is_custom" ]]
      then
        echo_error "$last_error"
      else
        [[ -n "$last_error" ]] && printf '%s\n' "$last_error" >&2
      fi
      echo_warning "timeout waiting for modem detection of '$selector'"
      return 1
    fi

    sleep "$sleep_period"
    detection_elapsed=$((detection_elapsed + sleep_period))
  done

  if [[ -z "$resolved_id" ]]
  then
    echo_warning "failed to resolve modem selector '$selector'"
    return 1
  fi

  MODEM="$resolved_id"

  if [[ "$MODEM" == "any" ]]
  then
    local _j _id
    if _j="$(mmcli_cmd -J)"
    then
      _id="$(jq -r '.modem["dbus-path"] | split("/")[-1] // empty' <<<"$_j")"
      if [[ -n "$_id" ]]
      then
        MODEM="$_id"
      fi
    fi
  fi

  local enable_target="$MODEM"

  if [[ -z "$QUIET" ]]
  then
    local _info
    if _info="$(get_modem_info "$enable_target" "detected ")"
    then
      echo_info "$_info"
    else
      echo_info "resolved modem selector '$selector' to '$enable_target'"
    fi
    MODEM_DETAILS_LOGGED=1
  fi

  if mmcli_cmd --enable
  then
    echo_info "modem enabled"
    # Log enabled modem details similar to selection log
    if [[ -z $QUIET ]]
    then
      local _json _formatted
      if _json="$(get_modem "$enable_target")"
      then
        configure_modem_vendor "$_json"
        if _formatted="$(modem_info_string_from_json "$_json" "$enable_target")"
        then
          echo_info "enabled modem={$_formatted}"
        else
          echo_info "enabled modem={id='${enable_target}'}"
        fi
      else
        echo_info "enabled modem={id='${enable_target}'}"
      fi
    fi
    return 0
  fi

  echo_warning "failed to enable modem"
  return 1
}

# Enable each detected modem in sequence.
enable_all_modems() {
  local mids mid
  if ! mapfile -t mids < <(list_modem_ids_sorted)
  then
    echo_error "failed to list modems to enable"
    return 1
  fi
  if (( ${#mids[@]} == 0 ))
  then
    echo_info "no modems detected"
    return 0
  fi
  local ok_count=0
  local fail_ids=()
  for mid in "${mids[@]}"
  do
    [[ -z "$mid" ]] && continue
    echo_info "enabling modem $mid"
    if ! enable_modem "$mid"
    then
      echo_warning "failed to enable modem $mid"
      fail_ids+=("$mid")
    else
      ok_count=$((ok_count + 1))
    fi
  done
  if (( ${#fail_ids[@]} > 0 ))
  then
    echo_info "enabled $ok_count/${#mids[@]} modems (failed: ${fail_ids[*]})"
  else
    echo_info "enabled $ok_count/${#mids[@]} modems"
  fi
}

# Reset the current modem with optional service restarts and USB replugging.
modem_reset() {
  local service="/etc/init.d/modemmanager"
  local has_service=""

  if [[ -x "$service" ]]
  then
    has_service=1
  else
    echo_warning "modemmanager init script not found or not executable at $service"
  fi

  local info_json="" vendor=""
  if info_json="$(mmcli_cmd -J)"
  then
    if ! vendor="$(modem_vendor_from_info_json "$info_json")"
    then
      vendor=""
    fi
    echo_debug "modem_reset: detected vendor '${vendor:-unknown}'"
  else
    echo_warning "could not query modem to determine vendor; proceeding with generic reset"
  fi

  if [[ -n "$HARD_RESET" && -n "$has_service" ]]
  then
    reset_log "stopping ModemManager"
    if ! "$service" stop
    then
      echo_error "failed to stop ModemManager service"
      return 1
    fi
  fi

  reset_modem_vendor "$info_json" "$vendor"

  if [[ -n "$USB_REPLUG" ]]
  then
    if ! modem_usb_replug "$info_json"
    then
      echo_error "USB replug failed"
      return 1
    fi
  fi

  if [[ -n "$HARD_RESET" && -n "$has_service" ]]
  then
    reset_log "starting ModemManager"
    if ! "$service" start
    then
      echo_error "failed to start ModemManager service"
      return 1
    fi
  fi

  reset_log "enabling modem"
  local prev_wait_mode="${ENABLE_WAIT_MODEM:-}"
  local prev_wait_timeout="${ENABLE_WAIT_TIMEOUT:-}"
  ENABLE_WAIT_MODEM=1
  if [[ ! "$ENABLE_WAIT_TIMEOUT" =~ ^[0-9]+$ ]] || (( ENABLE_WAIT_TIMEOUT <= 0 ))
  then
    ENABLE_WAIT_TIMEOUT="$ENABLE_WAIT_TIMEOUT_DEFAULT"
  fi
  if ! enable_modem "$MODEM"
  then
    echo_warning "failed to enable modem after reset, retrying in 5s"
    sleep 5
    if ! enable_modem "$MODEM"
    then
      ENABLE_WAIT_MODEM="$prev_wait_mode"
      ENABLE_WAIT_TIMEOUT="$prev_wait_timeout"
      echo_error "failed to enable modem after reset"
      return 1
    fi
  fi
  ENABLE_WAIT_MODEM="$prev_wait_mode"
  ENABLE_WAIT_TIMEOUT="$prev_wait_timeout"

  return 0
}

# Reset every detected modem using modem_reset.
modem_reset_all() {
  local mids mid
  if ! mapfile -t mids < <(list_modem_ids_sorted)
  then
    echo_error "failed to list modems to reset"
    return 1
  fi
  if (( ${#mids[@]} == 0 ))
  then
    echo_info "no modems detected"
    return 0
  fi
  for mid in "${mids[@]}"
  do
    [[ -z "$mid" ]] && continue
    echo_info "resetting modem $mid"
    MODEM="$mid" modem_reset || echo_error "failed to reset modem $mid"
  done
}

# Log reset operations when not running in quiet mode.
reset_log() {
  if [[ -z $QUIET ]]
  then
    echo_info "$*"
  fi
}

# Clean up watcher resources and background processes.
watch_cleanup() {
  watch_stop_workers

  if [[ -n "$WATCH_DBUS_PID" ]]
  then
    if ! kill "$WATCH_DBUS_PID"
    then
      echo_warning "could not stop dbus-monitor (pid $WATCH_DBUS_PID)"
    fi
    WATCH_DBUS_PID=""
  fi

  if [[ -n "$WATCH_MODEM_MONITOR_PID" ]]
  then
    if ! kill "$WATCH_MODEM_MONITOR_PID"
    then
      echo_warning "could not stop modem monitor (pid $WATCH_MODEM_MONITOR_PID)"
    fi
    WATCH_MODEM_MONITOR_PID=""
  fi

  if [[ -n "$WATCH_FIFO" ]]
  then
    if ! rm -f "$WATCH_FIFO"
    then
      echo_warning "could not remove fifo $WATCH_FIFO"
    fi
    WATCH_FIFO=""
  fi
}

# Return the queue key used to group watcher workers per modem.
watch_queue_key() {
  local modem_hint="$1"

  if [[ -n "$modem_hint" ]]
  then
    printf '%s' "$modem_hint"
  else
    printf '%s' "any"
  fi
}

# Create or reuse the async work directory for watcher jobs.
watch_async_dir_prepare() {
  if [[ -n "$WATCH_ASYNC_DIR" && -d "$WATCH_ASYNC_DIR" ]]
  then
    printf '%s\n' "$WATCH_ASYNC_DIR"
    return 0
  fi

  local base="${TMPDIR:-/tmp}"
  local dir

  if dir="$(mktemp -d "$base/mmsms-watch.XXXXXX")"
  then
    :
  else
    dir="$base/mmsms-watch.$$"
    if ! mkdir -p "$dir"
    then
      echo_warning "watch: failed to create async directory in $base"
      return 1
    fi
  fi

  WATCH_ASYNC_DIR="$dir"
  printf '%s\n' "$WATCH_ASYNC_DIR"
  return 0
}

# Check if a PID still corresponds to a running non-zombie process.
watch_pid_alive() {
  local pid="$1"

  if [[ -z "$pid" ]]
  then
    return 1
  fi

  local status_file="/proc/$pid/status"
  if [[ ! -r "$status_file" ]]
  then
    return 1
  fi

  local line
  while IFS= read -r line
  do
    case "$line" in
      State:*)
        [[ "$line" == *"(zombie)"* ]] && return 1
        return 0
        ;;
    esac
  done <"$status_file"

  return 0
}

# Remove the filesystem lock held by a watcher worker.
watch_worker_release_lock() {
  local lock_path="$1"

  if [[ -z "$lock_path" ]]
  then
    return
  fi

  if [[ -d "$lock_path" ]]
  then
    if ! rmdir "$lock_path"
    then
      echo_warning "watch: failed to remove lock directory $lock_path"
    fi
  fi
}

# Track a newly spawned watcher worker PID for a modem queue.
watch_worker_register() {
  local modem_key="$1"
  local pid="$2"

  if [[ -z "$modem_key" || -z "$pid" ]]
  then
    return
  fi

  local existing
  existing="${WATCH_WORKER_PIDS[$modem_key]:-}"

  if [[ -n "$existing" ]]
  then
    WATCH_WORKER_PIDS["$modem_key"]="$existing $pid"
  else
    WATCH_WORKER_PIDS["$modem_key"]="$pid"
  fi
}

# Prune exited watcher workers for a given modem queue.
watch_worker_prune_for_modem() {
  local modem_key="$1"

  local pids
  pids="${WATCH_WORKER_PIDS[$modem_key]:-}"

  if [[ -z "$pids" ]]
  then
    return
  fi

  local -a alive=()
  local pid
  for pid in $pids
  do
    if watch_pid_alive "$pid"
    then
      alive+=("$pid")
    else
      wait "$pid"
    fi
  done

  if (( ${#alive[@]} > 0 ))
  then
    WATCH_WORKER_PIDS["$modem_key"]="${alive[*]}"
  else
    unset 'WATCH_WORKER_PIDS[$modem_key]'
  fi
}

# Prune exited watcher workers for all modem queues.
watch_worker_prune_all() {
  local modem_key

  for modem_key in "${!WATCH_WORKER_PIDS[@]}"
  do
    watch_worker_prune_for_modem "$modem_key"
  done
}

# Count active watcher workers for a modem queue.
watch_worker_pending_count() {
  local modem_key="$1"

  local pids
  pids="${WATCH_WORKER_PIDS[$modem_key]:-}"

  if [[ -z "$pids" ]]
  then
    printf '%s' '0'
    return
  fi

  local -a pid_list=()
  local IFS=' '
  read -ra pid_list <<< "$pids"

  printf '%s' "${#pid_list[@]}"
}

# Spawn an asynchronous worker to handle an incoming SMS.
watch_spawn_worker() {
  local id="$1"
  local modem_hint="$2"
  local modem_key="$3"

  local dir
  if ! dir="$(watch_async_dir_prepare)"
  then
    return 1
  fi

  local lock_path="$dir/modem-${modem_key}.lock"

  (
    while ! mkdir "$lock_path"
    do
      sleep "$WATCH_WORKER_LOCK_SLEEP"
    done

    trap "watch_worker_release_lock '$lock_path'" EXIT INT TERM

    echo_debug "watch: worker $$ handling SMS $id for modem $modem_key"
    watch_handle_sms "$id" "$modem_hint"
    echo_debug "watch: worker $$ finished SMS $id for modem $modem_key"
  ) &
  local pid=$!

  watch_worker_register "$modem_key" "$pid"
  echo_debug "watch: started async SMS worker pid=$pid for modem $modem_key (id=$id)"

  return 0
}

# Queue an SMS for asynchronous handling, falling back to synchronous work when needed.
watch_enqueue_sms() {
  local id="$1"
  local modem_hint="$2"
  local modem_key
  modem_key="$(watch_queue_key "$modem_hint")"

  watch_worker_prune_for_modem "$modem_key"

  local pending
  pending="$(watch_worker_pending_count "$modem_key")"

  if (( pending >= WATCH_MAX_PENDING_PER_MODEM ))
  then
    echo_warning "watch: modem $modem_key pending workers at limit ($pending); processing SMS $id synchronously"
    watch_handle_sms "$id" "$modem_hint"
    return
  fi

  if watch_spawn_worker "$id" "$modem_hint" "$modem_key"
  then
    return
  fi

  echo_warning "watch: failed to start async worker for modem $modem_key; processing SMS $id synchronously"
  watch_handle_sms "$id" "$modem_hint"
}

# Terminate and reap all watcher worker processes.
watch_stop_workers() {
  watch_worker_prune_all

  local modem_key
  for modem_key in "${!WATCH_WORKER_PIDS[@]}"
  do
    local pids="${WATCH_WORKER_PIDS[$modem_key]}"
    local pid
    for pid in $pids
    do
      if watch_pid_alive "$pid"
      then
        if ! kill "$pid"
        then
          echo_warning "watch: failed to terminate worker pid=$pid for modem $modem_key"
        fi
      fi
    done
  done

  for modem_key in "${!WATCH_WORKER_PIDS[@]}"
  do
    local pids="${WATCH_WORKER_PIDS[$modem_key]}"
    local pid
    for pid in $pids
    do
      if ! wait "$pid"
      then
        echo_warning "watch: worker pid=$pid for modem $modem_key exited with error"
      fi
    done
    unset 'WATCH_WORKER_PIDS[$modem_key]'
  done

  if [[ -n "$WATCH_ASYNC_DIR" ]]
  then
    if [[ -d "$WATCH_ASYNC_DIR" ]]
    then
      if ! rm -rf "$WATCH_ASYNC_DIR"
      then
        echo_warning "watch: failed to remove async directory $WATCH_ASYNC_DIR"
      fi
    fi
    WATCH_ASYNC_DIR=""
  fi
}

# Continuously auto-enable modems while watch mode is active.
watch_enable_monitor_loop() {
  local target_modem="${1:-}"
  local enable_all="${2:-}"
  local interval="$WATCH_ENABLE_POLL_INTERVAL"

  declare -A enabled_modems=()
  local -a mids=()

  if mapfile -t mids < <(list_modem_ids_sorted)
  then
    local mid
    for mid in "${mids[@]}"
    do
      [[ -z "$mid" ]] && continue
      if [[ -n "$enable_all" ]]
      then
        enabled_modems["$mid"]=1
      elif [[ -n "$target_modem" && "$target_modem" != "any" && "$mid" == "$target_modem" ]]
      then
        enabled_modems["$mid"]=1
      fi
    done
  fi

  while :
  do
    mids=()
    if mapfile -t mids < <(list_modem_ids_sorted)
    then
      local mid
      for mid in "${mids[@]}"
      do
        [[ -z "$mid" ]] && continue
        if [[ -n "$enable_all" ]]
        then
          if [[ -z "${enabled_modems[$mid]:-}" ]]
          then
            echo_info "watch: auto-enabling modem $mid"
            if enable_modem "$mid"
            then
              enabled_modems["$mid"]=1
            else
              echo_warning "watch: failed to auto-enable modem $mid"
            fi
          fi
        else
          if [[ -z "$target_modem" || "$target_modem" == "any" ]]
          then
            if [[ -z "${enabled_modems[$mid]:-}" ]]
            then
              echo_info "watch: auto-enabling modem $mid"
              if enable_modem "$mid"
              then
                enabled_modems["$mid"]=1
                target_modem="$mid"
              else
                echo_warning "watch: failed to auto-enable modem $mid"
              fi
            fi
          elif [[ "$mid" == "$target_modem" ]]
          then
            if [[ -z "${enabled_modems[$mid]:-}" ]]
            then
              echo_info "watch: auto-enabling target modem $mid"
              if enable_modem "$mid"
              then
                enabled_modems["$mid"]=1
              else
                echo_warning "watch: failed to auto-enable target modem $mid"
              fi
            fi
          fi
        fi
      done

      local known mid_present present
      for known in "${!enabled_modems[@]}"
      do
        present=0
        for mid_present in "${mids[@]}"
        do
          if [[ "$mid_present" == "$known" ]]
          then
            present=1
            break
          fi
        done
        if (( present == 0 ))
        then
          unset 'enabled_modems[$known]'
        fi
      done
    fi

    sleep "$interval"
  done
}

# Start the background loop that auto-enables modems for watch mode.
watch_start_enable_monitor() {
  if [[ -z "$WATCH_ENABLE" ]]
  then
    return 0
  fi

  if [[ -n "$WATCH_MODEM_MONITOR_PID" ]]
  then
    return 0
  fi

  local target_modem="$MODEM"
  local enable_all="$ALL_MODEMS"

  watch_enable_monitor_loop "$target_modem" "$enable_all" &
  WATCH_MODEM_MONITOR_PID=$!
}

# Normalize a phone number to digits for whitelist comparisons.
watch_canon_number() {
  local n="${1:-}"
  n="${n//[^0-9]/}"
  printf '%s' "$n"
}

# Check whether a sender number is present in the whitelist.
watch_in_whitelist() {
  local original="${1:-}"

  local num
  num="$(watch_canon_number "$original")"
  if [[ -z "$num" ]]
  then
    echo_warning "watch: sender '${original}' not whitelisted (empty canonical number); whitelist='${SMS_WHITELIST[*]}'"
    return 1
  fi

  local allowed canon_allowed
  for allowed in "${SMS_WHITELIST[@]}"
  do
    canon_allowed="$(watch_canon_number "$allowed")"
    if [[ -n "$canon_allowed" && "$num" == "$canon_allowed" ]]
    then
echo_info "watch: sender '${original}' matched whitelist entry '${allowed}' (whitelist='${SMS_WHITELIST[*]}')"
      return 0
    fi
  done

  echo_warning "watch: sender '${original}' not in whitelist; whitelist='${SMS_WHITELIST[*]}'"
  return 1
}

# Send an SMS reply, optionally using fallback behavior.
watch_send_reply() {
  local to="$1"
  local msg="$2"
  # Log outgoing SMS (abbreviate text and escape newlines)
  local log_text
  log_text="$(abbrev_text_for_log "$msg")"
  local log_modem
  log_modem="$(modem_info_brief)"

  echo_info "sending reply with modem={$log_modem} recipient=$to text='$log_text'"
  if [[ -n "$FALLBACK" ]]
  then
    if ! sms_send_with_fallback "$to" "$msg"
    then
      echo_warning "failed to send reply to $to (including fallback)"
      return 1
    fi
    return 0
  fi

  if ! sms_send "$to" "$msg"
  then
    echo_warning "failed to send reply to $to"
    return 1
  fi
}

# Execute a shell command for watch automation with timeout handling.
watch_run_command() {
  local user_cmd="$1"
  local cmd="NO_COLOR=1 $1"
  local output status="exit" json now
  local rc=0

  if command -v timeout &>/dev/null
  then
    output="$(timeout -k "${WATCH_CMD_KILL_TIMEOUT}s" "${WATCH_CMD_TIMEOUT}s" bash -c "NO_COLOR=1 $cmd" 2>&1)"
    rc=$?
    if (( rc == 124 ))
    then
      status="timeout"
    elif (( rc >= 128 ))
    then
      status="killed"
    fi
  else
    output="$(bash -c "NO_COLOR=1 $cmd" 2>&1)"
    rc=$?
  fi

  output="${output%$'\n'}"
  if (( ${#output} > CMD_OUTPUT_MAX_LEN ))
  then
    output="${output:0:CMD_OUTPUT_MAX_LEN}\nâ€¦(truncated)â€¦"
  fi

  now="$(date -Iseconds)"

  jq -cen \
    --arg cmd "$user_cmd" \
    --argjson rc "$rc" \
    --arg status "$status" \
    --arg date "$now" \
    --arg output "$output" \
    '{cmd:$cmd, rc:$rc, status:$status, date:$date, output:$output}'
}

# Load and cache the modem's own number via mmcli.
load_own_number() {
  if [[ -n "$OWN_NUMBER" ]]
  then
    return 0
  fi

  local json number
  if ! json="$(mmcli_cmd -J)"
  then
    return 1
  fi

  number="$(jq -r '(.modem.generic["own-numbers"][0] // empty)' <<<"$json")"

  if [[ -z "$number" ]]
  then
    return 1
  fi

  number=$(ensure_plus "$number")
  OWN_NUMBER="$number"

  return 0
}

# Retrieve and cache the SMSC number using AT+CSCA?.
get_smsc_number() {
  if [[ -n "$SMSC_NUMBER" ]]
  then
    printf '%s' "$SMSC_NUMBER"
    return 0
  fi

  # Try to retrieve the network-configured SMSC via AT+CSCA?
  # If unavailable or unsupported, return empty (do not force SMSC).
  local resp smsc
  resp="$(at_command 'AT+CSCA?')"
  if [[ -n "$resp" ]]
  then
    smsc="$(at_first_quoted_decoded "$resp")"
    if [[ -n "$smsc" ]]
    then
      smsc="$(ensure_plus "$smsc")"
      SMSC_NUMBER="$smsc"
      printf '%s' "$SMSC_NUMBER"
      return 0
    fi
  fi

  # No SMSC detected; leave empty so callers skip forcing one
  SMSC_NUMBER=""
  return 1
}

# Build a structured JSON object summarizing modem status details.
modem_status_details_json() {
  local js own smsc country_code="" country_label="" payload
  local fallback_modem="$MODEM"

  if ! js="$(mmcli_cmd -J)"
  then
    if [[ -z $QUIET ]]
    then
      echo_error "failed to query modem status"
    fi
    return 1
  fi

  own="$(jq -r '.modem.generic["own-numbers"][0] // ""' <<<"$js")"
  own="$(ensure_plus "$own")"
  if [[ -n "$own" ]]

  then
    OWN_NUMBER="$own"
  fi

  if ! smsc="$(get_smsc_number)"
  then
    smsc=""
  fi
  smsc="$(ensure_plus "$smsc")"

  if [[ "$own" == +* ]]
  then
    country_code="$(phone_cc "$own")"
    if [[ "$country_code" == "--" || -z "$country_code" ]]
    then
      country_code=""
    else
      country_label="$(cc_to_label "$country_code")"
      if [[ "$country_label" == "--" ]]
      then
        country_label=""
      fi
    fi
  fi

  if ! payload="$(
    jq --arg own "$own" \
       --arg smsc "$smsc" \
       --arg fallback "$fallback_modem" \
       --arg cc "$country_code" \
       --arg country "$country_label" '
      def blank_to_null:
        if . == null or . == "" then null else . end;

      def normalize_port:
        if . == null or . == "" then null
        elif startswith("/") then .
        else "/dev/" + .
        end;

      def fallback_name($name; $sid):
        if $name != "" then $name
        elif $sid != "" then $sid
        else "" end;

      def fallback_code($code; $sid; $nid):
        if $code != "" then $code
        elif $nid != "" then $nid
        elif $sid != "" then $sid
        else "" end;

      (.modem.generic.ports // []) as $ports_raw
      | ($ports_raw
          | map(split(" ") | .[0])
          | map(normalize_port)
          | map(select(. != null))) as $ports
      | ($ports_raw
          | map(select(test("\\(at\\)"; "i")) | split(" ")[0] | normalize_port)
          | map(select(. != null))) as $at_candidates
      | (.modem["dbus-path"] // "") as $modem_path
      | ($modem_path | split("/")[-1]) as $mid_str
      | (.modem["3gpp"]["operator-name"] // "") as $carrier_name_raw
      | (.modem["3gpp"]["operator-code"] // "") as $carrier_code_raw
      | (.modem.cdma.sid // "") as $cdma_sid_raw
      | (.modem.cdma.nid // "") as $cdma_nid_raw
      | fallback_name($carrier_name_raw; $cdma_sid_raw) as $carrier_name
      | fallback_code($carrier_code_raw; $cdma_sid_raw; $cdma_nid_raw) as $carrier_code
      | {
          modem_id: ($mid_str | tonumber?),
          modem_label: (
            if ($mid_str // "") != "" then $mid_str
            elif ($fallback | test("^[0-9]+$")) then $fallback
            elif ($fallback | blank_to_null) then $fallback
            else "unknown" end
          ),
          state: (.modem.generic.state // null),
          power: (.modem.generic["power-state"] // null),
          registered: (.modem["3gpp"]["registration-state"] // null),
          signal: (.modem.generic["signal-quality"].value // null | tonumber?),
          carrier: (
            if $carrier_name != "" and $carrier_code != "" then
              if $carrier_name == $carrier_code then $carrier_name else $carrier_name + " (" + $carrier_code + ")" end
            elif $carrier_name != "" then $carrier_name
            elif $carrier_code != "" then $carrier_code
            else null end
          ),
          carrier_name: (if $carrier_name == "" then null else $carrier_name end),
          carrier_code: (if $carrier_code == "" then null else $carrier_code end),
          phone: ($own | blank_to_null),
          smsc: ($smsc | blank_to_null),
          manufacturer: ((.modem.generic.manufacturer // "") | blank_to_null),
          model: ((.modem.generic.model // "") | blank_to_null),
          plugin: ((.modem.generic.plugin // "") | blank_to_null),
          primary_port: ((.modem.generic["primary-port"] // "") | normalize_port),
          at_port: ($at_candidates[0] // null),
          ports: $ports,
          firmware: ((.modem.generic.revision // "") | blank_to_null),
          hardware_revision: ((.modem.generic["hardware-revision"] // "") | blank_to_null),
          equipment_id: ((.modem.generic["equipment-identifier"] // "") | blank_to_null),
          device: ((.modem.generic.device // "") | blank_to_null),
          device_identifier: ((.modem.generic["device-identifier"] // "") | blank_to_null),
          carrier_configuration: ((.modem.generic["carrier-configuration"] // "") | blank_to_null),
          carrier_configuration_revision: ((.modem.generic["carrier-configuration-revision"] // "") | blank_to_null),
          imei: ((.modem["3gpp"].imei // "") | blank_to_null),
          meid: ((.modem.cdma.meid // "") | blank_to_null),
          country_code: (if $cc == "" then null else ($cc | tonumber? // $cc) end),
          country: (if $country == "" then null else $country end)
        }
    ' <<<"$js"
  )"
  then
    return 1
  fi

  printf '%s\n' "$payload"
}

# Output status for the current modem in the requested format.
modem_status_single() {
  local payload raw


  if raw_plain_requested
  then
    mmcli_cmd
    return $?
  fi

  if raw_json_requested
  then
    if [[ -n "$ALL_MODEMS" ]]
    then
      local mids mid raw_items=()
      if mapfile -t mids < <(list_modem_ids_sorted)
      then
        for mid in "${mids[@]}"
        do
          [[ -z "$mid" ]] && continue
          if raw="$(MODEM="$mid" mmcli_cmd -J)"
          then
            raw_items+=("$raw")
          fi
        done
      fi
      if (( ${#raw_items[@]} == 0 ))
      then
        printf '[]
'
      else
        printf '%s
' "${raw_items[@]}" | jq -s '.'
      fi
    else
      mmcli_cmd -J | jq
    fi
    return 0
  fi

  if ! payload="$(modem_status_details_json)"
  then
    return 1

  fi

  if custom_json_requested
  then
    jq -e <<< "$payload"
    return "$?"
  fi

  local color_reset color_white color_cyan color_blue color_green color_yellow color_red color_magenta
  color_reset="$(ansi_escape "$COLOR_RESET")"
  color_white="$(ansi_escape "$COLOR_BOLD_WHITE")"
  color_cyan="$(ansi_escape "$COLOR_CYAN")"
  color_blue="$(ansi_escape "$COLOR_BOLD_BLUE")"
  color_green="$(ansi_escape "$COLOR_BOLD_GREEN")"
  color_yellow="$(ansi_escape "$COLOR_BOLD_YELLOW")"
  color_red="$(ansi_escape "$COLOR_BOLD_RED")"
  color_magenta="$(ansi_escape "$COLOR_BOLD_MAGENTA")"

  jq -r     --arg reset "$color_reset"     --arg white "$color_white"     --arg cyan "$color_cyan"     --arg blue "$color_blue"     --arg green "$color_green"     --arg yellow "$color_yellow"     --arg red "$color_red"     --arg magenta "$color_magenta" '
      def color($code; $text):
        if $code == "" then $text else $code + $text + $reset end;

      def value_or_dash($v):
        if $v == null or $v == "" then "--" else $v end;

      def split_lines($value):
        ($value // "--") | tostring | split("\n");

      def spaces($n):
        if $n <= 0 then ""
        else [range(0; $n) | " "] | add
        end;

      def format_label($label; $width):
        ($label // "") as $l
        | ($width - ($l | length)) as $pad
        | if $pad <= 0 then $l else $l + spaces($pad) end;

      def format_lines($label; $color; $lines; $width):
        if ($lines | length) == 0 then [""]
        else
          [format_label($label; $width) + "  " + color($color; $lines[0])]
          + ($lines[1:] | map(format_label(""; $width) + "  " + color($color; .)))
        end;


      def choose_state_color($state):
        if $state == null then $cyan
        else
          ($state | ascii_downcase) as $s
          | if ["connected","registered","enabled","online","on"] | index($s) then $green
            elif ["searching","initializing","connecting","locked","unknown"] | index($s) then $yellow
            elif ["failed","disabled","off"] | index($s) then $red
            else $cyan end
        end;

      def choose_power_color($power):
        if $power == null then $cyan
        else
          ($power | ascii_downcase) as $p
          | if ["on","full"] | index($p) then $green
            elif ["low"] | index($p) then $yellow
            elif ["off","unknown"] | index($p) then $red
            else $cyan end
        end;

      def choose_registration_color($reg):
        if $reg == null then $cyan
        else
          ($reg | ascii_downcase) as $r
          | if ["home","registered","attached"] | index($r) then $green
            elif ["roaming"] | index($r) then $magenta
            elif ["searching","idle","unknown"] | index($r) then $yellow
            elif ["denied","unregistered"] | index($r) then $red
            else $cyan end
        end;

      def choose_signal_color($value):
        if $value == null then $cyan
        elif $value >= 70 then $green
        elif $value >= 40 then $yellow
        else $red end;

      def join_ports($ports):
        if $ports == null or ($ports | length) == 0 then "--"
        else $ports | join(" ") end;

      def format_country($code; $label):
        if $code == null or $code == "" or $code == "null" then
          if $label == null or $label == "" then "--" else $label end
        else
          ($code | tostring) as $c
          | if $label == null or $label == "" then "+" + $c
            elif $label == $c then "+" + $c
            else $label + " (+" + $c + ")" end
        end;

      def add_row($rows; $label; $color; $value):
        $rows + [{label:$label, color:$color, value:$value}];

      def add_optional_row($rows; $label; $color; $value):
        if $value == null or $value == "" then $rows else add_row($rows; $label; $color; value_or_dash($value)) end;

      . as $m
      | ($m.modem_label // "unknown") as $modem_label
      | ($m.state // "unknown") as $state_label
      | ($m.power // "unknown") as $power_label
      | ($m.registered // "unknown") as $reg_label
      | ($m.signal // null) as $signal_value
      | (if $signal_value == null then "--" else ($signal_value | tostring) + "%" end) as $signal_display
      | ($m.carrier // null) as $carrier_display
      | ($m.phone // null) as $phone_display
      | ($m.smsc // null) as $smsc_display
      | ($m.firmware // null) as $firmware
      | ($m.hardware_revision // null) as $hardware
      | ($m.equipment_id // null) as $equipment
      | ($m.imei // null) as $imei
      | ($m.meid // null) as $meid
      | ($m.device_identifier // null) as $device_id
      | ($m.device // null) as $device
      | ($m.manufacturer // null) as $manufacturer
      | ($m.model // null) as $model
      | ($m.plugin // null) as $plugin
      | ($m.primary_port // null) as $primary_port
      | ($m.at_port // null) as $at_port
      | join_ports($m.ports) as $ports_display
      | ($m.carrier_configuration // null) as $carrier_config
      | ($m.carrier_configuration_revision // null) as $carrier_config_rev
      | (if $carrier_config != null and $carrier_config_rev != null then $carrier_config + " (" + $carrier_config_rev + ")"
         elif $carrier_config != null then $carrier_config
         elif $carrier_config_rev != null then $carrier_config_rev
         else null end) as $carrier_config_display
      | format_country($m.country_code; $m.country) as $country_display
      | (
          []
          | add_row(.; "Modem ID"; $white; value_or_dash($modem_label))
          | add_row(.; "State"; choose_state_color($m.state); value_or_dash($state_label))
          | add_row(.; "Power"; choose_power_color($m.power); value_or_dash($power_label))
          | add_row(.; "Registration"; choose_registration_color($m.registered); value_or_dash($reg_label))
          | add_row(.; "Signal"; choose_signal_color($signal_value); value_or_dash($signal_display))
          | add_row(.; "Carrier"; $blue; value_or_dash($carrier_display))
          | add_row(.; "Phone"; $blue; value_or_dash($phone_display))
          | add_row(.; "SMSC"; $blue; value_or_dash($smsc_display))
          | . + [null]
          | add_row(.; "Manufacturer"; $blue; value_or_dash($manufacturer))
          | add_row(.; "Model"; $blue; value_or_dash($model))
          | add_row(.; "Plugin"; $blue; value_or_dash($plugin))
          | add_row(.; "Primary Port"; $blue; value_or_dash($primary_port))
          | add_row(.; "AT Port"; $blue; value_or_dash($at_port))
          | add_row(.; "Ports"; $blue; value_or_dash($ports_display))
          | add_row(.; "Firmware"; $blue; value_or_dash($firmware))
          | add_row(.; "Hardware Rev"; $blue; value_or_dash($hardware))
          | add_row(.; "Equipment ID"; $blue; value_or_dash($equipment))
          | add_row(.; "IMEI"; $blue; value_or_dash($imei))
          | add_optional_row(.; "MEID"; $blue; $meid)
          | add_row(.; "Device ID"; $blue; value_or_dash($device_id))
          | add_row(.; "Device"; $blue; value_or_dash($device))
          | add_row(.; "Carrier Config"; $blue; value_or_dash($carrier_config_display))
          | add_row(.; "Country"; $blue; value_or_dash($country_display))
          | . + [null]
        ) as $rows
      | ($rows | map(select(. != null) | .label | length) | max // 0) as $width
      | $rows
      | map(
          if . == null then [""]
          else
            (.label // "") as $label
            | (.color // "") as $color
            | split_lines(.value) as $lines
            | format_lines($label; $color; $lines; $width)
          end
        )
      | (add // [])
      | .[]
    ' <<<"$payload"
}

# Display modem status for one or many modems respecting output flags.
modem_status() {
  local target_mid="${1:-}"

  if raw_plain_requested
  then
    if [[ -z "$target_mid" && -n "$ALL_MODEMS" ]]
    then
      local mids mid
      if ! mapfile -t mids < <(list_modem_ids_sorted)
      then
        echo_error "failed to list modems"
        return 1
      fi
      if (( ${#mids[@]} == 0 ))
      then
        echo_info "no modems detected"
        return 0
      fi

      local first=1
      for mid in "${mids[@]}"
      do
        [[ -z "$mid" ]] && continue
        if (( ! first ))
        then
          printf '\n'
        fi
        first=0
        MODEM="$mid" ALL_MODEMS="" modem_status_single
      done
      return 0
    fi

    modem_status_single
    return $?
  fi

  if [[ -z "$target_mid" && -n "$ALL_MODEMS" ]]
  then
    local mids mid
    if ! mapfile -t mids < <(list_modem_ids_sorted)
    then
      echo_error "failed to list modems"
      return 1
    fi
    if (( ${#mids[@]} == 0 ))
    then
      if json_like_requested
      then
        printf '[]\n'
      else
        echo_info "no modems detected"
      fi
      return 0
    fi

    if json_like_requested
    then
      local json_items=() item
      for mid in "${mids[@]}"
      do
        [[ -z "$mid" ]] && continue
        item="$(MODEM="$mid" ALL_MODEMS="" modem_status_single)"
        [[ -n "$item" ]] && json_items+=("$item")
      done
      if (( ${#json_items[@]} == 0 ))
      then
        printf '[]\n'
      else
        printf '%s\n' "${json_items[@]}" | jq -es '.'
      fi
      return 0
    fi

    local first=1
    for mid in "${mids[@]}"
    do
      [[ -z "$mid" ]] && continue
      (( first )) || printf '\n'
      first=0
      echo_info "modem $mid:"
      MODEM="$mid" ALL_MODEMS="" modem_status_single
    done
    return 0
  fi

  modem_status_single
}

# Print the modem's own phone number if available.
modem_number() {
  if ! load_own_number
  then
    local load_rc=$?
    if (( load_rc == 1 ))
    then
      echo_error "could not query modem for own number"
    else
      echo_error "modem did not report own number"
    fi
    return 1
  fi

  if [[ -z "$OWN_NUMBER" ]]
  then
    echo_error "modem did not report own number"
    return 2
  fi

  printf '%s\n' "$OWN_NUMBER"
  return 0
}

# Process an incoming SMS by validating, forwarding, or executing commands.
watch_handle_sms() {
  local id="$1"
  local prefer_modem_id="${2:-}"
  # Ensure replies and operations use the modem that received the message
  # by shadowing MODEM locally for mmcli_cmd invocations.
  # shellcheck disable=SC2031
  local MODEM="$MODEM"
  local modem_hint_label
  local modem_effective
  if [[ -n "$prefer_modem_id" ]]
  then
    MODEM="$prefer_modem_id"
    modem_hint_label="$prefer_modem_id"
  else
    echo_warning "no modem hint for SMS $id; defaulting to any"
    MODEM="any"
    modem_hint_label="--"
  fi
  modem_effective="$MODEM"
  echo_debug "watch: processing SMS $id (hint=$modem_hint_label effective=$modem_effective)"
  local tries=0
  local js state pdu sender text payload

  while :
  do
    if ! js="$(mmcli_cmd --sms "$id" -J)"
    then
      echo_warning "watch: failed to read SMS $id details via mmcli"
      return
    fi

    state="$(jq -r '.sms.properties.state // empty' <<<"$js")"
    pdu="$(jq -r '.sms.properties."pdu-type" // empty' <<<"$js")"
    sender="$(jq -r '.sms.content.number // empty' <<<"$js")"
    text="$(jq -r '.sms.content.text // empty' <<<"$js")"

    if [[ "$state" != "received" && "$pdu" != "deliver" ]]
    then
      echo_info "ignore id=$id (state=$state pdu=$pdu)"
      return
    fi

    if [[ -n "$OWN_NUMBER" && "$sender" == "$OWN_NUMBER" ]]
    then
      echo_info "skip self-sent id=$id"
      return
    fi

    if [[ -z "$text" && $tries -lt $SMS_RETRY_COUNT ]]
    then
      tries=$((tries + 1))
      sleep "$WATCH_RETRY_SLEEP"
      continue
    fi

    # Determine recipient (SIM MSISDN) for the modem that received the SMS
    # Prefer querying the current modem directly to avoid cross-modem mixups.
    local recipient=""
    local om_json
    if om_json="$(mmcli_cmd -J)"
    then
      recipient="$(jq -r '.modem.generic["own-numbers"][0] // empty' <<<"$om_json")"
      recipient="$(ensure_plus "$recipient")"
    fi

    local log_text
    log_text="$(abbrev_text_for_log "$text")"
    local log_recipient="$recipient"
    if [[ -z "$log_recipient" ]]
    then
      log_recipient="--"
    fi
    local sender_cc
    sender_cc="$(phone_cc_label "$sender")"
    echo_info "received message={id='$id' sender='$sender' (cc='$sender_cc') recipient='$log_recipient' text='$log_text'}"

    local sender_whitelisted
    if watch_in_whitelist "$sender"
    then
      sender_whitelisted=1
    fi

    local handled=0
    if [[ "$text" == "!"* ]]
    then
      if [[ -n $sender_whitelisted ]]
      then
        local cmd="${text#!}"
        # remove leading ws
        cmd=$(sed -E 's/^[[:space:]]+//' <<< "$cmd")

        if [[ -z "$cmd" ]]
        then
          watch_send_reply "$sender" "ERR: empty command"
        else
          echo_info "executing command from $sender: $cmd"
          local cmd_result rc status output cmd_header
          cmd_result="$(watch_run_command "$cmd")"
          rc="$(jq -r '.rc' <<<"$cmd_result")"
          status="$(jq -r '.status' <<<"$cmd_result")"
          output="$(jq -r '.output' <<<"$cmd_result")"
          cmd_header="$(jq -cr '{cmd, rc, status, date}' <<<"$cmd_result")"
          echo_info "command from $sender finished rc=$rc status=$status"
          # Before sending our reply, prune already-sent messages on this modem
          sms_prune_sent || echo_warning "failed to prune sent SMS before reply"
          if [[ -n "$output" ]]
          then
            watch_send_reply "$sender" "${cmd_header}\n${output}"
          else
            watch_send_reply "$sender" "$cmd_header"
          fi
        fi

        handled=1
      else
        echo_info "command from $sender ignored (not whitelisted)"
      fi
    fi

    if (( handled == 0 ))
    then
      payload="$(jq -n \
        --arg recipient "$recipient" \
        --arg sender "$sender" \
        --arg text "$text" \
        --arg date "$(date -Iseconds)" \
        '{recipient:$recipient, sender:$sender, text:$text, date: $date}')"
      echo_info "forwarding id=$id from $sender to webhook"
      local resp rc code body log_body
      resp="$(curl -sS -m 10 -H 'Content-Type: application/json' -w $'\n%{http_code}' \
        -X POST -d "$payload" "$WEBHOOK_URL" 2>&1)"
      rc=$?
      if (( rc != 0 ))
      then
        log_body="$(abbrev_text_for_log "$resp")"
        echo_warning "webhook delivery error rc='$rc' output='$log_body'"
      else
        code="${resp##*$'\n'}"
        body="${resp%$'\n'*}"

        if [[ "$code" =~ ^[0-9]{3}$ ]]
        then
          log_body="$(abbrev_text_for_log "$body")"
        else
          code="n/a"
          log_body="$(abbrev_text_for_log "$resp")"
        fi

        if [[ "$code" =~ ^2 ]]
        then
          echo_info "webhook response code='$code' body='$log_body'"
        else
          echo_warning "webhook response code='$code' body='$log_body'"
        fi
      fi
    fi

    if (( WATCH_DELETE_AFTER == 1 ))
    then
      if ! mmcli_cmd --messaging-delete-sms="$id" >/dev/null
      then
        echo_warning "failed to delete processed SMS $id"
      else
        echo_info "deleted processed SMS $id"
      fi
    fi
    return
  done
}

# Monitor D-Bus for new SMS events and dispatch handlers.
watch_messages() {
  export PATH="/usr/local/bin:/srv/bin:$PATH"
  trap watch_cleanup EXIT INT TERM
  trap watch_worker_prune_all CHLD

  WATCH_FIFO="${TMPDIR:-/tmp}/smsbus.$$"
  mkfifo "$WATCH_FIFO"

  local filter="type='signal',interface='org.freedesktop.ModemManager1.Modem.Messaging',member='Added'"
  dbus-monitor --system "$filter" >"$WATCH_FIFO" &
  WATCH_DBUS_PID=$!

  if load_own_number
  then
    if [[ -n "$OWN_NUMBER" ]]
    then
      echo_info "own number = $OWN_NUMBER"
    fi
  else
    local load_rc=$?
    if (( load_rc == 1 ))
    then
      echo_warning "could not query modem for own number"
    else
      echo_warning "modem did not report own number"
    fi
  fi

  if [[ -n "$WATCH_PRUNE" ]]
  then
    if ! sms_prune_all_modems
    then
      echo_warning "failed to prune existing SMS messages on all modems"
    fi
  fi

  if [[ -n "$WATCH_ENABLE" ]]
  then
    if [[ -n "$ALL_MODEMS" ]]
    then
      enable_all_modems || echo_warning "failed to enable all modems"
    else
      enable_modem "$MODEM" || echo_warning "failed to enable modem"
    fi
    watch_start_enable_monitor
  fi

  local current_modem_id=""
  while IFS= read -r line
  do
    # Track the modem id from the signal's path
    if [[ "$line" =~ /org/freedesktop/ModemManager1/Modem/([0-9]+) ]]
    then
      current_modem_id="${BASH_REMATCH[1]}"
    fi

    if [[ "$line" == *"/org/freedesktop/ModemManager1/SMS/"* ]]
    then
      local local_path="${line#*\"}"
      local_path="${local_path%%\"*}"
      local id="${local_path##*/}"
      if [[ "$id" =~ ^[0-9]+$ ]]
      then
        # If not listening on all, ignore messages from other modems
        if [[ -z "$ALL_MODEMS" && -n "$current_modem_id" && "$current_modem_id" != "$MODEM" ]]
        then
          echo_warning "ignoring SMS $id from modem $current_modem_id (listening on $MODEM)"
          continue
        fi
        watch_enqueue_sms "$id" "$current_modem_id"
      fi
    fi
  done <"$WATCH_FIFO"
}

# Decide whether a command needs MODEM resolved ahead of time.
command_requires_modem_resolution() {
  local cmd="$1"

  case "$cmd" in
    logs|service|pull)
      return 1
      ;;
  esac

  return 0
}

# Resolve MODEM to a concrete modem id and log the selection context.
resolve_modem_selection() {
  local cmd="$1"
  local defer_resolution=""

  if [[ "$cmd" == "enable" && -n "$ENABLE_WAIT_MODEM" && -z "$ALL_MODEMS" ]]
  then
    defer_resolution=1
  fi

  if [[ -n "$DEFAULT_MODEM" ]]
  then
    echo_debug "default modem configured: $DEFAULT_MODEM"
  fi

  if [[ -z "$ALL_MODEMS" && -z "$MODEM_EXPLICIT" && -n "$DEFAULT_MODEM" ]]
  then
    MODEM="$DEFAULT_MODEM"
    echo_debug "using default modem $MODEM"
  fi

  if [[ -n "$defer_resolution" ]]
  then
    echo_debug "deferring modem resolution for enable command (--wait active)"
    return 0
  fi

  local resolved
  if ! resolved="$(get_modem_id "$MODEM")"
  then
    # get_modem_id already printed context and list
    return 2
  fi

  MODEM="$resolved"

  if [[ "$MODEM" == "any" ]]
  then
    local _j _id
    if _j="$(mmcli_cmd -J)"
    then
      _id="$(jq -r '.modem["dbus-path"] | split("/")[-1] // empty' <<<"$_j")"
      if [[ -n "$_id" ]]
      then
        MODEM="$_id"
      fi
    fi
  fi

  if [[ -n $QUIET ]]
  then
    [[ -n $MODEM ]]
    return "$?"
  fi

  if [[ "$cmd" == "watch" && -n "$ALL_MODEMS" ]]
  then
    local _ids=()
    local _id
    if mapfile -t _ids < <(list_modem_ids_sorted)
    then
      echo_info "listening on all modems: ${#_ids[@]} detected"
      for _id in "${_ids[@]}"
      do
        [[ -z "$_id" ]] && continue
        log_modem_details "$_id"
      done
      MODEM_DETAILS_LOGGED=1
    else
      echo_info "listening on all modems"
    fi
    return 0
  fi

  if [[ -n "$ALL_MODEMS" ]]
  then
    local _ids=()
    if mapfile -t _ids < <(list_modem_ids_sorted)
    then
      if (( ${#_ids[@]} > 0 ))
      then
        echo_info "operating on all modems: ${#_ids[@]} detected"

        local _id
        for _id in "${_ids[@]}"
        do
          [[ -z "$_id" ]] && continue
          log_modem_details "$_id"
        done
        MODEM_DETAILS_LOGGED=1
      else
        echo_info "operating on all modems: none detected"
      fi
    else
      echo_info "operating on all modems"
    fi
  elif [[ -n "$MODEM" && "$MODEM" != "any" ]]
  then
    local _info
    if _info="$(get_modem_info "$MODEM" "selected ")"
    then
      echo_info "$_info"
    else
      echo_info "selected modem={id='$MODEM'}"
    fi
  else
    local _info
    if _info="$(get_modem_info "$MODEM" "selected ")"
    then
      echo_info "$_info"
    elif [[ "$MODEM" != "any" && -n "$MODEM" ]]
    then
      echo_info "selected modem={id='$MODEM'}"
    else
      echo_info "selected modem: any"
    fi
  fi

  return 0
}

# Parse CLI arguments, resolve configuration, and dispatch the requested command.
main() {
  local command=""
  local -a PRE_ARGS=()
  local -a ARGS=()
  local -a DEBUG_FLAGS=()

  while (( $# > 0 ))
  do
    case "$1" in
      -m|--modem)
        if (( $# < 2 ))
        then
          echo_error "missing value for $1"
          return 2
        fi
        DEBUG_FLAGS+=("$1=$2")
        MODEM="$2"
        MODEM_EXPLICIT=1
        shift 2
        continue
        ;;
      -d|--debug)
        DEBUG_FLAGS+=("$1")
        # shellcheck disable=SC2034
        DEBUG=1
        shift
        continue
        ;;
      -q|--quiet|--silent)
        DEBUG_FLAGS+=("$1")
        QUIET=1
        shift
        continue
        ;;
      -x|--trace)
        DEBUG_FLAGS+=("$1")
        PS4='+ [${BASH_SOURCE##*/}:${LINENO}] ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
        set -x
        shift
        continue
        ;;
      -s|--syslog)
        DEBUG_FLAGS+=("$1")
        # shellcheck disable=SC2034
        ECHO_SYSLOG=1
        shift
        continue
        ;;
      -c|--config)
        if (( $# < 2 ))
        then
          echo_error "missing value for $1"
          return 2
        fi
        DEBUG_FLAGS+=("$1=$2")
        CONFIG_FILE="$2"
        shift 2
        continue
        ;;
      --skip-modem-init)
        if (( $# < 2 ))
        then
          echo_error "missing value for $1"
          return 2
        fi
        DEBUG_FLAGS+=("$1=$2")
        add_skip_modem_init_pattern "$2"
        shift 2
        continue
        ;;
      --skip-modem-init=*)
        local pattern
        pattern="${1#*=}"
        if [[ -z "$pattern" ]]
        then
          echo_error "missing value for --skip-modem-init"
          return 2
        fi
        DEBUG_FLAGS+=("--skip-modem-init=$pattern")
        add_skip_modem_init_pattern "$pattern"
        shift
        continue
        ;;
      -h|--help)
        usage
        return 0
        ;;
      --)
        shift
        break
        ;;
      *)
        if [[ -z "$command" ]] && is_command_token "$1"
        then
          command="$1"
          shift
          break
        fi
        PRE_ARGS+=("$1")
        shift
        ;;
    esac
  done

  if [[ -z "$command" && $# -gt 0 ]]
  then
    command="$1"
    shift
  fi

  ARGS=("${PRE_ARGS[@]}")
  if (( $# > 0 ))
  then
    ARGS+=("$@")
  fi

  if [[ -z "$command" ]]
  then
    command="status"
  fi

  case "$command" in
    at|ati)
      command="at"
      ;;
    send|s)
      command="send"
      ;;
    list|ls|l|-l)
      command="list"
      ;;
    log*)
      command="logs"
      ;;
    read|get|r)
      command="read"
      ;;
    prune|clear|delete)
      command="prune"
      ;;
    -e|*enable*|en|start)
      command="enable"
      ;;
    status|stat|st)
      command="status"
      ;;
    number|phone)
      command="number"
      ;;
    reset|rst)
      command="reset"
      ;;
    service|svc)
      command="service"
      ;;
    watch|w)
      command="watch"
      ;;
    smsc)
      command="smsc"
      ;;
    help)
      local topic="${ARGS[0]:-}"
      if [[ -z "$topic" ]]
      then
        usage
      else
        case "$topic" in
          at|ati) topic="at" ;;
          en|enable|start) topic="enable" ;;
          log*) topic="logs" ;;
          l|ls|list) topic="list" ;;
          number|phone) topic="number" ;;
          rst|reset|restart) topic="reset" ;;
          r|get|read) topic="read" ;;
          service|svc) topic="service" ;;
          smsc) topic="smsc" ;;
          st|stat|status) topic="status" ;;
          s|send) topic="send" ;;
          w|watch) topic="watch" ;;
        esac

        print_subcommand_usage "$topic"
      fi
      return 0
      ;;
  esac

  if [[ "$command" == -* ]]
  then
    echo_error "unknown option: $command"
    usage >&2
    return 2
  fi

  parse_command_args "$command" "${ARGS[@]}"
  local parse_rc=$?
  if (( parse_rc == 64 ))
  then
    return 0
  elif (( parse_rc != 0 ))
  then
    return $parse_rc
  fi

  local -a CMD_ARGS=("${PARSED_ARGS[@]}")

  if ! load_config post-args
  then
    return $?
  fi

  if [[ "$command" == "watch" && -n "$WATCH_DELETE_AFTER_CLI_OVERRIDE" ]]
  then
    WATCH_DELETE_AFTER=1
  fi

  if [[ -n "$RAW_OUTPUT_FORCED" ]]
  then
    RAW_OUTPUT=1
  fi
  if [[ -n "$JSON_OUTPUT_FORCED" ]]
  then
    JSON_OUTPUT=1
  fi

  if command_requires_modem_resolution "$command"
  then
    local resolve_rc
    resolve_modem_selection "$command"
    resolve_rc=$?
    if (( resolve_rc != 0 ))
    then
      return "$resolve_rc"
    fi
  fi

  local dbg_args="" dbg_flags=""
  if (( ${#DEBUG_FLAGS[@]} > 0 ))
  then
    local dbg_flags_str
    printf -v dbg_flags_str '%q ' "${DEBUG_FLAGS[@]}"
    dbg_flags=" flags=${dbg_flags_str%% }"
  fi
  if (( ${#CMD_ARGS[@]} > 0 ))
  then
    local dbg_args_str
    printf -v dbg_args_str '%q ' "${CMD_ARGS[@]}"
    dbg_args=" args=${dbg_args_str%% }"
  fi
  echo_debug "command=$command${dbg_flags}${dbg_args}"

  case "$command" in
    at)
      if [[ -n ${CMD_ARGS[0]} ]]
      then
        at_command "${CMD_ARGS[@]}"
      else
        at_command_interactive
      fi
      ;;
    send)
      if [[ -n "$FALLBACK" ]]
      then
        if ! sms_send_with_fallback "${CMD_ARGS[@]}"
        then
          return 1
        fi
      else
        if ! sms_send "${CMD_ARGS[@]}"
        then
          echo_warning "send failed. fallback disabled, not trying other modems"
          return 1
        fi
      fi
      ;;
    list)
      sms_list_pretty
      ;;
    logs)
      mmsms_logread "${CMD_ARGS[@]}"
      ;;
    read)
      if (( ${#CMD_ARGS[@]} < 1 ))
      then
        echo_error "No SMS ID/path specified"
        # Show the message list in the same pretty/JSON/raw style
        sms_list_pretty || echo_error "failed to list SMS messages"
        return 1
      fi
        if raw_json_requested
        then
          mmcli_cmd --sms "${CMD_ARGS[0]}" -J | jq -e
        elif raw_plain_requested
        then
          sms_read_raw "${CMD_ARGS[@]}"
        elif custom_json_requested
        then
          sms_read_json "${CMD_ARGS[0]}"
        else
          sms_read_pretty "${CMD_ARGS[0]}"
        fi
      ;;
    service)
      mmsms_service_action "${CMD_ARGS[@]}"
      ;;
    pull)
      if (( ${#CMD_ARGS[@]} > 0 ))
      then
        echo_error "pull does not accept additional arguments"
        return 2
      fi
      if ! mmsms_repo_pull
      then
        return 1
      fi
      ;;
    prune)
      if [[ -n "$SENT_ONLY" && -n "$ALL_MODEMS" ]]
      then
        sms_prune_sent_modems
      elif [[ -n "$SENT_ONLY" ]]
      then
        sms_prune_sent
      elif [[ -n "$ALL_MODEMS" ]]
      then
        sms_prune_all_modems
      else
        sms_prune_all
      fi
      ;;
    enable)
      if [[ -n "$ALL_MODEMS" ]]
      then
        enable_all_modems
      else
        enable_modem "$MODEM"
      fi
      ;;
    status)
      modem_status "${CMD_ARGS[@]}"
      ;;
    number)
      modem_number
      ;;
    smsc)
      local smsc
      smsc="$(get_smsc_number)"
      printf "%s\n" "$smsc"
      ;;
    reset)
      if [[ -n "$ALL_MODEMS" ]]
      then
        modem_reset_all
      else
        modem_reset
      fi
      ;;
    watch)
      # Config already sourced earlier; ensure whitelist is populated
      if (( ${#SMS_WHITELIST[@]} == 0 ))
      then
        echo_error "watch requires at least one whitelisted number (SMS_WHITELIST)"
        return 2
      fi
      watch_messages
      ;;
    *)
      echo_error "unknown command: $command"
      usage >&2
      return 2
      ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "$0" ]]
then
  main "$@"
fi
