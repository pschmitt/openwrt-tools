#!/usr/bin/env bash

set -euo pipefail

SCRIPT_NAME="$(basename "${BASH_SOURCE[0]}")"

cd "$(dirname "$(readlink -f "$0")")" || return 9

# shellcheck source=lib/echo.sh
source lib/echo.sh || exit 2

CONFIG_FILE="${CONFIG_FILE:-/etc/mmsms.conf}"
# source configuration file
# shellcheck disable=SC1090
if ! source "$CONFIG_FILE"
then
  echo_error "$SCRIPT_NAME: could not read configuration file $CONFIG_FILE"
  exit 2
fi

MODEM="${MODEM:-any}"
DEFAULT_SMSC_NUMBER=""
OWN_NUMBER="${OWN_NUMBER:-}"
SMSC_NUMBER="${SMSC_NUMBER:-}"
SMS_SEND_TIMEOUT="${SMS_SEND_TIMEOUT:-30}"
SMS_SEND_RETRY_COUNT="${SMS_SEND_RETRY_COUNT:-2}"
CMD_OUTPUT_MAX_LEN="${CMD_OUTPUT_MAX_LEN:-4000}"

WEBHOOK_URL="${WEBHOOK_URL:-}"
WATCH_DELETE_AFTER="${DELETE_AFTER:-1}"
WATCH_MAX_RETRY="${MAX_RETRY:-3}"
WATCH_RETRY_SLEEP="${RETRY_SLEEP:-1}"
WATCH_CMD_TIMEOUT="${CMD_TIMEOUT:-8}"
WATCH_CMD_KILL_TIMEOUT="${WATCH_CMD_KILL_TIMEOUT:-${CMD_KILL_TIMEOUT:-20}}"

QUIET="${QUIET:-}"
JSON_OUTPUT="${JSON_OUTPUT:-}"
RAW_OUTPUT="${RAW_OUTPUT:-}"

# Ensure SMS_WHITELIST is defined as an array if provided by the config
if ! declare -p SMS_WHITELIST >/dev/null 2>&1
then
  SMS_WHITELIST=()
fi

# Allow overriding the whitelist via SMS_WHITELIST_OVERRIDE (comma or space separated digits)
if [[ -n "${SMS_WHITELIST_OVERRIDE:-}" ]]
then
  # shellcheck disable=SC2206
  SMS_WHITELIST=( ${SMS_WHITELIST_OVERRIDE//,/ } )
else
  if (( ${#SMS_WHITELIST[@]} == 0 )) && declare -p SMS_WHITELIST_DEFAULT >/dev/null 2>&1
  then
    SMS_WHITELIST=("${SMS_WHITELIST_DEFAULT[@]}")
  fi
fi

WATCH_FIFO=""
WATCH_DBUS_PID=""
WATCH_CMD_RC=0
WATCH_CMD_REASON="exit"

usage() {
  cat <<USAGE
Usage: $SCRIPT_NAME [OPTIONS] COMMAND [ARGS]

Options:
  -m, --modem MODEM    Modem selector or id (default: $MODEM)
                       Accepts id (e.g. 2), dbus path, 'any', or
                       a string matching manufacturer/plugin/ttyUSB
  -d, --debug          Enable debug output
  -j, --json           Output JSON (for list/status/read)
      --raw            List: output array of raw mmcli SMS objects; Read: raw mmcli JSON; Status: raw mmcli JSON
  -q, --quiet          Suppress info output (warnings/errors only)
      --silent         Same as --quiet
  -x, --trace          Enable shell tracing (set -x)
  -q, --quiet          Suppress status output (exit code only)
  -h, --help           Show this help and exit

Commands:
  send RECIPIENT [TEXT|-]   Send SMS; use '-' or stdin for TEXT
  list                      List SMS messages on the modem
  read MESSAGE_ID           Show details for a specific SMS
  prune                     Delete all SMS messages from the modem
  enable                    Wait for ModemManager and enable the modem
  status                    Show modem status summary
  restart                   Restart modemmanager, issue quectel reset, re-enable modem
  watch                     Monitor incoming SMS and forward/execute actions
  number|phone              Print modem's own phone number
  (default: status)
USAGE
}

error() {
  echo_error "$SCRIPT_NAME: $*"
}

# Log and run generic mmcli calls (no implicit --modem)
mmcli() {
  echo_debug "[mmcli] mmcli $*"
  command mmcli "$@"
}

# Resolve a human-friendly modem selector to a concrete modem id
# - Accepts: numeric id (e.g., 2), D-Bus path, 'any', or a substring
#   matching manufacturer, plugin, primary-port, or any ttyUSB/wwan port.
# - On multiple matches, prints a modem list to stderr and returns non-zero.
# - On no match, reports an error and shows the list.
get_modem_id() {
  local sel_raw="${1:-}"
  local sel

  # Default / passthrough cases
  if [[ -z "$sel_raw" || "$sel_raw" == any ]]
  then
    printf '%s' "any"
    return 0
  fi

  # If numeric id
  if [[ "$sel_raw" =~ ^[0-9]+$ ]]
  then
    printf '%s' "$sel_raw"
    return 0
  fi

  # If a D-Bus path (/org/.../Modem/N)
  if [[ "$sel_raw" == */Modem/* ]]
  then
    printf '%s' "${sel_raw##*/}"
    return 0
  fi

  # Case-insensitive substring match on fields
  sel="${sel_raw,,}"

  local list_json ids id json
  if ! list_json="$(mmcli -L -J)"
  then
    error "could not query modem list via mmcli"
    return 1
  fi

  # Collect modem ids
  mapfile -t ids < <(jq -r '."modem-list"[]? | split("/")[-1]' <<<"$list_json" 2>/dev/null)
  if (( ${#ids[@]} == 0 ))
  then
    error "no modems detected"
    return 1
  fi

  local matches=()
  for id in "${ids[@]}"
  do
    [[ -z "$id" ]] && continue
    if ! json="$(mmcli -m "$id" -J)"
    then
      continue
    fi

    # Extract candidate fields and match case-insensitively in bash
    local fields
    fields="$(jq -r '
      .modem.generic as $g
      | [
          ($g.manufacturer // ""),
          ($g.plugin // ""),
          ($g["primary-port"] // ""),
          (($g.ports // [])[]? | (split(" ")[0]))
        ] | .[]
    ' <<<"$json" 2>/dev/null || true)"
    if [[ -n "$fields" ]]
    then
      local f lf
      while IFS= read -r f
      do
        lf="${f,,}"
        if [[ "$lf" == *"$sel"* ]]
        then
          matches+=("$id")
          break
        fi
      done <<< "$fields"
    fi
  done

  if (( ${#matches[@]} == 1 ))
  then
    printf '%s' "${matches[0]}"
    return 0
  fi

  # Helper to show available modems for disambiguation
  echo_error "${SCRIPT_NAME}: modem selector '${sel_raw}' matched ${#matches[@]} modem(s)" >&2
  echo_info "Available modems:" >&2
  for id in "${ids[@]}"
  do
    [[ -z "$id" ]] && continue
    if ! json="$(mmcli -m "$id" -J)"
    then
      continue
    fi
    jq -r '
      .modem as $m
      | {
          id: ($m["dbus-path"] | split("/")[-1]),
          manufacturer: ($m.generic.manufacturer // "--"),
          model: ($m.generic.model // "--"),
          plugin: ($m.generic.plugin // "--"),
          primary: ($m.generic["primary-port"] // "--"),
          ports: (($m.generic.ports // []) | map(split(" ")[0]) | join(","))
        }
      | ("  " + .id + ": " + .manufacturer + " " + .model
         + " plugin=" + .plugin
         + " primary=" + .primary
         + " ports=" + .ports)
    ' <<<"$json" >&2
  done

  if (( ${#matches[@]} == 0 ))
  then
    return 1
  fi

  # Ambiguous
  return 2
}

mmcli_cmd() {
  echo_debug "[mmcli] mmcli --modem $MODEM $*"
  command mmcli --modem "$MODEM" "$@"
}

sms_read() {
  local msg_id="$1"
  mmcli_cmd --sms "$msg_id"
}

sms_read_json() {
  local msg_id="$1"
  local js pdu msg_type
  if ! js="$(mmcli_cmd --sms "$msg_id" -J)"
  then
    return 1
  fi

  pdu="$(jq -r '.sms.properties["pdu-type"] // ""' <<<"$js" 2>/dev/null)"
  case "${pdu,,}" in
    deliver) msg_type="received" ;;
    submit) msg_type="sent" ;;
    status-report) msg_type="report" ;;
    *) msg_type="$pdu" ;;
  esac

  jq --arg type "$msg_type" '
    .sms as $s
    | {
        id: ($s["dbus-path"] | split("/")[-1] | tonumber?),
        sender: ($s.content.number // ""),
        text: ($s.content.text // ""),
        class: ($s.properties.class // ""),
        state: ($s.properties.state // ""),
        pdu: ($s.properties["pdu-type"] // ""),
        storage: ($s.properties.storage // ""),
        smsc: ($s.properties.smsc // ""),
        timestamp: ($s.properties.timestamp // ""),
        discharge_timestamp: ($s.properties["discharge-timestamp"] // ""),
        delivery_state: ($s.properties["delivery-state"] // ""),
        delivery_report: ($s.properties["delivery-report"] // ""),
        type: $type
      }
  ' <<<"$js" 2>/dev/null
}

sms_send() {
  if [[ $# -lt 2 ]]
  then
    usage >&2
    return 2
  fi

  local recipient="$1"
  shift
  local text=""

  recipient="${recipient//[[:space:]]/}"
  if [[ -n "$recipient" && "$recipient" != +* ]]
  then
    recipient="+$recipient"
  fi

  if (( $# == 0 ))
  then
    text="$(cat)"
  elif [[ "$1" == "-" ]]
  then
    shift
    text="$(cat)"
  else
    text="$*"
  fi

  if [[ -z "$text" ]]
  then
    error "no SMS text provided"
    return 2
  fi

  printf 'text=%q\n' "$text" >&2

  # DIRTYFIX For Home Assistant SMS notifications
  # text="$(echo -e "$text")"

  local tmpfile
  if ! tmpfile="$(mktemp /tmp/mm-sms-text.XXXXXX)"
  then
    error "failed to create temporary file for SMS text"
    return 1
  fi

  if ! printf '%s' "$text" >"$tmpfile"
  then
    rm -f "$tmpfile" 2>/dev/null || true
    error "failed to write SMS text to temporary file"
    return 1
  fi

  local sms_id=""
  local smsc_raw=""
  local smsc=""
  local smsc_params=""
  smsc_raw="$(get_smsc_number)"
  if [[ -n "$smsc_raw" ]]
  then
    smsc="${smsc_raw//[[:space:]]/}"
    if [[ -n "$smsc" && "$smsc" != +* ]]
    then
      smsc="+$smsc"
    fi
    if [[ -n "$smsc" && "$smsc" =~ ^\+[0-9]+$ ]]
    then
      smsc_params=",smsc=$smsc"
    elif [[ -n "$smsc_raw" ]]
    then
      echo_warning "[mmsms:send] invalid smsc '$smsc_raw', skipping"
      smsc=""
    fi
  fi
  local attempt=1
  local max_attempts=$((SMS_SEND_RETRY_COUNT + 1))
  local rc=1

  while (( attempt <= max_attempts ))
  do
    sms_id=""
    local create_json
    create_json=""
    if ! create_json="$(mmcli_cmd -J --messaging-create-sms="number=${recipient}${smsc_params}" \
      --messaging-create-sms-with-text="$tmpfile")"
    then
      if (( attempt == max_attempts ))
      then
        error "failed to create SMS after $max_attempts attempts"
        break
      fi
      echo_warning "[mm-sms:send] failed to create SMS (attempt $attempt/$max_attempts), retrying"
      attempt=$((attempt + 1))
      continue
    fi

    if ! sms_id="$(jq -r '.modem.messaging["created-sms"] // empty' <<<"$create_json" 2>/dev/null)"
    then
      sms_id=""
    fi

    if [[ -z "$sms_id" ]]
    then
      if (( attempt == max_attempts ))
      then
        error "failed to create SMS after $max_attempts attempts"
        break
      fi
      echo_warning "[mm-sms:send] received empty SMS id (attempt $attempt/$max_attempts), retrying"
      attempt=$((attempt + 1))
      continue
    fi

    if mmcli_cmd --sms "$sms_id" --send --timeout="$SMS_SEND_TIMEOUT"
    then
      rc=0
      break
    fi

    if (( attempt == max_attempts ))
    then
      error "failed to send SMS after $max_attempts attempts"
      break
    fi

    echo_warning "[mm-sms:send] failed to send SMS (attempt $attempt/$max_attempts), retrying"
    attempt=$((attempt + 1))
  done

  rm -f "$tmpfile" 2>/dev/null || true
  return $rc
}

sms_prune_all() {
  local ids
  if ! ids="$(mmcli_cmd --messaging-list-sms -J | \
    jq -er '."modem.messaging.sms"[]? | split("/")[-1]' 2>/dev/null)"
  then
    return 0
  fi

  if [[ -z "$ids" ]]
  then
    return 0
  fi

  while IFS= read -r sms_id
  do
    [[ -z "$sms_id" ]] && continue
    echo_info "[mm-sms:prune] deleting SMS $sms_id"
    if ! mmcli_cmd --messaging-delete-sms="$sms_id"
    then
      error "failed to delete SMS $sms_id"
    fi
  done <<< "$ids"
}

sms_list_pretty() {
  local list_json ids id js sender text msg_type pdu line maxlen=80

  if ! list_json="$(mmcli_cmd --messaging-list-sms -J)"
  then
    error "failed to list SMS messages"
    return 1
  fi

  mapfile -t ids < <(jq -r '."modem.messaging.sms"[]? | split("/")[-1]' <<<"$list_json" 2>/dev/null)
  if (( ${#ids[@]} == 0 ))
  then
    if [[ -n "$JSON_OUTPUT$RAW_OUTPUT" ]]
    then
      printf '[]\n'
    else
      echo_info "[mm-sms:list] no SMS messages"
    fi
    return 0
  fi

  if [[ -n "$RAW_OUTPUT" ]]
  then
    # Collect raw mmcli JSON objects and wrap in an array
    {
      for id in "${ids[@]}"
      do
        [[ -z "$id" ]] && continue
        mmcli_cmd --sms "$id" -J || true
      done
    } | jq -s '.'
    return 0
  fi

  if [[ -n "$JSON_OUTPUT" ]]
  then
    # Emit one compact JSON object per SMS, then wrap into an array
    {
      for id in "${ids[@]}"
      do
        [[ -z "$id" ]] && continue
        if ! js="$(mmcli_cmd --sms "$id" -J)"
        then
          continue
        fi
        pdu="$(jq -r '.sms.properties["pdu-type"] // ""' <<<"$js" 2>/dev/null)"
        case "${pdu,,}" in
          deliver) msg_type="received" ;;
          submit) msg_type="sent" ;;
          status-report) msg_type="report" ;;
          *) msg_type="$pdu" ;;
        esac
        jq -c --arg id "$id" --arg type "$msg_type" '
          {
            id: ($id|tonumber),
            sender: (.sms.content.number // ""),
            text: (.sms.content.text // ""),
            class: (.sms.content.class // ""),
            state: (.sms.properties.state // ""),
            pdu: (.sms.properties["pdu-type"] // ""),
            storage: (.sms.properties.storage // ""),
            type: $type
          }
        ' <<<"$js" 2>/dev/null || true
      done
    } | jq -s '.'
    return 0
  fi

  # Header for human-readable list (make entire line bold to preserve alignment)
  local _nocolor=0
  [[ -n "$NO_COLOR" || -n "$CRON" ]] && _nocolor=1
  local header_line
  header_line="$(printf '%-4s %-10s %-18s %s' 'ID' 'TYPE' 'FROM' 'MSG')"
  if (( _nocolor ))
  then
    printf '%s\n' "$header_line"
  else
    printf '\e[1m%s\e[0m\n' "$header_line"
  fi

  for id in "${ids[@]}"
  do
    [[ -z "$id" ]] && continue
    if ! js="$(mmcli_cmd --sms "$id" -J)"
    then
      continue
    fi
    sender="$(jq -r '.sms.content.number // "--"' <<<"$js" 2>/dev/null)"
    pdu="$(jq -r '.sms.properties["pdu-type"] // ""' <<<"$js" 2>/dev/null)"
    case "${pdu,,}" in
      deliver) msg_type="received" ;;
      submit) msg_type="sent" ;;
      status-report) msg_type="report" ;;
      *) msg_type="$pdu" ;;
    esac
    text="$(jq -r '.sms.content.text // ""' <<<"$js" 2>/dev/null)"
    text=${text//$'\r'/}
    text=${text//$'\n'/\\n}
    if (( ${#text} > maxlen ))
    then
      text="${text:0:maxlen}..."
    fi
    printf '%-4s %-10s %-18s %s\n' "$id" "$msg_type" "$sender" "$text"
  done
}

enable_log() {
  echo_info "[mm-sms:enable] $*"
}

enable_modem() {
  local max_wait=600
  local sleep_period=2
  local elapsed=0

  enable_log "waiting for D-Bus system socket"
  until [[ -S /var/run/dbus/system_bus_socket ]]
  do
    if (( elapsed >= max_wait ))
    then
      echo_warning "[mm-sms:enable] timeout waiting for D-Bus socket"
      return 1
    fi
    sleep "$sleep_period"
    elapsed=$((elapsed + sleep_period))
  done

  enable_log "waiting for ModemManager"
  elapsed=0
  until mmcli -L >/dev/null 2>&1
  do
    if (( elapsed >= max_wait ))
    then
      echo_warning "[mm-sms:enable] timeout waiting for ModemManager"
      return 1
    fi
    sleep "$sleep_period"
    elapsed=$((elapsed + sleep_period))
  done

  enable_log "waiting for modem detection"
  elapsed=0
  local list_json=""
  local modem_count=0
  while :
  do
    list_json=""
    modem_count=0
    if list_json="$(mmcli -L -J)"
    then
      modem_count="$(jq -r '((."modem-list" // []) | length) // 0' <<<"$list_json" 2>/dev/null || printf '0')"
      if [[ "$modem_count" =~ ^[0-9]+$ ]] && (( modem_count > 0 ))
      then
        break
      fi
    fi

    if (( elapsed >= max_wait ))
    then
      echo_warning "[mm-sms:enable] timeout waiting for modem detection"
      return 1
    fi
    sleep "$sleep_period"
    elapsed=$((elapsed + sleep_period))
  done

  enable_log "detected $modem_count modem(s)"

  if mmcli_cmd --enable >/dev/null 2>&1
  then
    enable_log "modem enabled"
    return 0
  fi

  echo_warning "[mm-sms:enable] failed to enable modem"
  return 1
}

modem_reset() {
  local service="/etc/init.d/modemmanager"
  local has_service=0

  if [[ -x "$service" ]]
  then
    has_service=1
  else
    reset_warn "modemmanager init script not found or not executable at $service"
  fi

  if ! command -v quectel >/dev/null 2>&1
  then
    error "quectel command not found in PATH"
    return 1
  fi

  if (( has_service ))
  then
    reset_log "stopping ModemManager"
    if ! "$service" stop
    then
      error "failed to stop ModemManager service"
      return 1
    fi
  fi

  reset_log "issuing quectel reset"
  if ! quectel reset
  then
    error "quectel reset failed"
    if (( has_service ))
    then
      reset_warn "attempting to restart ModemManager after reset failure"
      "$service" start || reset_warn "could not restart ModemManager"
    fi
    return 1
  fi

  if (( has_service ))
  then
    reset_log "starting ModemManager"
    if ! "$service" start
    then
      error "failed to start ModemManager service"
      return 1
    fi
  fi

  reset_log "enabling modem"
  if ! enable_modem
  then
    reset_warn "failed to enable modem after reset, retrying in 5s"
    sleep 5
    if ! enable_modem
    then
      error "failed to enable modem after reset"
      return 1
    fi
  fi

  return 0
}

watch_log() {
  echo_info "[mm-sms:watch] $*"
}

watch_warn() {
  echo_warning "[mm-sms:watch] $*"
}

reset_log() {
  if [[ -z $QUIET ]]
  then
    echo_info "[mm-sms:reset] $*"
  fi
}

reset_warn() {
  echo_warning "[mm-sms:reset] $*"
}

watch_cleanup() {
  if [[ -n "$WATCH_DBUS_PID" ]]
  then
    if ! kill "$WATCH_DBUS_PID" 2>/dev/null
    then
      watch_warn "could not stop dbus-monitor (pid $WATCH_DBUS_PID)"
    fi
    WATCH_DBUS_PID=""
  fi
  if [[ -n "$WATCH_FIFO" ]]
  then
    if ! rm -f "$WATCH_FIFO" 2>/dev/null
    then
      watch_warn "could not remove fifo $WATCH_FIFO"
    fi
    WATCH_FIFO=""
  fi
}

watch_canon_number() {
  local n="${1:-}"
  n="${n//[^0-9]/}"
  printf '%s' "$n"
}

watch_in_whitelist() {
  local num
  num="$(watch_canon_number "${1:-}")"
  if [[ -z "$num" ]]
  then
    return 1
  fi
  local allowed canon_allowed
  for allowed in "${SMS_WHITELIST[@]}"
  do
    canon_allowed="$(watch_canon_number "$allowed")"
    if [[ -n "$canon_allowed" && "$num" == "$canon_allowed" ]]
    then
      return 0
    fi
  done
  return 1
}

watch_send_reply() {
  local to="$1"
  local msg="$2"
  if ! sms_send "$to" "$msg"
  then
    watch_warn "failed to send reply to $to"
    return 1
  fi
}

watch_run_command() {
  local cmd="$1"
  local output rc reason="exit"
  rc=0

  if command -v timeout >/dev/null 2>&1
  then
    if ! output="$(timeout -k "${WATCH_CMD_KILL_TIMEOUT}s" "${WATCH_CMD_TIMEOUT}s" bash -c "$cmd" 2>&1)"
    then
      rc=$?
    fi
    if (( rc == 124 ))
    then
      reason="timeout"
    elif (( rc >= 128 ))
    then
      reason="killed"
    fi
  else
    if ! output="$(bash -c "$cmd" 2>&1)"
    then
      rc=$?
    fi
  fi

  WATCH_CMD_RC=$rc
  WATCH_CMD_REASON=$reason

  output="${output%$'\n'}"
  if (( ${#output} > CMD_OUTPUT_MAX_LEN ))
  then
    output="${output:0:CMD_OUTPUT_MAX_LEN}\n…(truncated)…"
  fi

  printf '%s' "$output"
}

load_own_number() {
  if [[ -n "$OWN_NUMBER" ]]
  then
    return 0
  fi

  local json number
  if ! json="$(mmcli_cmd -J)"
  then
    return 1
  fi

  number="$(jq -r '(.modem.generic["own-numbers"][0] // empty)' <<<"$json")"
  if [[ -z "$number" ]]
  then
    return 2
  fi

  if [[ "$number" != +* ]]
  then
    number="+$number"
  fi

  OWN_NUMBER="$number"
  return 0
}

get_smsc_number() {
  if [[ -n "$SMSC_NUMBER" ]]
  then
    printf '%s' "$SMSC_NUMBER"
    return 0
  fi

  if load_own_number
  then
    SMSC_NUMBER="$OWN_NUMBER"
    printf '%s' "$SMSC_NUMBER"
    return 0
  fi

  SMSC_NUMBER="$DEFAULT_SMSC_NUMBER"
  printf '%s' "$SMSC_NUMBER"
}

modem_status() {
  local json state power reg signal carrier own smsc

  if ! json="$(mmcli_cmd -J)"
  then
    if [[ -z $QUIET ]]
    then
      error "failed to query modem status"
    fi
    return 1
  fi

  if [[ -n "$RAW_OUTPUT" ]]
  then
    printf '%s\n' "$json" | jq
    return 0
  fi

  state="$(jq -r '(.modem.generic.state // empty)' <<<"$json")"
  power="$(jq -r '(.modem.generic["power-state"] // empty)' <<<"$json")"
  reg="$(jq -r '(.modem["3gpp"]["registration-state"] // empty)' <<<"$json")"
  signal="$(jq -r '(.modem.generic["signal-quality"].value // empty)' <<<"$json")"
  carrier="$(jq -r '(.modem["3gpp"]["operator-name"] // .modem["3gpp"]["operator-code"] // .modem.cdma.sid // empty)' <<<"$json")"
  own="$(jq -r '(.modem.generic["own-numbers"][0] // empty)' <<<"$json")"

  if [[ -z "$state" ]]
  then
    state=unknown
  fi
  if [[ -z "$power" ]]
  then
    power=unknown
  fi
  if [[ -z "$reg" ]]
  then
    reg=unknown
  fi
  if [[ -n "$signal" ]]
  then
    signal="${signal}%"
  else
    signal=unknown
  fi
  if [[ -z "$carrier" ]]
  then
    carrier=unknown
  fi
  if [[ -n "$own" && "$own" != +* ]]
  then
    own="+$own"
  fi
  if [[ -z "$own" ]]
  then
    own=unknown
  else
    OWN_NUMBER="$own"
  fi

  # Derive SMSC (may use OWN_NUMBER or config); do not fail hard if empty
  smsc="$(get_smsc_number || true)"
  if [[ -z "$smsc" ]]
  then
    smsc=unknown
  fi

  # JSON output if requested
  if [[ -n "$JSON_OUTPUT" ]]
  then
    local sig_num_json
    sig_num_json="$(jq -r '(.modem.generic["signal-quality"].value // empty)' <<<"$json")"
    jq -n \
      --arg state "$state" \
      --arg power "$power" \
      --arg registered "$reg" \
      --arg carrier "$carrier" \
      --arg phone "$own" \
      --arg smsc "$smsc" \
      --arg sig "$sig_num_json" \
      '{state:$state, power:$power, registered:$registered, carrier:$carrier, phone:$phone, smsc:$smsc, signal: ($sig|tonumber?)}'
    return 0
  fi

  if [[ -z $QUIET ]]
  then
    # Color helpers (respect NO_COLOR and CRON)
    local _nocolor=0
    [[ -n "$NO_COLOR" || -n "$CRON" ]] && _nocolor=1

    colorize() { # $1=colorcode, $2=text
      if (( _nocolor ))
      then
        printf '%s' "$2"
      else
        printf '\e[%sm%s\e[0m' "$1" "$2"
      fi
    }

    # Choose colors
    local state_color power_color reg_color sig_color carrier_color phone_color smsc_color
    case "${state,,}" in
      connected|registered|enabled|online|on) state_color='1;32';;   # bold green
      searching|initializing|connecting|locked|unknown) state_color='1;33';; # bold yellow
      failed|disabled|off) state_color='1;31';;                      # bold red
      *) state_color='36';;                                          # cyan
    esac

    case "${power,,}" in
      on|full) power_color='1;32';;
      low) power_color='1;33';;
      off|unknown) power_color='1;31';;
      *) power_color='36';;
    esac

    case "${reg,,}" in
      home|roaming|registered|attached) reg_color='1;32';;
      searching|idle|unknown) reg_color='1;33';;
      denied|unregistered) reg_color='1;31';;
      *) reg_color='36';;
    esac

    # Determine signal color based on numeric value when available
    local sig_num
    sig_num="$(jq -r '(.modem.generic["signal-quality"].value // empty)' <<<"$json")"
    if [[ "$sig_num" =~ ^[0-9]+$ ]]
    then
      if (( sig_num >= 70 ))
      then
        sig_color='1;32'
      elif (( sig_num >= 40 ))
      then
        sig_color='1;33'
      else
        sig_color='1;31'
      fi
    else
      sig_color='36'
    fi

    carrier_color='1;34' # bold blue
    phone_color='1;34'
    smsc_color='1;34'

    printf 'modem state: %s\n' "$(colorize "$state_color" "$state")"
    printf 'power: %s\n' "$(colorize "$power_color" "$power")"
    printf 'registered: %s\n' "$(colorize "$reg_color" "$reg")"
    printf 'signal: %s\n' "$(colorize "$sig_color" "$signal")"
    printf 'carrier: %s\n' "$(colorize "$carrier_color" "$carrier")"
    printf 'phone: %s\n' "$(colorize "$phone_color" "$own")"
    printf 'smsc: %s\n' "$(colorize "$smsc_color" "$smsc")"
  fi

  return 0
}

modem_number() {
  if ! load_own_number
  then
    local load_rc=$?
    if (( load_rc == 1 ))
    then
      error "could not query modem for own number"
    else
      error "modem did not report own number"
    fi
    return 1
  fi

  if [[ -z "$OWN_NUMBER" ]]
  then
    error "modem did not report own number"
    return 2
  fi

  printf '%s\n' "$OWN_NUMBER"
  return 0
}

watch_handle_sms() {
  local id="$1"
  local tries=0
  local js state pdu sender text payload

  while :
  do
    if ! js="$(mmcli_cmd --sms "$id" -J)"
    then
      return
    fi

    state="$(jq -r '.sms.properties.state // empty' <<<"$js")"
    pdu="$(jq -r '.sms.properties."pdu-type" // empty' <<<"$js")"
    sender="$(jq -r '.sms.content.number // empty' <<<"$js")"
    text="$(jq -r '.sms.content.text // empty' <<<"$js")"

    if [[ "$state" != "received" && "$pdu" != "deliver" ]]
    then
      watch_log "ignore id=$id (state=$state pdu=$pdu)"
      return
    fi

    if [[ -n "$OWN_NUMBER" && "$sender" == "$OWN_NUMBER" ]]
    then
      watch_log "skip self-sent id=$id"
      return
    fi

    if [[ -z "$text" && $tries -lt $WATCH_MAX_RETRY ]]
    then
      tries=$((tries + 1))
      sleep "$WATCH_RETRY_SLEEP"
      continue
    fi

    local log_text="$text"
    log_text=${log_text//$'\r'/}
    log_text=${log_text//$'\n'/\\n}
    if [[ -z "$log_text" ]]
    then
      log_text="<empty>"
    elif (( ${#log_text} > 200 ))
    then
      log_text="${log_text:0:200}..."
    fi
    watch_log "received id=$id from $sender text='$log_text'"

    local handled=0
    if [[ "$text" == "!"* ]]
    then
      if watch_in_whitelist "$sender"
      then
        local cmd="${text#!}"
        while [[ "$cmd" == " "* ]]
        do
          cmd="${cmd# }"
        done
        if [[ -z "$cmd" ]]
        then
          watch_send_reply "$sender" "ERR: empty command"
        else
          watch_log "executing command from $sender: $cmd"
          local output
          output="$(watch_run_command "$cmd")"
          watch_log "command from $sender finished rc=$WATCH_CMD_RC reason=${WATCH_CMD_REASON:-exit}"
          watch_send_reply "$sender" "rc=$WATCH_CMD_RC (${WATCH_CMD_REASON:-exit})\n$output"
        fi
        handled=1
      else
        watch_log "command from $sender ignored (not whitelisted)"
      fi
    fi

    if (( handled == 0 ))
    then
      local recipient="$OWN_NUMBER"
      if [[ -z "$recipient" ]]
      then
        recipient="$(get_smsc_number)"
      fi
      payload="$(jq -n \
        --arg recipient "$recipient" \
        --arg sender "$sender" \
        --arg text "$text" \
        --arg date "$(date -Iseconds)" \
        '{recipient:$recipient, sender:$sender, text:$text, date: $date}')"
      watch_log "forwarding id=$id from $sender to webhook"
      if ! curl -sS -m 10 -H 'Content-Type: application/json' \
        -X POST -d "$payload" "$WEBHOOK_URL" >/dev/null
      then
        watch_warn "webhook delivery failed for id=$id"
      fi
    fi

    if (( WATCH_DELETE_AFTER == 1 ))
    then
      if ! mmcli_cmd --messaging-delete-sms="$id" >/dev/null 2>&1
      then
        watch_warn "failed to delete processed SMS $id"
      fi
    fi
    return
  done
}

watch_messages() {
  export PATH="/usr/local/bin:/srv/bin:$PATH"
  trap watch_cleanup EXIT INT TERM

  WATCH_FIFO="/tmp/smsbus.$$"
  mkfifo "$WATCH_FIFO"

  local filter="type='signal',interface='org.freedesktop.ModemManager1.Modem.Messaging',member='Added'"
  dbus-monitor --system "$filter" >"$WATCH_FIFO" &
  WATCH_DBUS_PID=$!

  if load_own_number
  then
    if [[ -n "$OWN_NUMBER" ]]
    then
      watch_log "own number = $OWN_NUMBER"
    fi
  else
    local load_rc=$?
    if (( load_rc == 1 ))
    then
      watch_warn "could not query modem for own number"
    else
      watch_warn "modem did not report own number"
    fi
  fi

  if ! sms_prune_all
  then
    watch_warn "failed to prune existing SMS messages"
  fi

  enable_modem || watch_warn "failed to enable modem"

  while IFS= read -r line
  do
    if [[ "$line" == *"/org/freedesktop/ModemManager1/SMS/"* ]]
    then
      local local_path="${line#*\"}"
      local_path="${local_path%%\"*}"
      local id="${local_path##*/}"
      if [[ "$id" =~ ^[0-9]+$ ]]
      then
        watch_handle_sms "$id"
      fi
    fi
  done <"$WATCH_FIFO"
}

main() {
  local command=""
  local -a ARGS=()

  # Global options can appear anywhere; collect non-option args into ARGS
  while (( $# > 0 ))
  do
    case "$1" in
      -m|--modem)
        if (( $# < 2 ))
        then
          error "missing value for $1"
          return 2
        fi
        MODEM="$2"
        shift 2
        ;;
      -d|--debug)
        DEBUG=1
        shift
        ;;
      -j|--json)
        JSON_OUTPUT=1
        shift
        ;;
      --raw)
        RAW_OUTPUT=1
        shift
        ;;
      -q|--quiet|--silent)
        QUIET=1
        shift
        ;;
      -x|--trace)
        PS4='+ [${BASH_SOURCE##*/}:${LINENO}] ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
        set -x
        shift
        ;;
      -h|--help)
        usage
        return 0
        ;;
      --)
        shift
        while (( $# > 0 ))
        do
          ARGS+=("$1")
          shift
        done
        break
        ;;
      *)
        ARGS+=("$1")
        shift
        ;;
    esac
  done

  if (( ${#ARGS[@]} == 0 ))
  then
    command="status"
  else
    command="${ARGS[0]}"
    ARGS=("${ARGS[@]:1}")
  fi

  case "$command" in
    send|s)
      command="send"
      ;;
    list|ls|l|-l)
      command="list"
      ;;
    read|get|r)
      command="read"
      ;;
    prune|clear|delete)
      command="prune"
      ;;
    -e|*enable*|en|start)
      command="enable"
      ;;
    status|stat|st)
      command="status"
      ;;
    number|phone)
      command="number"
      ;;
    reset|rst|restart)
      command="reset"
      ;;
    watch|w)
      command="watch"
      ;;
  esac

  if [[ "$command" == -* ]]
  then
    error "unknown option: $command"
    usage >&2
    return 2
  fi

  # Resolve human-friendly modem selector to a concrete id, once
  if ! MODEM="$(get_modem_id "$MODEM")"
  then
    # get_modem_id already printed context and list
    return 2
  fi

  # Pin 'any' to the actual modem id to avoid races in subsequent calls
  if [[ "$MODEM" == "any" ]]
  then
    local _j _id
    if _j="$(mmcli_cmd -J || true)"
    then
      _id="$(jq -r '.modem["dbus-path"] | split("/")[-1] // empty' <<<"$_j" 2>/dev/null)"
      if [[ -n "$_id" ]]
      then
        MODEM="$_id"
      fi
    fi
  fi

  # Informative log about resolved modem selection (guarded to avoid nesting)
  if [[ -z $QUIET ]]
  then
    if [[ "$MODEM" == "any" ]]
    then
      # Resolve which modem 'any' targets by querying mmcli -m any -J
      local _j _ln
      if _j="$(mmcli_cmd -J 2>/dev/null || true)"
      then
        _ln="$(jq -r '
          .modem as $m
          | {
              id: ($m["dbus-path"] | split("/")[-1]),
              manufacturer: ($m.generic.manufacturer // "--"),
              model: ($m.generic.model // "--"),
              plugin: ($m.generic.plugin // "--"),
              primary: ($m.generic["primary-port"] // "--"),
              ports: (($m.generic.ports // []) | map(split(" ")[0]) | join(","))
            }
          | ("[mm-sms] selected modem: " + .id + ": " + .manufacturer + " " + .model
             + " plugin=" + .plugin
             + " primary=" + .primary
             + " ports=" + .ports)
        ' <<<"$_j" 2>/dev/null || true)"
        echo_info "${_ln:-[mm-sms] selected modem: any}"
      else
        echo_info "[mm-sms] selected modem: any"
      fi
    else
      local _mjson _mln
      _mjson="$(mmcli -m "$MODEM" -J || true)"
      if [[ -n "$_mjson" ]]
      then
        _mln="$(jq -r '
          .modem as $m
          | {
              id: ($m["dbus-path"] | split("/")[-1]),
              manufacturer: ($m.generic.manufacturer // "--"),
              model: ($m.generic.model // "--"),
              plugin: ($m.generic.plugin // "--"),
              primary: ($m.generic["primary-port"] // "--"),
              ports: (($m.generic.ports // []) | map(split(" ")[0]) | join(","))
            }
          | ("[mm-sms] selected modem: " + .id + ": " + .manufacturer + " " + .model
             + " plugin=" + .plugin
             + " primary=" + .primary
             + " ports=" + .ports)
        ' <<<"$_mjson" 2>/dev/null || true)"
      fi
      echo_info "${_mln:-[mm-sms] selected modem: $MODEM}"
    fi
  fi

  case "$command" in
    send)
      sms_send "${ARGS[@]}"
      ;;
    list)
      sms_list_pretty
      ;;
    read)
      if (( ${#ARGS[@]} < 1 ))
      then
        error "No SMS ID/path specified"
        # Show the message list in the same pretty/JSON/raw style
        sms_list_pretty || error "failed to list SMS messages"
        return 1
      fi
      if [[ -n "$RAW_OUTPUT" ]]
      then
        mmcli_cmd --sms "${ARGS[0]}" -J | jq
      elif [[ -n "$JSON_OUTPUT" ]]
      then
        sms_read_json "${ARGS[0]}"
      else
        sms_read "${ARGS[@]}"
      fi
      ;;
    prune)
      sms_prune_all
      ;;
    enable)
      enable_modem
      ;;
    status)
      modem_status
      ;;
    number)
      modem_number
      ;;
    reset)
      modem_reset
      ;;
    watch)
      watch_messages
      ;;
    *)
      error "unknown command: $command"
      usage >&2
      return 2
      ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "$0" ]]
then
  main "$@"
fi
