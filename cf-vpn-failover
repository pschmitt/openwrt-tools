#!/usr/bin/env bash

# Manage failover CNAMEs for VPN hosts (netbird/tailscale) into a dedicated
# subzone. Chooses the best available VPN endpoint by probing reachability.

cd "$(dirname "$(readlink -f -- "$0")")" || return 9
# shellcheck source=lib/echo.sh
source lib/echo.sh || exit 2
# shellcheck source=cf-vpn-dns-update
source cf-vpn-dns-update || exit 2

usage() {
  echo "Usage: $(basename "$0") [--zone ZONE_NAME] [--subzone SUBZONE] [--nb-zone SUBZONE] [--ts-zone SUBZONE] [--zt-zone SUBZONE] [--dry-run] [--debug] [--ttl TTL]"
}

ping_host() {
  local ip="$1"

  if [[ -z "$ip" ]]
  then
    return 1
  fi

  local ping_bin="ping"
  local -a ping_args=("-c" "1" "-W" "1")

  if [[ "$ip" == *:* ]]
  then
    ping_args=("-6" "${ping_args[@]}")
  fi

  if ! command -v "$ping_bin" >/dev/null 2>&1
  then
    echo_error "No ping binary available"
    return 1
  fi

  "$ping_bin" "${ping_args[@]}" "$ip" >/dev/null 2>&1
  return "$?"
}

record_target() {
  local host="$1"
  local nb_ip="$2"
  local ts_ip="$3"
  local zt_ip="$4"

  local nb_up
  local ts_up
  local zt_up
  local record_type="CNAME"
  local record_value

  if ping_host "$nb_ip"
  then
    nb_up=1
  fi

  if ping_host "$ts_ip"
  then
    ts_up=1
  fi

  if ping_host "$zt_ip"
  then
    zt_up=1
  fi

  if [[ -n "${nb_up:-}" ]]
  then
    record_value="${host}.${NB_SUBZONE}.${ZONE_NAME}"
    echo "$record_type $record_value"
    return 0
  fi

  if [[ -n "${ts_up:-}" ]]
  then
    record_value="${host}.${TS_SUBZONE}.${ZONE_NAME}"
    echo "$record_type $record_value"
    return 0
  fi

  if [[ -n "${zt_up:-}" ]]
  then
    record_value="${host}.${ZT_SUBZONE}.${ZONE_NAME}"
    echo "$record_type $record_value"
    return 0
  fi

  record_value="${host}.${ZONE_NAME}"
  if ping_host "$record_value"
  then
    echo "$record_type $record_value"
    return 0
  fi

  record_type="A"
  record_value="0.0.0.0"
  echo "$record_type $record_value"
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]
then
  set -u -o pipefail

  export PATH="$PATH:/srv/bin"

  DEBUG="${DEBUG:-}"
  DRY_RUN="${DRY_RUN:-}"
  CF_CREDENTIALS_FILE="${CF_CREDENTIALS_FILE:-/etc/cloudflare/credentials}"
  CF_API_KEY="${CF_API_KEY:-}"
  CF_API_EMAIL="${CF_API_EMAIL:-}"
  CF_API_TOKEN="${CF_API_TOKEN:-}"
  ZONE_NAME="${ZONE_NAME:-brkn.lol}"
  SUBZONE="${SUBZONE:-vpn}"
  NB_SUBZONE="${NB_SUBZONE:-nb}"
  TS_SUBZONE="${TS_SUBZONE:-ts}"
  ZT_SUBZONE="${ZT_SUBZONE:-zt}"
  ZEROTIER_NETWORK_NAME="${ZEROTIER_NETWORK_NAME:-}"
  ZEROTIER_API_TOKEN="${ZEROTIER_API_TOKEN:-}"
  ZEROTIER_API_TOKEN_FILE="${ZEROTIER_API_TOKEN_FILE:-/etc/zerotier/api-token}"
  TTL="${TTL:-60}"

  while [[ -n "$*" ]]
  do
    case "$1" in
      help|h|-h|--help)
        usage
        exit 0
        ;;
      -d|--debug)
        DEBUG=1
        shift
        ;;
      -k|--dry-run|--dryrun)
        DRY_RUN=1
        shift
        ;;
      -z|--zone)
        ZONE_NAME="$2"
        shift 2
        ;;
      -s|--subzone)
        SUBZONE="$2"
        shift 2
        ;;
      --nb-zone)
        NB_SUBZONE="$2"
        shift 2
        ;;
      --ts-zone)
        TS_SUBZONE="$2"
        shift 2
        ;;
      --zt-zone)
        ZT_SUBZONE="$2"
        shift 2
        ;;
      -t|--ttl)
        TTL="$2"
        shift 2
        ;;
      *)
        {
          echo_error "Unsupported option: $1"
          usage
        } >&2
        exit 2
        ;;
    esac
  done

  if [[ -z "$CF_API_KEY" && -z "$CF_API_TOKEN" ]]
  then
    if [[ ! -e "$CF_CREDENTIALS_FILE" ]]
    then
      echo_error "$CF_CREDENTIALS_FILE: file does not exist." >&2
      exit 2
    fi

    # shellcheck disable=SC1090
    source "$CF_CREDENTIALS_FILE" || exit 3
  fi

  if ! mapfile -t NB_HOSTS_LINES < <(get_nb_hosts)
  then
    NB_HOSTS_LINES=()
  fi

  if ! mapfile -t TS_HOSTS_LINES < <(get_ts_hosts)
  then
    TS_HOSTS_LINES=()
  fi

  if ! mapfile -t ZT_HOSTS_LINES < <(get_zt_hosts)
  then
    ZT_HOSTS_LINES=()
  fi

  declare -A NB_HOSTS
  declare -A TS_HOSTS
  declare -A ZT_HOSTS
  declare -A HOSTS_SEEN

  for line in "${NB_HOSTS_LINES[@]}"
  do
    read -r host ip <<< "$line"
    NB_HOSTS["$host"]="$ip"
    HOSTS_SEEN["$host"]=1
  done

  for line in "${TS_HOSTS_LINES[@]}"
  do
    read -r host ip <<< "$line"
    TS_HOSTS["$host"]="$ip"
    HOSTS_SEEN["$host"]=1
  done

  for line in "${ZT_HOSTS_LINES[@]}"
  do
    read -r host ip <<< "$line"
    ZT_HOSTS["$host"]="$ip"
    HOSTS_SEEN["$host"]=1
  done

  if [[ "${#HOSTS_SEEN[@]}" -eq 0 ]]
  then
    echo_error "No hosts found on netbird or tailscale."
    exit 1
  fi

  RECORDS="$(cf_get_records "$ZONE_NAME")"

  HOST_LIST=()
  while IFS= read -r host
  do
    HOST_LIST+=("$host")
  done < <(printf '%s\n' "${!HOSTS_SEEN[@]}" | sort)

  ERRORS=0
  for host in "${HOST_LIST[@]}"
  do
    local_nb_ip="${NB_HOSTS[$host]:-}"
    local_ts_ip="${TS_HOSTS[$host]:-}"
    local_zt_ip="${ZT_HOSTS[$host]:-}"

    echo_info "ðŸ–¥ï¸ Host: $host - netbird: ${local_nb_ip:-N/A} - tailscale: ${local_ts_ip:-N/A} - zerotier: ${local_zt_ip:-N/A}"

    read -r record_type target <<< "$(record_target "$host" "$local_nb_ip" "$local_ts_ip" "$local_zt_ip")"
    cname="${host}.${SUBZONE}"

    if ! cf_record_update "$cname" "$record_type" "$target"
    then
      ERRORS=$((ERRORS + 1))
    fi
  done

  if [[ "$ERRORS" -eq 0 ]]
  then
    echo_success "There were no errors updating the records."
    exit 0
  fi

  echo_error "There were $ERRORS errors updating the records."
  exit 1
fi
